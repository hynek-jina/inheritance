import {
  require_react_dom
} from "./chunk-IWOBEF4E.js";
import {
  require_jsx_runtime
} from "./chunk-7HXCKB66.js";
import {
  require_react
} from "./chunk-RY7GF66K.js";
import {
  Base64Url,
  EncryptionKey,
  base64UrlToUint8Array,
  constVoid,
  createConsole,
  createIdenticon,
  createLocalAuth,
  createRandomBytes,
  createSlip21,
  createSymmetricCrypto,
  createTime,
  uint8ArrayToBase64Url
} from "./chunk-ZE6P75YZ.js";
import {
  bytesToUtf8,
  utf8ToBytes
} from "./chunk-Z2XCXHOH.js";
import "./chunk-LYLMWGXG.js";
import "./chunk-QABT6O3A.js";
import "./chunk-KEHC4ODF.js";
import "./chunk-X4MTQ2G7.js";
import "./chunk-EHVH4VTN.js";
import "./chunk-3ZJO4ABM.js";
import "./chunk-AKUSJVNE.js";
import "./chunk-HKCYG2EZ.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@evolu/web/dist/src/SharedWebWorker.js
var createSharedWebWorker = (name, createWebWorker) => {
  if (typeof document === "undefined")
    return {
      postMessage: constVoid,
      onMessage: constVoid
    };
  const namespacedName = `evolu-sharedwebworker-${name}`;
  const channel = new BroadcastChannel(namespacedName);
  let worker;
  let onMessageCallback;
  let ownerReady = false;
  const pendingMessages = [];
  channel.onmessage = (event) => {
    const data = event.data;
    if (data.type === "owner-ready") {
      ownerReady = true;
      for (const message of pendingMessages) {
        channel.postMessage({ type: "to-worker", message });
      }
      pendingMessages.length = 0;
    } else if (!worker && data.type === "from-worker") {
      onMessageCallback?.(data.message);
    }
  };
  channel.postMessage({ type: "request-owner-ready" });
  void navigator.locks.request(namespacedName, async () => {
    worker = createWebWorker();
    for (const message of pendingMessages) {
      worker.postMessage(message);
    }
    pendingMessages.length = 0;
    channel.onmessage = (event) => {
      const data = event.data;
      if (data.type === "to-worker") {
        worker.postMessage(data.message);
      } else if (data.type === "request-owner-ready") {
        channel.postMessage({ type: "owner-ready" });
      }
    };
    worker.onmessage = (event) => {
      channel.postMessage({ type: "from-worker", message: event.data });
      onMessageCallback?.(event.data);
    };
    channel.postMessage({ type: "owner-ready" });
    await new Promise(constVoid);
  });
  return {
    postMessage: (message) => {
      if (worker) {
        worker.postMessage(message);
      } else if (ownerReady) {
        channel.postMessage({ type: "to-worker", message });
      } else {
        pendingMessages.push(message);
      }
    },
    onMessage: (callback) => {
      onMessageCallback = callback;
    }
  };
};

// node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  let dbp;
  const getDB = () => {
    if (dbp)
      return dbp;
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    dbp = promisifyRequest(request);
    dbp.then((db) => {
      db.onclose = () => dbp = void 0;
    }, () => {
    });
    return dbp;
  };
  return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}

// node_modules/@evolu/web/dist/src/local-first/LocalAuth.js
var createWebAuthnStore = (deps) => ({
  setItem: async (key, value, options) => {
    if (options?.accessControl === "none") {
      const metadata2 = createMetadata(false);
      await set(key, { value, metadata: metadata2 }, getStore(options.service));
      return { metadata: metadata2 };
    }
    const seed = generateSeed(deps)();
    const authResult = JSON.parse(value);
    const credential = await createCredential(deps)(options?.webAuthnUsername ?? "Evolu User", seed, options?.relyingPartyID, options?.relyingPartyName, options?.webAuthnUserVerification, options?.webAuthnAuthenticatorAttachment);
    const encryptionKey = deriveEncryptionKey(seed);
    const encryptedData = encryptAuthResult(deps)(authResult, encryptionKey);
    const credentialId = uint8ArrayToBase64Url(new Uint8Array(credential.rawId));
    const metadata = createMetadata();
    await set(key, { credentialId, ...encryptedData, metadata }, getStore(options?.service));
    return { metadata };
  },
  getItem: async (key, options) => {
    if (options?.accessControl === "none") {
      const data2 = await get(key, getStore(options.service));
      return data2 ? {
        key,
        value: data2.value,
        service: options.service ?? "default",
        metadata: data2.metadata
      } : null;
    }
    const data = await get(key, getStore(options?.service));
    if (!data) {
      return null;
    }
    try {
      const credential = await getCredential(deps)(data.credentialId, options?.relyingPartyID, options?.webAuthnUserVerification);
      const credentialSeed = extractSeedFromCredential(credential);
      const encryptionKey = deriveEncryptionKey(credentialSeed);
      const authResultVal = decryptAuthResult(deps)(data, encryptionKey);
      if (!authResultVal) {
        return null;
      }
      return {
        key,
        service: options?.service ?? "default",
        value: authResultVal,
        metadata: data.metadata
      };
    } catch (_error) {
      return null;
    }
  },
  deleteItem: async (key, options) => {
    await del(key, getStore(options?.service));
    return true;
  },
  getAllItems: async (options) => {
    const service = options?.service ?? "default";
    const itemKeys = await keys(getStore(service));
    const items = await Promise.all(itemKeys.map(async (key) => {
      const data = await get(key, getStore(service));
      return {
        key,
        service,
        metadata: data?.metadata ?? createMetadata(),
        ...options?.includeValues && data?.value ? { value: data.value } : {}
      };
    }));
    return items;
  },
  clearService: async (options) => {
    await clear(getStore(options?.service));
  }
});
var createMetadata = (isSecure = true) => {
  return {
    backend: "keychain",
    accessControl: isSecure ? "biometryCurrentSet" : "none",
    securityLevel: isSecure ? "biometry" : "software",
    timestamp: Date.now()
  };
};
var getStore = (prefix = "default") => {
  return createStore(prefix, "evolu-auth");
};
var createCredential = (deps) => async (username, seed, relyingPartyID, relyingPartyName, userVerification, authenticatorAttachment) => {
  const options = createCredentialCreationOptions(deps)(username, seed, relyingPartyID, relyingPartyName, userVerification, authenticatorAttachment);
  const credential = await navigator.credentials.create(options);
  if (!credential) {
    throw new Error("Failed to create WebAuthn credential");
  }
  return credential;
};
var getCredential = (deps) => async (credentialId, relyingPartyID, userVerification) => {
  const options = createCredentialRequestOptions(deps)(credentialId, relyingPartyID, userVerification);
  const credential = await navigator.credentials.get(options);
  if (!credential?.response) {
    throw new Error("Failed to get WebAuthn credential");
  }
  return credential;
};
var extractSeedFromCredential = (credential) => {
  const response = credential.response;
  if (!response.userHandle) {
    throw new Error("No userHandle in credential response");
  }
  return new Uint8Array(response.userHandle);
};
var createCredentialCreationOptions = (deps) => (username, seed, relyingPartyID, relyingPartyName, userVerification, authenticatorAttachment) => {
  return {
    publicKey: {
      challenge: generateSeed(deps)(),
      rp: {
        id: relyingPartyID ?? document.location.hostname,
        name: relyingPartyName ?? "Evolu"
      },
      user: {
        id: seed,
        name: username,
        displayName: username
      },
      pubKeyCredParams: [
        { type: "public-key", alg: -8 },
        // Ed25519
        { type: "public-key", alg: -7 },
        // ES256
        { type: "public-key", alg: -257 }
        // RS256
      ],
      attestation: "none",
      authenticatorSelection: {
        // - "platform": Uses the platform's built-in authenticator.
        // - "cross-platform": Uses a device specific authenticator (yubikey, fido2, etc.)
        authenticatorAttachment: authenticatorAttachment ?? "platform",
        // - "discouraged": Only User Presence is needed.
        // - "preferred": User Verification is preferred but not required. Falls back to User Presence.
        // - "required": User Verification MUST occur (biometrics/PIN). Clients may silently downgrade to User Presence only.
        userVerification: userVerification ?? "required",
        // - "discouraged": Server-side credential is preferable, but will accept client-side discoverable credential.
        // - "preferred": Relying Party strongly prefers client-side discoverable credential but will accept server-side credential.
        // - "required": Client-side discoverable credential MUST be created, error if it can't be created.
        residentKey: "required",
        // Included for backwards compatibility. Deprecated in favor of residentKey (true = "required")
        requireResidentKey: true
      }
    }
  };
};
var createCredentialRequestOptions = (deps) => (credentialId, relyingPartyID, userVerification) => {
  return {
    publicKey: {
      challenge: generateSeed(deps)(),
      rpId: relyingPartyID ?? document.location.hostname,
      userVerification: userVerification ?? "preferred",
      allowCredentials: [
        {
          type: "public-key",
          id: base64UrlToUint8Array(Base64Url.orThrow(credentialId))
        }
      ]
    }
  };
};
var deriveEncryptionKey = (seed) => {
  const seed32 = seed.length === 32 ? seed : seed.slice(0, 32);
  return EncryptionKey.orThrow(createSlip21(seed32, ["evolu", "auth"]));
};
var encryptAuthResult = (deps) => (authResult, encryptionKey) => {
  const plaintext = utf8ToBytes(JSON.stringify(authResult));
  const { nonce, ciphertext } = deps.symmetricCrypto.encrypt(plaintext, encryptionKey);
  return {
    nonce: uint8ArrayToBase64Url(nonce),
    ciphertext: uint8ArrayToBase64Url(ciphertext)
  };
};
var decryptAuthResult = (deps) => (encryptedData, encryptionKey) => {
  const nonce = base64UrlToUint8Array(encryptedData.nonce);
  const ciphertext = base64UrlToUint8Array(encryptedData.ciphertext);
  const result = deps.symmetricCrypto.decrypt(ciphertext, encryptionKey, nonce);
  if (!result.ok)
    return null;
  return bytesToUtf8(result.value);
};
var generateSeed = (deps) => () => {
  return deps.randomBytes.create(32);
};

// node_modules/@evolu/web/dist/src/local-first/Platform.js
var reloadApp = (url) => {
  if (typeof document === "undefined") {
    return;
  }
  location.replace(url);
};

// node_modules/@evolu/web/dist/src/local-first/index.js
var randomBytes = createRandomBytes();
var symmetricCrypto = createSymmetricCrypto({ randomBytes });
var createDbWorker = (name) => createSharedWebWorker(name, () => new Worker(new URL("Db.worker.js", import.meta.url), {
  type: "module"
}));
var localAuth = createLocalAuth({
  randomBytes,
  secureStorage: createWebAuthnStore({ randomBytes, symmetricCrypto })
});
var evoluWebDeps = {
  console: createConsole(),
  createDbWorker,
  randomBytes: createRandomBytes(),
  reloadApp,
  time: createTime()
};

// node_modules/@evolu/web/dist/src/WasmSqliteDriver.js
import sqlite3InitModule from "@evolu/sqlite-wasm";
globalThis.sqlite3ApiConfig = {
  warn: (arg) => {
    if (typeof arg === "string" && arg.startsWith("Ignoring inability to install OPFS sqlite3_vfs"))
      return;
    console.warn(arg);
  }
};
var sqlite3Promise = sqlite3InitModule();

// node_modules/@evolu/react-web/dist/index.js
var import_react_dom = __toESM(require_react_dom());

// node_modules/@evolu/react-web/dist/components/EvoluIdenticon.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);
var EvoluIdenticon = ({ id, size = 32, borderRadius = 3, style }) => {
  const svg = (0, import_react.useMemo)(() => createIdenticon(id, style), [id, style]);
  const uri = (0, import_react.useMemo)(() => `data:image/svg+xml,${encodeURIComponent(svg)}`, [svg]);
  return (0, import_jsx_runtime.jsx)("img", { src: uri, width: size, height: size, style: { width: size, height: size, borderRadius }, alt: "Identicon" });
};

// node_modules/@evolu/react-web/dist/index.js
var evoluReactWebDeps = {
  ...evoluWebDeps,
  flushSync: import_react_dom.flushSync
};
export {
  EvoluIdenticon,
  evoluReactWebDeps,
  localAuth
};
//# sourceMappingURL=@evolu_react-web.js.map

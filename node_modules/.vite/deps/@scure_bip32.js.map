{
  "version": 3,
  "sources": ["../../@scure/bip32/index.ts"],
  "sourcesContent": ["/**\n * BIP32 hierarchical deterministic (HD) wallets over secp256k1.\n * @module\n * @example\n * ```js\n * import { HDKey } from \"@scure/bip32\";\n * const hdkey1 = HDKey.fromMasterSeed(seed);\n * const hdkey2 = HDKey.fromExtendedKey(base58key);\n * const hdkey3 = HDKey.fromJSON({ xpriv: string });\n *\n * // props\n * [hdkey1.depth, hdkey1.index, hdkey1.chainCode];\n * console.log(hdkey2.privateKey, hdkey2.publicKey);\n * console.log(hdkey3.derive(\"m/0/2147483647'/1\"));\n * const sig = hdkey3.sign(hash);\n * hdkey3.verify(hash, sig);\n * ```\n */\n/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { secp256k1 as secp } from '@noble/curves/secp256k1.js';\nimport { hmac } from '@noble/hashes/hmac.js';\nimport { ripemd160 } from '@noble/hashes/legacy.js';\nimport { sha256, sha512 } from '@noble/hashes/sha2.js';\nimport { abytes, concatBytes, createView } from '@noble/hashes/utils.js';\nimport { createBase58check } from '@scure/base';\n\nconst Point = secp.Point;\nconst { Fn } = Point;\nconst base58check = createBase58check(sha256);\n\nconst MASTER_SECRET = Uint8Array.from('Bitcoin seed'.split(''), (char) => char.charCodeAt(0));\n\n/** Network-specific versioning. */\nexport interface Versions {\n  private: number;\n  public: number;\n}\n\nconst BITCOIN_VERSIONS: Versions = { private: 0x0488ade4, public: 0x0488b21e };\n/** Hardened offset from Bitcoin, default */\nexport const HARDENED_OFFSET: number = 0x80000000;\n\nconst hash160 = (data: Uint8Array) => ripemd160(sha256(data));\nconst fromU32 = (data: Uint8Array) => createView(data).getUint32(0, false);\nconst toU32 = (n: number): Uint8Array => {\n  if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n    throw new Error('invalid number, should be from 0 to 2**32-1, got ' + n);\n  }\n  const buf = new Uint8Array(4);\n  createView(buf).setUint32(0, n, false);\n  return buf;\n};\n\ninterface HDKeyOpt {\n  versions?: Versions;\n  depth?: number;\n  index?: number;\n  parentFingerprint?: number;\n  chainCode?: Uint8Array;\n  publicKey?: Uint8Array;\n  privateKey?: Uint8Array;\n}\n\n/**\n * HDKey from BIP32\n * @example\n```js\nconst hdkey1 = HDKey.fromMasterSeed(seed);\nconst hdkey2 = HDKey.fromExtendedKey(base58key);\nconst hdkey3 = HDKey.fromJSON({ xpriv: string });\n```\n */\nexport class HDKey {\n  get fingerprint(): number {\n    if (!this.pubHash) {\n      throw new Error('No publicKey set!');\n    }\n    return fromU32(this.pubHash);\n  }\n  get identifier(): Uint8Array | undefined {\n    return this.pubHash;\n  }\n  get pubKeyHash(): Uint8Array | undefined {\n    return this.pubHash;\n  }\n  get privateKey(): Uint8Array | null {\n    return this._privateKey || null;\n  }\n  get publicKey(): Uint8Array | null {\n    return this._publicKey || null;\n  }\n  get privateExtendedKey(): string {\n    const priv = this._privateKey;\n    if (!priv) {\n      throw new Error('No private key');\n    }\n    return base58check.encode(\n      this.serialize(this.versions.private, concatBytes(Uint8Array.of(0), priv))\n    );\n  }\n  get publicExtendedKey(): string {\n    if (!this._publicKey) {\n      throw new Error('No public key');\n    }\n    return base58check.encode(this.serialize(this.versions.public, this._publicKey));\n  }\n\n  static fromMasterSeed(seed: Uint8Array, versions: Versions = BITCOIN_VERSIONS): HDKey {\n    abytes(seed);\n    if (8 * seed.length < 128 || 8 * seed.length > 512) {\n      throw new Error(\n        'HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got ' +\n          seed.length\n      );\n    }\n    const I = hmac(sha512, MASTER_SECRET, seed);\n    const privateKey = I.slice(0, 32);\n    const chainCode = I.slice(32);\n    return new HDKey({ versions, chainCode, privateKey });\n  }\n\n  static fromExtendedKey(base58key: string, versions: Versions = BITCOIN_VERSIONS): HDKey {\n    // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n    const keyBuffer: Uint8Array = base58check.decode(base58key);\n    const keyView = createView(keyBuffer);\n    const version = keyView.getUint32(0, false);\n    const opt = {\n      versions,\n      depth: keyBuffer[4],\n      parentFingerprint: keyView.getUint32(5, false),\n      index: keyView.getUint32(9, false),\n      chainCode: keyBuffer.slice(13, 45),\n    };\n    const key = keyBuffer.slice(45);\n    const isPriv = key[0] === 0;\n    if (version !== versions[isPriv ? 'private' : 'public']) {\n      throw new Error('Version mismatch');\n    }\n    if (isPriv) {\n      return new HDKey({ ...opt, privateKey: key.slice(1) });\n    } else {\n      return new HDKey({ ...opt, publicKey: key });\n    }\n  }\n\n  public static fromJSON(json: { xpriv: string }): HDKey {\n    return HDKey.fromExtendedKey(json.xpriv);\n  }\n  readonly versions: Versions;\n  readonly depth: number = 0;\n  readonly index: number = 0;\n  readonly chainCode: Uint8Array | null = null;\n  readonly parentFingerprint: number = 0;\n  private _privateKey?: Uint8Array;\n  private _publicKey?: Uint8Array;\n  private pubHash: Uint8Array | undefined;\n\n  constructor(opt: HDKeyOpt) {\n    if (!opt || typeof opt !== 'object') {\n      throw new Error('HDKey.constructor must not be called directly');\n    }\n    this.versions = opt.versions || BITCOIN_VERSIONS;\n    this.depth = opt.depth || 0;\n    this.chainCode = opt.chainCode || null;\n    this.index = opt.index || 0;\n    this.parentFingerprint = opt.parentFingerprint || 0;\n    if (!this.depth) {\n      if (this.parentFingerprint || this.index) {\n        throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n      }\n    }\n    if (this.depth > 255) {\n      throw new Error('HDKey: depth exceeds the serializable value 255');\n    }\n    if (opt.publicKey && opt.privateKey) {\n      throw new Error('HDKey: publicKey and privateKey at same time.');\n    }\n    if (opt.privateKey) {\n      if (!secp.utils.isValidSecretKey(opt.privateKey)) throw new Error('Invalid private key');\n      this._privateKey = opt.privateKey;\n      this._publicKey = secp.getPublicKey(opt.privateKey, true);\n    } else if (opt.publicKey) {\n      this._publicKey = Point.fromBytes(opt.publicKey).toBytes(true); // force compressed point\n    } else {\n      throw new Error('HDKey: no public or private key provided');\n    }\n    this.pubHash = hash160(this._publicKey);\n  }\n\n  derive(path: string): HDKey {\n    if (!/^[mM]'?/.test(path)) {\n      throw new Error('Path must start with \"m\" or \"M\"');\n    }\n    if (/^[mM]'?$/.test(path)) {\n      return this;\n    }\n    const parts = path.replace(/^[mM]'?\\//, '').split('/');\n    // tslint:disable-next-line\n    let child: HDKey = this;\n    for (const c of parts) {\n      const m = /^(\\d+)('?)$/.exec(c);\n      const m1 = m && m[1];\n      if (!m || m.length !== 3 || typeof m1 !== 'string')\n        throw new Error('invalid child index: ' + c);\n      let idx = +m1;\n      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n        throw new Error('Invalid index');\n      }\n      // hardened key\n      if (m[2] === \"'\") {\n        idx += HARDENED_OFFSET;\n      }\n      child = child.deriveChild(idx);\n    }\n    return child;\n  }\n\n  deriveChild(index: number): HDKey {\n    if (!this._publicKey || !this.chainCode) {\n      throw new Error('No publicKey or chainCode set');\n    }\n    let data = toU32(index);\n    if (index >= HARDENED_OFFSET) {\n      // Hardened\n      const priv = this._privateKey;\n      if (!priv) {\n        throw new Error('Could not derive hardened child key');\n      }\n      // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n      data = concatBytes(Uint8Array.of(0), priv, data);\n    } else {\n      // Normal child: serP(point(kpar)) || ser32(index)\n      data = concatBytes(this._publicKey, data);\n    }\n    const I = hmac(sha512, this.chainCode, data);\n    const childTweak = I.slice(0, 32);\n    const chainCode = I.slice(32);\n    if (!secp.utils.isValidSecretKey(childTweak)) {\n      throw new Error('Tweak bigger than curve order');\n    }\n    const opt: HDKeyOpt = {\n      versions: this.versions,\n      chainCode,\n      depth: this.depth + 1,\n      parentFingerprint: this.fingerprint,\n      index,\n    };\n    const ctweak = Fn.fromBytes(childTweak);\n    try {\n      // Private parent key -> private child key\n      if (this._privateKey) {\n        const added = Fn.create(Fn.fromBytes(this._privateKey) + ctweak);\n        if (!Fn.isValidNot0(added)) {\n          throw new Error('The tweak was out of range or the resulted private key is invalid');\n        }\n        opt.privateKey = Fn.toBytes(added);\n      } else {\n        const added = Point.fromBytes(this._publicKey).add(Point.BASE.multiply(ctweak));\n        // Cryptographically impossible: hmac-sha512 preimage would need to be found\n        if (added.equals(Point.ZERO)) {\n          throw new Error('The tweak was equal to negative P, which made the result key invalid');\n        }\n        opt.publicKey = added.toBytes(true);\n      }\n      return new HDKey(opt);\n    } catch (err) {\n      return this.deriveChild(index + 1);\n    }\n  }\n\n  sign(hash: Uint8Array): Uint8Array {\n    if (!this._privateKey) {\n      throw new Error('No privateKey set!');\n    }\n    abytes(hash, 32);\n    return secp.sign(hash, this._privateKey, { prehash: false });\n  }\n\n  verify(hash: Uint8Array, signature: Uint8Array): boolean {\n    abytes(hash, 32);\n    abytes(signature, 64);\n    if (!this._publicKey) {\n      throw new Error('No publicKey set!');\n    }\n    return secp.verify(signature, hash, this._publicKey, { prehash: false });\n  }\n\n  wipePrivateData(): this {\n    if (this._privateKey) {\n      this._privateKey.fill(0);\n      this._privateKey = undefined;\n    }\n    return this;\n  }\n  toJSON(): { xpriv: string; xpub: string } {\n    return {\n      xpriv: this.privateExtendedKey,\n      xpub: this.publicExtendedKey,\n    };\n  }\n\n  private serialize(version: number, key: Uint8Array) {\n    if (!this.chainCode) {\n      throw new Error('No chainCode set');\n    }\n    abytes(key, 33);\n    // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n    return concatBytes(\n      toU32(version),\n      new Uint8Array([this.depth]),\n      toU32(this.parentFingerprint),\n      toU32(this.index),\n      this.chainCode,\n      key\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": []
}

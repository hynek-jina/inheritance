import {
  utils
} from "./chunk-KEHC4ODF.js";
import {
  pbkdf2,
  pbkdf2Async
} from "./chunk-EHVH4VTN.js";
import {
  sha256,
  sha512
} from "./chunk-AKUSJVNE.js";
import {
  abytes,
  ahash,
  anumber,
  checkOpts,
  kdfInputToBytes,
  randomBytes
} from "./chunk-HKCYG2EZ.js";

// node_modules/@noble/hashes/webcrypto.js
function _subtle() {
  const cr = typeof globalThis === "object" ? globalThis.crypto : null;
  const sb = cr?.subtle;
  if (typeof sb === "object" && sb != null)
    return sb;
  throw new Error("crypto.subtle must be defined");
}
function createWebHash(name, blockLen, outputLen) {
  const hashC = async (msg) => {
    abytes(msg);
    const crypto = _subtle();
    return new Uint8Array(await crypto.digest(name, msg));
  };
  hashC.webCryptoName = name;
  hashC.outputLen = outputLen;
  hashC.blockLen = blockLen;
  hashC.create = () => {
    throw new Error("not implemented");
  };
  return hashC;
}
function ahashWeb(hash) {
  ahash(hash);
  if (typeof hash.webCryptoName !== "string")
    throw new Error("non-web hash");
}
var sha2562 = createWebHash("SHA-256", 64, 32);
var sha384 = createWebHash("SHA-384", 128, 48);
var sha5122 = createWebHash("SHA-512", 128, 64);
var hmac = (() => {
  const hmac_ = async (hash, key, message) => {
    const crypto = _subtle();
    abytes(key, void 0, "key");
    abytes(message, void 0, "message");
    ahashWeb(hash);
    const wkey = await crypto.importKey("raw", key, { name: "HMAC", hash: hash.webCryptoName }, false, ["sign"]);
    return new Uint8Array(await crypto.sign("HMAC", wkey, message));
  };
  hmac_.create = (_hash, _key) => {
    throw new Error("not implemented");
  };
  return hmac_;
})();
async function pbkdf22(hash, password, salt, opts) {
  const crypto = _subtle();
  ahashWeb(hash);
  const _opts = checkOpts({ dkLen: 32 }, opts);
  const { c, dkLen } = _opts;
  anumber(c, "c");
  anumber(dkLen, "dkLen");
  const _password = kdfInputToBytes(password, "password");
  const _salt = kdfInputToBytes(salt, "salt");
  const key = await crypto.importKey("raw", _password, "PBKDF2", false, [
    "deriveBits"
  ]);
  const deriveOpts = { name: "PBKDF2", salt: _salt, iterations: c, hash: hash.webCryptoName };
  return new Uint8Array(await crypto.deriveBits(deriveOpts, key, 8 * dkLen));
}

// node_modules/@scure/bip39/index.js
var isJapanese = (wordlist) => wordlist[0] === "あいこくしん";
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError("invalid mnemonic type: " + typeof str);
  return str.normalize("NFKD");
}
function normalize(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
function aentropy(ent) {
  abytes(ent);
  if (![16, 20, 24, 28, 32].includes(ent.length))
    throw new Error("invalid entropy length");
}
function generateMnemonic(wordlist, strength = 128) {
  anumber(strength);
  if (strength % 32 !== 0 || strength > 256)
    throw new TypeError("Invalid entropy");
  return entropyToMnemonic(randomBytes(strength / 8), wordlist);
}
var calcChecksum = (entropy) => {
  const bitsLeft = 8 - entropy.length / 4;
  return new Uint8Array([sha256(entropy)[0] >> bitsLeft << bitsLeft]);
};
function getCoder(wordlist) {
  if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== "string")
    throw new Error("Wordlist: expected array of 2048 strings");
  wordlist.forEach((i) => {
    if (typeof i !== "string")
      throw new Error("wordlist: non-string element: " + i);
  });
  return utils.chain(utils.checksum(1, calcChecksum), utils.radix2(11, true), utils.alphabet(wordlist));
}
function mnemonicToEntropy(mnemonic, wordlist) {
  const { words } = normalize(mnemonic);
  const entropy = getCoder(wordlist).decode(words);
  aentropy(entropy);
  return entropy;
}
function entropyToMnemonic(entropy, wordlist) {
  aentropy(entropy);
  const words = getCoder(wordlist).encode(entropy);
  return words.join(isJapanese(wordlist) ? "　" : " ");
}
function validateMnemonic(mnemonic, wordlist) {
  try {
    mnemonicToEntropy(mnemonic, wordlist);
  } catch (e) {
    return false;
  }
  return true;
}
var psalt = (passphrase) => nfkd("mnemonic" + passphrase);
function mnemonicToSeed(mnemonic, passphrase = "") {
  return pbkdf2Async(sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
}
function mnemonicToSeedSync(mnemonic, passphrase = "") {
  return pbkdf2(sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
}
function mnemonicToSeedWebcrypto(mnemonic, passphrase = "") {
  return pbkdf22(sha5122, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
}

export {
  generateMnemonic,
  mnemonicToEntropy,
  entropyToMnemonic,
  validateMnemonic,
  mnemonicToSeed,
  mnemonicToSeedSync,
  mnemonicToSeedWebcrypto
};
//# sourceMappingURL=chunk-QABT6O3A.js.map

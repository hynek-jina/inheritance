{
  "version": 3,
  "sources": ["../../@noble/hashes/src/webcrypto.ts", "../../@scure/bip39/index.js"],
  "sourcesContent": ["import { type Pbkdf2Opt } from './pbkdf2.ts';\nimport {\n  abytes,\n  ahash,\n  anumber,\n  checkOpts,\n  kdfInputToBytes,\n  type CHash,\n  type KDFInput,\n} from './utils.ts';\n\nfunction _subtle(): typeof crypto.subtle {\n  const cr = typeof globalThis === 'object' ? (globalThis as any).crypto : null;\n  const sb = cr?.subtle;\n  if (typeof sb === 'object' && sb != null) return sb;\n  throw new Error('crypto.subtle must be defined');\n}\n\nexport type WebHash = {\n  (msg: Uint8Array): Promise<Uint8Array>;\n  webCryptoName: string;\n  outputLen: number;\n  blockLen: number;\n};\n\nfunction createWebHash(name: string, blockLen: number, outputLen: number): WebHash {\n  const hashC: any = async (msg: Uint8Array) => {\n    abytes(msg);\n    const crypto = _subtle();\n    return new Uint8Array(await crypto.digest(name, msg as BufferSource));\n  };\n  hashC.webCryptoName = name; // make sure it won't interfere with function name\n  hashC.outputLen = outputLen;\n  hashC.blockLen = blockLen;\n  hashC.create = () => {\n    throw new Error('not implemented');\n  };\n  return hashC;\n}\n\nfunction ahashWeb(hash: WebHash) {\n  ahash(hash as any as CHash);\n  if (typeof hash.webCryptoName !== 'string') throw new Error('non-web hash');\n}\n\n/** WebCrypto SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\n// export const sha1: WebHash = createHash('SHA-1', 64, 20);\n\n/** WebCrypto SHA2-256 hash function from RFC 4634. */\nexport const sha256: WebHash = /* @__PURE__ */ createWebHash('SHA-256', 64, 32);\n/** WebCrypto SHA2-384 hash function from RFC 4634. */\nexport const sha384: WebHash = /* @__PURE__ */ createWebHash('SHA-384', 128, 48);\n/** WebCrypto SHA2-512 hash function from RFC 4634. */\nexport const sha512: WebHash = /* @__PURE__ */ createWebHash('SHA-512', 128, 64);\n\n/**\n * WebCrypto HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256. Webcrypto version.\n * @param key - key which would be used to authenticate message\n * @param message - message\n * @example\n * ```js\n * import { hmac, sha256 } from '@noble/hashes/webcrypto.js';\n * const mac1 = await hmac(sha256, 'key', 'message');\n * ```\n */\nexport const hmac: {\n  (hash: WebHash, key: Uint8Array, message: Uint8Array): Promise<Uint8Array>;\n  create(hash: WebHash, key: Uint8Array): any;\n} = /* @__PURE__ */ (() => {\n  const hmac_ = async (\n    hash: WebHash,\n    key: Uint8Array,\n    message: Uint8Array\n  ): Promise<Uint8Array> => {\n    const crypto = _subtle();\n    abytes(key, undefined, 'key');\n    abytes(message, undefined, 'message');\n    ahashWeb(hash);\n    // WebCrypto keys can't be zeroized\n    // prettier-ignore\n    const wkey = await crypto.importKey(\n      'raw',\n      key as BufferSource,\n      { name: 'HMAC', hash: hash.webCryptoName },\n      false,\n      ['sign']\n    );\n    return new Uint8Array(await crypto.sign('HMAC', wkey, message as BufferSource));\n  };\n  hmac_.create = (_hash: WebHash, _key: Uint8Array) => {\n    throw new Error('not implemented');\n  };\n  return hmac_;\n})();\n\n/**\n * WebCrypto HKDF (RFC 5869): derive keys from an initial input.\n * Combines hkdf_extract + hkdf_expand in one step\n * @param hash - hash function that would be used (e.g. sha256). Webcrypto version.\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in bytes\n * @example\n * ```js\n * import { hkdf, sha256 } from '@noble/hashes/webcrypto.js';\n * import { randomBytes } from '@noble/hashes/utils.js';\n * const inputKey = randomBytes(32);\n * const salt = randomBytes(32);\n * const info = 'application-key';\n * const hk1w = await hkdf(sha256, inputKey, salt, info, 32);\n * ```\n */\nexport async function hkdf(\n  hash: WebHash,\n  ikm: Uint8Array,\n  salt: Uint8Array | undefined,\n  info: Uint8Array | undefined,\n  length: number\n): Promise<Uint8Array> {\n  const crypto = _subtle();\n  ahashWeb(hash);\n  abytes(ikm, undefined, 'ikm');\n  anumber(length, 'length');\n  if (salt !== undefined) abytes(salt, undefined, 'salt');\n  if (info !== undefined) abytes(info, undefined, 'info');\n  const wkey = await crypto.importKey('raw', ikm as BufferSource, 'HKDF', false, ['deriveBits']);\n  const opts = {\n    name: 'HKDF',\n    hash: hash.webCryptoName,\n    salt: salt === undefined ? new Uint8Array(0) : salt,\n    info: info === undefined ? new Uint8Array(0) : info,\n  };\n  return new Uint8Array(await crypto.deriveBits(opts, wkey, 8 * length));\n}\n\n/**\n * WebCrypto PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256. Webcrypto version.\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n * @example\n * ```js\n * const key = await pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });\n * ```\n */\nexport async function pbkdf2(\n  hash: WebHash,\n  password: KDFInput,\n  salt: KDFInput,\n  opts: Pbkdf2Opt\n): Promise<Uint8Array> {\n  const crypto = _subtle();\n  ahashWeb(hash);\n  const _opts = checkOpts({ dkLen: 32 }, opts);\n  const { c, dkLen } = _opts;\n  anumber(c, 'c');\n  anumber(dkLen, 'dkLen');\n  const _password = kdfInputToBytes(password, 'password');\n  const _salt = kdfInputToBytes(salt, 'salt');\n  const key = await crypto.importKey('raw', _password as BufferSource, 'PBKDF2', false, [\n    'deriveBits',\n  ]);\n  const deriveOpts = { name: 'PBKDF2', salt: _salt, iterations: c, hash: hash.webCryptoName };\n  return new Uint8Array(await crypto.deriveBits(deriveOpts, key, 8 * dkLen));\n}\n", "/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { pbkdf2, pbkdf2Async } from '@noble/hashes/pbkdf2.js';\nimport { sha256, sha512 } from '@noble/hashes/sha2.js';\nimport { abytes, anumber, randomBytes } from '@noble/hashes/utils.js';\nimport { pbkdf2 as pbkdf2web, sha512 as sha512web } from '@noble/hashes/webcrypto.js';\nimport { utils as baseUtils } from '@scure/base';\n// Japanese wordlist\nconst isJapanese = (wordlist) => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093';\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\n// https://tonsky.me/blog/unicode/#why-is-a----\nfunction nfkd(str) {\n    if (typeof str !== 'string')\n        throw new TypeError('invalid mnemonic type: ' + typeof str);\n    return str.normalize('NFKD');\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(' ');\n    if (![12, 15, 18, 21, 24].includes(words.length))\n        throw new Error('Invalid mnemonic');\n    return { nfkd: norm, words };\n}\nfunction aentropy(ent) {\n    abytes(ent);\n    if (![16, 20, 24, 28, 32].includes(ent.length))\n        throw new Error('invalid entropy length');\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nexport function generateMnemonic(wordlist, strength = 128) {\n    anumber(strength);\n    if (strength % 32 !== 0 || strength > 256)\n        throw new TypeError('Invalid entropy');\n    return entropyToMnemonic(randomBytes(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy) => {\n    // Checksum is ent.length/4 bits long\n    const bitsLeft = 8 - entropy.length / 4;\n    // Zero rightmost \"bitsLeft\" bits in byte\n    // For example: bitsLeft=4 val=10111101 -> 10110000\n    return new Uint8Array([(sha256(entropy)[0] >> bitsLeft) << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string')\n        throw new Error('Wordlist: expected array of 2048 strings');\n    wordlist.forEach((i) => {\n        if (typeof i !== 'string')\n            throw new Error('wordlist: non-string element: ' + i);\n    });\n    return baseUtils.chain(baseUtils.checksum(1, calcChecksum), baseUtils.radix2(11, true), baseUtils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */\nexport function mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    aentropy(entropy);\n    return entropy;\n}\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nexport function entropyToMnemonic(entropy, wordlist) {\n    aentropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */\nexport function validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nconst psalt = (passphrase) => nfkd('mnemonic' + passphrase);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeed(mnemonic, passphrase = '') {\n    return pbkdf2Async(sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });\n}\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeedSync(mnemonic, passphrase = '') {\n    return pbkdf2(sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });\n}\n/**\n * Uses native, built-in functionality, provided by globalThis.crypto.\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedWebcrypto(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeedWebcrypto(mnemonic, passphrase = '') {\n    return pbkdf2web(sha512web, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });\n}\n"],
  "mappings": "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",
  "names": ["sha256", "sha512", "pbkdf2", "pbkdf2", "sha512"]
}

import { NonEmptyReadonlyArray } from "../Array.js";
import { CallbackId } from "../Callbacks.js";
import { ConsoleConfig, ConsoleDep } from "../Console.js";
import { EncryptionKey, RandomBytesDep, SymmetricCryptoDecryptError } from "../Crypto.js";
import { TransferableError } from "../Error.js";
import { RandomDep } from "../Random.js";
import { CreateSqliteDriverDep, SqliteError } from "../Sqlite.js";
import { TimeDep } from "../Time.js";
import { Id, Mnemonic, SimpleName } from "../Type.js";
import { CreateWebSocketDep } from "../WebSocket.js";
import { Worker } from "../Worker.js";
import { AppOwner, OwnerTransport } from "./Owner.js";
import { ProtocolError } from "./Protocol.js";
import { Query, QueryPatches } from "./Query.js";
import { DbSchema, MutationChange } from "./Schema.js";
import { SyncOwner } from "./Sync.js";
import { TimestampConfig, TimestampError } from "./Timestamp.js";
export interface DbConfig extends ConsoleConfig, TimestampConfig {
    /**
     * The name of the Evolu instance. Evolu is multitenant - it can run multiple
     * instances concurrently. Each instance must have a unique name.
     *
     * The instance name is used as the SQLite database filename for persistent
     * storage, ensuring that database files are separated and invisible to each
     * other.
     *
     * The default value is: `Evolu`.
     *
     * ### Example
     *
     * ```ts
     * // name: SimpleName.orThrow("MyApp")
     * ```
     */
    readonly name: SimpleName;
    /**
     * Transport configuration for data sync and backup. Supports single transport
     * or multiple transports simultaneously for redundancy.
     *
     * **Redundancy:** The ideal setup uses at least two completely independent
     * relays - for example, a home relay and a geographically separate relay.
     * Data is sent to both relays simultaneously, providing true redundancy
     * similar to using two independent clouds. This eliminates vendor lock-in and
     * ensures your app continues working regardless of circumstances - whether
     * home relay hardware is stolen or a remote relay provider shuts down.
     *
     * Currently supports:
     *
     * - WebSocket: Real-time bidirectional communication with relay servers
     *
     * Empty transports create local-only instances. Transports can be dynamically
     * added and removed for any owner (including {@link AppOwner}) via
     * {@link Evolu#useOwner}.
     *
     * Use {@link createOwnerWebSocketTransport} to create WebSocket transport
     * configurations with proper URL formatting and {@link OwnerId} inclusion. The
     * {@link OwnerId} in the URL enables relay authentication, allowing relay
     * servers to control access (e.g., for paid tiers or private instances).
     *
     * The default value is:
     *
     * `{ type: "WebSocket", url: "wss://free.evoluhq.com" }`.
     *
     * ### Example
     *
     * ```ts
     * // Single WebSocket relay
     * transports: [{ type: "WebSocket", url: "wss://relay1.example.com" }];
     *
     * // Multiple WebSocket relays for redundancy
     * transports: [
     *   { type: "WebSocket", url: "wss://relay1.example.com" },
     *   { type: "WebSocket", url: "wss://relay2.example.com" },
     *   { type: "WebSocket", url: "wss://relay3.example.com" },
     * ];
     *
     * // Local-only instance (no sync) - useful for device settings or when relay
     * // URL will be provided later (e.g., after authentication), allowing users
     * // to work offline before the app connects
     * transports: [];
     *
     * // Using createOwnerWebSocketTransport helper for relay authentication
     * transports: [
     *   createOwnerWebSocketTransport({
     *     url: "ws://localhost:4000",
     *     ownerId,
     *   }),
     * ];
     * ```
     */
    readonly transports: ReadonlyArray<OwnerTransport>;
    /**
     * External AppOwner to use when creating Evolu instance. Use this when you
     * want to manage AppOwner creation and persistence externally (e.g., with
     * your own authentication system). If omitted, Evolu will automatically
     * create and persist an AppOwner locally.
     *
     * For device-specific settings and account management state, we can use a
     * separate local-only Evolu instance via `transports: []`.
     *
     * ### Example
     *
     * ```ts
     * const ConfigId = id("Config");
     * type ConfigId = typeof ConfigId.Type;
     *
     * const DeviceSchema = {
     *   config: {
     *     id: ConfigId,
     *     key: NonEmptyString50,
     *     value: NonEmptyString50,
     *   },
     * };
     *
     * // Local-only instance for device settings (no sync)
     * const deviceEvolu = createEvolu(evoluReactWebDeps)(DeviceSchema, {
     *   name: SimpleName.orThrow("MyApp-Device"),
     *   transports: [], // No sync - stays local to device
     * });
     *
     * // Main synced instance for user data
     * const evolu = createEvolu(evoluReactWebDeps)(MainSchema, {
     *   name: SimpleName.orThrow("MyApp"),
     *   // Default transports for sync
     * });
     * ```
     */
    readonly externalAppOwner?: AppOwner;
    /**
     * Use in-memory SQLite database instead of persistent storage. Useful for
     * testing or temporary data that doesn't need persistence.
     *
     * In-memory databases exist only in RAM and are completely destroyed when the
     * process ends, making them forensically safe for sensitive data.
     *
     * The default value is: `false`.
     */
    readonly inMemory?: boolean;
    /**
     * Encryption key for the SQLite database.
     *
     * Note: If an unencrypted SQLite database already exists and you provide an
     * encryptionKey, SQLite will throw an error.
     *
     * @experimental
     */
    readonly encryptionKey?: EncryptionKey;
}
export declare const defaultDbConfig: DbConfig;
export type DbWorker = Worker<DbWorkerInput, DbWorkerOutput>;
export type CreateDbWorker = (name: SimpleName) => DbWorker;
export interface CreateDbWorkerDep {
    readonly createDbWorker: CreateDbWorker;
}
export type DbWorkerInput = {
    readonly type: "init";
    readonly config: DbConfig;
    readonly dbSchema: DbSchema;
} | {
    readonly type: "getAppOwner";
} | {
    readonly type: "mutate";
    readonly tabId: Id;
    readonly changes: NonEmptyReadonlyArray<MutationChange>;
    readonly onCompleteIds: ReadonlyArray<CallbackId>;
    readonly subscribedQueries: ReadonlyArray<Query>;
} | {
    readonly type: "query";
    readonly tabId: Id;
    readonly queries: NonEmptyReadonlyArray<Query>;
} | {
    readonly type: "reset";
    readonly onCompleteId: CallbackId;
    readonly reload: boolean;
    readonly restore?: {
        readonly dbSchema: DbSchema;
        readonly mnemonic: Mnemonic;
    };
} | {
    readonly type: "ensureDbSchema";
    readonly dbSchema: DbSchema;
} | {
    readonly type: "export";
    readonly onCompleteId: CallbackId;
} | {
    readonly type: "useOwner";
    readonly use: boolean;
    readonly owner: SyncOwner;
};
export type DbWorkerOutput = {
    readonly type: "onError";
    readonly error: ProtocolError | SqliteError | SymmetricCryptoDecryptError | TimestampError | TransferableError;
} | {
    readonly type: "onGetAppOwner";
    readonly appOwner: AppOwner;
} | {
    readonly type: "onQueryPatches";
    readonly tabId: Id;
    readonly queryPatches: ReadonlyArray<QueryPatches>;
    readonly onCompleteIds: ReadonlyArray<CallbackId>;
} | {
    readonly type: "refreshQueries";
    readonly tabId?: Id;
} | {
    readonly type: "onReset";
    readonly onCompleteId: CallbackId;
    readonly reload: boolean;
} | {
    readonly type: "onExport";
    readonly onCompleteId: CallbackId;
    readonly file: Uint8Array;
};
export type DbWorkerPlatformDeps = ConsoleDep & CreateSqliteDriverDep & CreateWebSocketDep & RandomBytesDep & RandomDep & TimeDep;
export interface PostMessageDep {
    readonly postMessage: (message: DbWorkerOutput) => void;
}
export declare const createDbWorkerForPlatform: (platformDeps: DbWorkerPlatformDeps) => DbWorker;
//# sourceMappingURL=Db.d.ts.map
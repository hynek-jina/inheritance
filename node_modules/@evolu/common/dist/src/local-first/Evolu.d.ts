import { ConsoleDep } from "../Console.js";
import { RandomBytesDep, SymmetricCryptoDecryptError } from "../Crypto.js";
import { TransferableError } from "../Error.js";
import { SqliteError } from "../Sqlite.js";
import { StoreSubscribe } from "../Store.js";
import { TimeDep } from "../Time.js";
import { Mnemonic } from "../Type.js";
import { CreateDbWorkerDep, DbConfig } from "./Db.js";
import { AppOwner } from "./Owner.js";
import { FlushSyncDep, ReloadAppDep } from "./Platform.js";
import { ProtocolError } from "./Protocol.js";
import { Queries, QueriesToQueryRowsPromises, Query, QueryRows, Row } from "./Query.js";
import { CreateQuery, EvoluSchema, IndexesConfig, Mutation, ValidateSchema } from "./Schema.js";
import { SyncOwner } from "./Sync.js";
import { TimestampError } from "./Timestamp.js";
export interface EvoluConfig extends Partial<DbConfig> {
    /**
     * Use the `indexes` option to define SQLite indexes.
     *
     * Table and column names are not typed because Kysely doesn't support it.
     *
     * https://medium.com/@JasonWyatt/squeezing-performance-from-sqlite-indexes-indexes-c4e175f3c346
     *
     * ### Example
     *
     * ```ts
     * const evolu = createEvolu(evoluReactDeps)(Schema, {
     *   indexes: (create) => [
     *     create("todoCreatedAt").on("todo").column("createdAt"),
     *     create("todoCategoryCreatedAt")
     *       .on("todoCategory")
     *       .column("createdAt"),
     *   ],
     * });
     * ```
     */
    readonly indexes?: IndexesConfig;
    /**
     * URL to reload browser tabs after reset or restore.
     *
     * The default value is `/`.
     *
     * Note: This option will be moved to web platform deps in the next major
     * version.
     */
    readonly reloadUrl?: string;
}
export interface Evolu<S extends EvoluSchema = EvoluSchema> extends Disposable {
    /**
     * Subscribe to {@link EvoluError} changes.
     *
     * ### Example
     *
     * ```ts
     * const unsubscribe = evolu.subscribeError(() => {
     *   const error = evolu.getError();
     *   console.log(error);
     * });
     * ```
     */
    readonly subscribeError: StoreSubscribe;
    /** Get {@link EvoluError}. */
    readonly getError: () => EvoluError | null;
    /**
     * Create type-safe SQL {@link Query}.
     *
     * Evolu uses Kysely - the type-safe SQL query builder for TypeScript. See
     * https://kysely.dev.
     *
     * All this function does is compile the Kysely query and serialize it into a
     * unique string. Both operations are fast and cheap.
     *
     * For mutations, use {@link Evolu#insert}, {@link Evolu#update}, or
     * {@link Evolu#upsert}.
     *
     * ### Example
     *
     * ```ts
     * const allTodos = evolu.createQuery((db) =>
     *   db.selectFrom("todo").selectAll(),
     * );
     *
     * const todoById = (id: TodoId) =>
     *   evolu.createQuery((db) =>
     *     db.selectFrom("todo").selectAll().where("id", "=", id),
     *   );
     * ```
     */
    readonly createQuery: CreateQuery<S>;
    /**
     * Load {@link Query} and return a promise with {@link QueryRows}.
     *
     * The returned promise always resolves successfully because there is no
     * reason why loading should fail. All data are local, and the query is typed.
     * Unexpected errors are handled with {@link Evolu#subscribeError}.
     *
     * Loading is batched, and returned promises are cached until resolved to
     * prevent redundant database queries and to support React Suspense (which
     * requires stable promise references while pending).
     *
     * To subscribe a query for automatic updates, use
     * {@link Evolu#subscribeQuery}.
     *
     * ### Example
     *
     * ```ts
     * const allTodos = evolu.createQuery((db) =>
     *   db.selectFrom("todo").selectAll(),
     * );
     * evolu.loadQuery(allTodos).then((rows) => {
     *   console.log(rows);
     * });
     * ```
     */
    readonly loadQuery: <R extends Row>(query: Query<R>) => Promise<QueryRows<R>>;
    /**
     * Load an array of {@link Query} queries and return an array of
     * {@link QueryRows} promises. It's like `queries.map(loadQuery)` but with
     * proper types for returned promises.
     *
     * ### Example
     *
     * ```ts
     * evolu.loadQueries([allTodos, todoById(1)]);
     * ```
     */
    readonly loadQueries: <R extends Row, Q extends Queries<R>>(queries: [...Q]) => [...QueriesToQueryRowsPromises<Q>];
    /**
     * Subscribe to {@link Query} {@link QueryRows} changes.
     *
     * ### Example
     *
     * ```ts
     * const unsubscribe = evolu.subscribeQuery(allTodos)(() => {
     *   const rows = evolu.getQueryRows(allTodos);
     * });
     * ```
     */
    readonly subscribeQuery: (query: Query) => StoreSubscribe;
    /**
     * Get {@link QueryRows}.
     *
     * ### Example
     *
     * ```ts
     * const unsubscribe = evolu.subscribeQuery(allTodos)(() => {
     *   const rows = evolu.getQueryRows(allTodos);
     * });
     * ```
     */
    readonly getQueryRows: <R extends Row>(query: Query<R>) => QueryRows<R>;
    /**
     * Promise that resolves to {@link AppOwner} when available.
     *
     * Note: With web-only deps, this promise will not resolve during SSR because
     * there is no AppOwner on the server.
     *
     * ### Example
     *
     * ```ts
     * const owner = await evolu.appOwner;
     * ```
     */
    readonly appOwner: Promise<AppOwner>;
    /**
     * Inserts a row into the database and returns a {@link Result} with the new
     * {@link Id}.
     *
     * The first argument is the table name, and the second is an object
     * containing the row data. An optional third argument provides mutation
     * options including an `onComplete` callback and `onlyValidate` flag.
     *
     * Returns a Result type - use `.ok` to check if the insertion succeeded, and
     * `.value.id` to access the generated ID on success, or `.error` to handle
     * validation errors.
     *
     * Evolu does not use SQL for mutations to ensure data can be safely and
     * predictably merged without conflicts. Explicit mutations also allow Evolu
     * to automatically update {@link SystemColumns}.
     *
     * ### Example
     *
     * ```ts
     * const result = evolu.insert("todo", {
     *   title: "Learn Evolu",
     *   isCompleted: false,
     * });
     *
     * if (result.ok) {
     *   console.log("Todo created with ID:", result.value.id);
     * } else {
     *   console.error("Validation error:", result.error);
     * }
     *
     * // With onComplete callback
     * evolu.insert(
     *   "todo",
     *   { title: "Another todo" },
     *   {
     *     onComplete: () => {
     *       console.log("Insert completed");
     *     },
     *   },
     * );
     * ```
     */
    insert: Mutation<S, "insert">;
    /**
     * Updates a row in the database and returns a {@link Result} with the existing
     * {@link Id}.
     *
     * The first argument is the table name, and the second is an object
     * containing the row data including the required `id` field. An optional
     * third argument provides mutation options including an `onComplete` callback
     * and `onlyValidate` flag.
     *
     * Returns a Result type - use `.ok` to check if the update succeeded, and
     * `.value.id` to access the ID on success, or `.error` to handle validation
     * errors.
     *
     * Evolu does not use SQL for mutations to ensure data can be safely and
     * predictably merged without conflicts. Explicit mutations also allow Evolu
     * to automatically update {@link SystemColumns}.
     *
     * ### Example
     *
     * ```ts
     * const result = evolu.update("todo", {
     *   id: todoId,
     *   title: "Updated title",
     *   isCompleted: true,
     * });
     *
     * if (result.ok) {
     *   console.log("Todo updated with ID:", result.value.id);
     * } else {
     *   console.error("Validation error:", result.error);
     * }
     *
     * // To delete a row, set isDeleted to true
     * evolu.update("todo", { id: todoId, isDeleted: true });
     *
     * // With onComplete callback
     * evolu.update(
     *   "todo",
     *   { id: todoId, title: "New title" },
     *   {
     *     onComplete: () => {
     *       console.log("Update completed");
     *     },
     *   },
     * );
     * ```
     */
    update: Mutation<S, "update">;
    /**
     * Upserts a row in the database and returns a {@link Result} with the existing
     * {@link Id}.
     *
     * The first argument is the table name, and the second is an object
     * containing the row data including the required `id` field. An optional
     * third argument provides mutation options including an `onComplete` callback
     * and `onlyValidate` flag.
     *
     * This function allows you to use custom IDs and optionally set `createdAt`,
     * which is useful for external systems, data migrations, or when the same row
     * may already be created on a different device.
     *
     * Returns a Result type - use `.ok` to check if the upsert succeeded, and
     * `.value.id` to access the ID on success, or `.error` to handle validation
     * errors.
     *
     * Evolu does not use SQL for mutations to ensure data can be safely and
     * predictably merged without conflicts. Explicit mutations also allow Evolu
     * to automatically update {@link SystemColumns}.
     *
     * ### Example
     *
     * ```ts
     * // Use deterministic ID for stable upserts across devices
     * const stableId = createIdFromString("my-todo-1");
     *
     * const result = evolu.upsert("todo", {
     *   id: stableId,
     *   title: "Learn Evolu",
     *   isCompleted: false,
     * });
     *
     * if (result.ok) {
     *   console.log("Todo upserted with ID:", result.value.id);
     * } else {
     *   console.error("Validation error:", result.error);
     * }
     *
     * // Data migration with custom createdAt
     * evolu.upsert("todo", {
     *   id: externalId,
     *   title: "Migrated todo",
     *   createdAt: new Date("2023-01-01"), // Preserve original timestamp
     * });
     *
     * // With onComplete callback
     * evolu.upsert(
     *   "todo",
     *   { id: stableId, title: "Updated title" },
     *   {
     *     onComplete: () => {
     *       console.log("Upsert completed");
     *     },
     *   },
     * );
     * ```
     */
    upsert: Mutation<S, "upsert">;
    /**
     * Delete {@link AppOwner} and all their data from the current device. After
     * the deletion, Evolu will purge the application state. For browsers, this
     * will reload all tabs using Evolu. For native apps, it will restart the
     * app.
     *
     * Reloading can be turned off via options if you want to provide a different
     * UX.
     */
    readonly resetAppOwner: (options?: {
        readonly reload?: boolean;
    }) => Promise<void>;
    /**
     * Restore {@link AppOwner} with all their synced data. It uses
     * {@link Evolu#resetAppOwner}, so be careful.
     */
    readonly restoreAppOwner: (mnemonic: Mnemonic, options?: {
        readonly reload?: boolean;
    }) => Promise<void>;
    /**
     * Reload the app in a platform-specific way. For browsers, this will reload
     * all tabs using Evolu. For native apps, it will restart the app.
     */
    readonly reloadApp: () => void;
    /**
     * Export SQLite database file as Uint8Array.
     *
     * In the future, it will be possible to import a database and export/import
     * history for 1:1 migrations across owners.
     */
    readonly exportDatabase: () => Promise<Uint8Array<ArrayBuffer>>;
    /**
     * Use a {@link SyncOwner}. Returns a {@link UnuseOwner}.
     *
     * Using an owner means syncing it with its transports, or the transports
     * defined in Evolu config if the owner has no transports defined.
     *
     * Transport are automatically deduplicated and reference-counted, so multiple
     * owners using the same transport will share a single connection.
     *
     * ### Example
     *
     * ```ts
     * // Use an owner (starts syncing).
     * const unuseOwner = evolu.useOwner(shardOwner);
     *
     * // Later, stop using the owner.
     * unuseOwner();
     *
     * // Bulk operations.
     * const unuseOwners = owners.map((owner) => evolu.useOwner(owner));
     * // Later: for (const unuse of unuseOwners) unuse();
     * ```
     *
     * @experimental
     */
    readonly useOwner: (owner: SyncOwner) => UnuseOwner;
}
/** Function returned by {@link Evolu#useOwner} to stop using an {@link SyncOwner}. */
export type UnuseOwner = () => void;
/** Represents errors that can occur in Evolu. */
export type EvoluError = ProtocolError | SqliteError | SymmetricCryptoDecryptError | TimestampError | TransferableError;
export type EvoluDeps = ConsoleDep & CreateDbWorkerDep & Partial<FlushSyncDep> & RandomBytesDep & ReloadAppDep & TimeDep;
/**
 * Creates an {@link Evolu} instance for a platform configured with the specified
 * {@link EvoluSchema} and optional {@link EvoluConfig} providing a typed
 * interface for querying, mutating, and syncing your application's data.
 *
 * ### Example
 *
 * ```ts
 * const TodoId = id("Todo");
 * type TodoId = InferType<typeof TodoId>;
 *
 * const TodoCategoryId = id("TodoCategory");
 * type TodoCategoryId = InferType<typeof TodoCategoryId>;
 *
 * const NonEmptyString50 = maxLength(50, NonEmptyString);
 * type NonEmptyString50 = InferType<typeof NonEmptyString50>;
 *
 * const Schema = {
 *   todo: {
 *     id: TodoId,
 *     title: NonEmptyString1000,
 *     isCompleted: nullOr(SqliteBoolean),
 *     categoryId: nullOr(TodoCategoryId),
 *   },
 *   todoCategory: {
 *     id: TodoCategoryId,
 *     name: NonEmptyString50,
 *   },
 * };
 *
 * const evolu = createEvolu(evoluReactDeps)(Schema);
 * ```
 *
 * ### Instance Caching
 *
 * `createEvolu` caches instances using {@link Instances} by {@link EvoluConfig}
 * name to enable hot reloading and prevent database corruption from multiple
 * connections. For testing, use unique instance names to ensure proper
 * isolation.
 */
export declare const createEvolu: (deps: EvoluDeps) => <S extends EvoluSchema>(schema: ValidateSchema<S> extends never ? S : ValidateSchema<S>, config?: EvoluConfig) => Evolu<S>;
export declare const createQuery: <R extends Row>(queryCallback: Parameters<CreateQuery<EvoluSchema>>[0], options?: Parameters<CreateQuery<EvoluSchema>>[1]) => Query<R>;
//# sourceMappingURL=Evolu.d.ts.map
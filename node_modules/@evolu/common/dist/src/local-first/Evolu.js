import { pack } from "msgpackr";
import { dedupeArray, isNonEmptyArray, isNonEmptyReadonlyArray, } from "../Array.js";
import { assert, assertNonEmptyReadonlyArray } from "../Assert.js";
import { createCallbacks } from "../Callbacks.js";
import { eqArrayNumber } from "../Eq.js";
import { exhaustiveCheck } from "../Function.js";
import { createInstances } from "../Instances.js";
import { err, ok } from "../Result.js";
import { isSqlMutation, SqliteBoolean, sqliteBooleanToBoolean, } from "../Sqlite.js";
import { createStore } from "../Store.js";
import { createId, } from "../Type.js";
import { defaultDbConfig } from "./Db.js";
import { applyPatches, createSubscribedQueries, emptyRows, serializeQuery, } from "./Query.js";
import { evoluSchemaToDbSchema, insertable, kysely, updateable, upsertable, } from "./Schema.js";
import { DbChange } from "./Storage.js";
import { initialSyncState } from "./Sync.js";
const evoluInstances = createInstances();
/**
 * Unique identifier for the current browser tab or app instance, lazily
 * initialized on first use to distinguish between multiple tabs.
 */
let tabId = null;
/**
 * Creates an {@link Evolu} instance for a platform configured with the specified
 * {@link EvoluSchema} and optional {@link EvoluConfig} providing a typed
 * interface for querying, mutating, and syncing your application's data.
 *
 * ### Example
 *
 * ```ts
 * const TodoId = id("Todo");
 * type TodoId = InferType<typeof TodoId>;
 *
 * const TodoCategoryId = id("TodoCategory");
 * type TodoCategoryId = InferType<typeof TodoCategoryId>;
 *
 * const NonEmptyString50 = maxLength(50, NonEmptyString);
 * type NonEmptyString50 = InferType<typeof NonEmptyString50>;
 *
 * const Schema = {
 *   todo: {
 *     id: TodoId,
 *     title: NonEmptyString1000,
 *     isCompleted: nullOr(SqliteBoolean),
 *     categoryId: nullOr(TodoCategoryId),
 *   },
 *   todoCategory: {
 *     id: TodoCategoryId,
 *     name: NonEmptyString50,
 *   },
 * };
 *
 * const evolu = createEvolu(evoluReactDeps)(Schema);
 * ```
 *
 * ### Instance Caching
 *
 * `createEvolu` caches instances using {@link Instances} by {@link EvoluConfig}
 * name to enable hot reloading and prevent database corruption from multiple
 * connections. For testing, use unique instance names to ensure proper
 * isolation.
 */
export const createEvolu = (deps) => (schema, config) => evoluInstances.ensure(config?.name ?? defaultDbConfig.name, () => createEvoluInstance(deps)(schema, config), (evolu) => {
    // Hot reloading. Note that indexes are intentionally omitted.
    evolu.ensureSchema(schema);
});
const createEvoluInstance = (deps) => (schema, config) => {
    deps.console.enabled = config?.enableLogging ?? false;
    const { indexes, reloadUrl = "/", ...partialDbConfig } = config ?? {};
    const dbConfig = { ...defaultDbConfig, ...partialDbConfig };
    deps.console.log("[evolu]", "createEvoluInstance", {
        name: dbConfig.name,
    });
    const errorStore = createStore(null);
    const rowsStore = createStore(new Map());
    const { promise: appOwner, resolve: resolveAppOwner } = Promise.withResolvers();
    if (config?.externalAppOwner) {
        resolveAppOwner(config.externalAppOwner);
    }
    // TODO: Update it for the owner-api
    const _syncStore = createStore(initialSyncState);
    const subscribedQueries = createSubscribedQueries(rowsStore);
    const loadingPromises = createLoadingPromises(subscribedQueries);
    const onCompleteCallbacks = createCallbacks(deps);
    const exportCallbacks = createCallbacks(deps);
    const dbWorker = deps.createDbWorker(dbConfig.name);
    const getTabId = () => {
        tabId ??= createId(deps);
        return tabId;
    };
    // Worker responses are delivered to all tabs. Each case must handle this
    // properly (e.g., AppOwner promise resolves only once, tabId filtering).
    dbWorker.onMessage((message) => {
        switch (message.type) {
            case "onError": {
                errorStore.set(message.error);
                break;
            }
            case "onGetAppOwner": {
                resolveAppOwner(message.appOwner);
                break;
            }
            case "onQueryPatches": {
                if (message.tabId !== getTabId())
                    return;
                const state = rowsStore.get();
                const nextState = new Map([
                    ...state,
                    ...message.queryPatches.map(({ query, patches }) => [
                        query,
                        applyPatches(patches, state.get(query) ?? emptyRows),
                    ]),
                ]);
                for (const { query } of message.queryPatches) {
                    loadingPromises.resolve(query, nextState.get(query) ?? emptyRows);
                }
                if (deps.flushSync && message.onCompleteIds.length > 0) {
                    deps.flushSync(() => {
                        rowsStore.set(nextState);
                    });
                }
                else {
                    rowsStore.set(nextState);
                }
                for (const id of message.onCompleteIds) {
                    onCompleteCallbacks.execute(id);
                }
                break;
            }
            case "refreshQueries": {
                if (message.tabId && message.tabId === getTabId())
                    return;
                const loadingPromisesQueries = loadingPromises.getQueries();
                loadingPromises.releaseUnsubscribedOnMutation();
                const queries = dedupeArray([
                    ...loadingPromisesQueries,
                    ...subscribedQueries.get(),
                ]);
                if (isNonEmptyReadonlyArray(queries)) {
                    dbWorker.postMessage({ type: "query", tabId: getTabId(), queries });
                }
                break;
            }
            case "onReset": {
                if (message.reload) {
                    deps.reloadApp(reloadUrl);
                }
                else {
                    onCompleteCallbacks.execute(message.onCompleteId);
                }
                break;
            }
            case "onExport": {
                exportCallbacks.execute(message.onCompleteId, message.file);
                break;
            }
            default:
                exhaustiveCheck(message);
        }
    });
    const dbSchema = evoluSchemaToDbSchema(schema, indexes);
    const mutationTypesCache = new Map();
    // Lazy create mutation Types like this: `insertable(Schema.todo)`
    const getMutationType = (table, kind) => {
        let types = mutationTypesCache.get(kind);
        if (!types) {
            types = new Map();
            mutationTypesCache.set(kind, types);
        }
        let type = types.get(table);
        if (!type) {
            type = { insert: insertable, update: updateable, upsert: upsertable }[kind](schema[table]);
            types.set(table, type);
        }
        return type;
    };
    dbWorker.postMessage({ type: "init", config: dbConfig, dbSchema });
    // We can't use `init` to get AppOwner because `init` runs only once per n tabs.
    dbWorker.postMessage({ type: "getAppOwner" });
    const loadQueryMicrotaskQueue = [];
    const mutateMicrotaskQueue = [];
    const useOwnerMicrotaskQueue = [];
    const createMutation = (kind) => (table, props, options) => {
        const result = getMutationType(table, kind).fromUnknown(props);
        const id = kind === "insert"
            ? createId(deps)
            : props.id;
        if (options?.onlyValidate !== true) {
            if (!result.ok) {
                // Mark the transaction as invalid by pushing null
                mutateMicrotaskQueue.push([null, undefined]);
            }
            else {
                const { id: _, isDeleted, ...values } = result.value;
                const dbChange = {
                    table,
                    id,
                    values,
                    isInsert: kind === "insert" || kind === "upsert",
                    isDelete: SqliteBoolean.is(isDeleted)
                        ? sqliteBooleanToBoolean(isDeleted)
                        : null,
                };
                assert(DbChange.is(dbChange), `Invalid DbChange for table '${table}': Please check schema type errors.`);
                mutateMicrotaskQueue.push([
                    { ...dbChange, ownerId: options?.ownerId },
                    options?.onComplete,
                ]);
            }
            if (mutateMicrotaskQueue.length === 1) {
                queueMicrotask(processMutationQueue);
            }
        }
        if (result.ok)
            return ok({ id });
        return err(result.error);
    };
    const processMutationQueue = () => {
        const changes = [];
        const onCompletes = [];
        for (const [change, onComplete] of mutateMicrotaskQueue) {
            if (change !== null)
                changes.push(change);
            if (onComplete)
                onCompletes.push(onComplete);
        }
        const queueLength = mutateMicrotaskQueue.length;
        mutateMicrotaskQueue.length = 0;
        // Don't process any mutations if there was a validation error.
        // All mutations within a queue run as a single transaction.
        if (changes.length !== queueLength) {
            return;
        }
        const onCompleteIds = onCompletes.map(onCompleteCallbacks.register);
        loadingPromises.releaseUnsubscribedOnMutation();
        if (!isNonEmptyArray(changes))
            return;
        dbWorker.postMessage({
            type: "mutate",
            tabId: getTabId(),
            changes,
            onCompleteIds,
            subscribedQueries: subscribedQueries.get(),
        });
    };
    const evolu = {
        subscribeError: errorStore.subscribe,
        getError: errorStore.get,
        createQuery,
        loadQuery: (query) => {
            const { promise, isNew } = loadingPromises.get(query);
            if (isNew) {
                loadQueryMicrotaskQueue.push(query);
                if (loadQueryMicrotaskQueue.length === 1) {
                    queueMicrotask(() => {
                        const queries = dedupeArray(loadQueryMicrotaskQueue);
                        loadQueryMicrotaskQueue.length = 0;
                        assertNonEmptyReadonlyArray(queries);
                        deps.console.log("[evolu]", "loadQuery", { queries });
                        dbWorker.postMessage({
                            type: "query",
                            tabId: getTabId(),
                            queries,
                        });
                    });
                }
            }
            return promise;
        },
        loadQueries: (queries) => queries.map(evolu.loadQuery),
        subscribeQuery: (query) => (listener) => {
            // Call the listener only if the result has been changed.
            let previousRows = null;
            const unsubscribe = subscribedQueries.subscribe(query)(() => {
                const rows = evolu.getQueryRows(query);
                if (previousRows === rows)
                    return;
                previousRows = rows;
                listener();
            });
            return () => {
                previousRows = null;
                unsubscribe();
            };
        },
        getQueryRows: (query) => (rowsStore.get().get(query) ?? emptyRows),
        appOwner,
        // TODO: Update it for the owner-api
        // subscribeSyncState: syncStore.subscribe,
        // getSyncState: syncStore.get,
        insert: createMutation("insert"),
        update: createMutation("update"),
        upsert: createMutation("upsert"),
        resetAppOwner: (options) => {
            const { promise, resolve } = Promise.withResolvers();
            const onCompleteId = onCompleteCallbacks.register(resolve);
            dbWorker.postMessage({
                type: "reset",
                onCompleteId,
                reload: options?.reload ?? true,
            });
            return promise;
        },
        restoreAppOwner: (mnemonic, options) => {
            const { promise, resolve } = Promise.withResolvers();
            const onCompleteId = onCompleteCallbacks.register(resolve);
            dbWorker.postMessage({
                type: "reset",
                onCompleteId,
                reload: options?.reload ?? true,
                restore: { mnemonic, dbSchema },
            });
            return promise;
        },
        reloadApp: () => {
            deps.reloadApp(reloadUrl);
        },
        ensureSchema: (schema) => {
            mutationTypesCache.clear();
            const dbSchema = evoluSchemaToDbSchema(schema);
            dbWorker.postMessage({ type: "ensureDbSchema", dbSchema });
        },
        exportDatabase: () => {
            const { promise, resolve } = Promise.withResolvers();
            const onCompleteId = exportCallbacks.register(resolve);
            dbWorker.postMessage({ type: "export", onCompleteId });
            return promise;
        },
        useOwner: (owner) => {
            const scheduleOwnerQueueProcessing = () => {
                if (useOwnerMicrotaskQueue.length !== 1)
                    return;
                queueMicrotask(() => {
                    const queue = [...useOwnerMicrotaskQueue];
                    useOwnerMicrotaskQueue.length = 0;
                    const result = [];
                    const skipIndices = new Set();
                    for (let i = 0; i < queue.length; i++) {
                        if (skipIndices.has(i))
                            continue;
                        const [currentOwner, currentUse, currentOwnerSerialized] = queue[i];
                        // Look for opposite action with same owner
                        for (let j = i + 1; j < queue.length; j++) {
                            if (skipIndices.has(j))
                                continue;
                            const [, otherUse, otherOwnerSerialized] = queue[j];
                            if (currentUse !== otherUse &&
                                eqArrayNumber(currentOwnerSerialized, otherOwnerSerialized)) {
                                // Found cancel-out pair, skip both
                                skipIndices.add(i).add(j);
                                break;
                            }
                        }
                        if (!skipIndices.has(i)) {
                            result.push([currentOwner, currentUse, currentOwnerSerialized]);
                        }
                    }
                    for (const [owner, use] of result) {
                        dbWorker.postMessage({ type: "useOwner", owner, use });
                    }
                });
            };
            useOwnerMicrotaskQueue.push([owner, true, pack(owner)]);
            scheduleOwnerQueueProcessing();
            const unuse = () => {
                useOwnerMicrotaskQueue.push([owner, false, pack(owner)]);
                scheduleOwnerQueueProcessing();
            };
            return unuse;
        },
        /** Disposal is not implemented yet. */
        [Symbol.dispose]: () => {
            throw new Error("Evolu instance disposal is not yet implemented");
        },
    };
    return evolu;
};
export const createQuery = (queryCallback, options) => {
    const compiledQuery = queryCallback(kysely).compile();
    if (isSqlMutation(compiledQuery.sql))
        throw new Error("SQL mutation (INSERT, UPDATE, DELETE, etc.) isn't allowed in the Evolu `createQuery` function. Kysely suggests it because there is no read-only Kysely yet, and removing such an API is not possible. For mutations, use Evolu Mutation API.");
    return serializeQuery({
        sql: compiledQuery.sql,
        parameters: compiledQuery.parameters,
        ...(options && { options }),
    });
};
const createLoadingPromises = (subscribedQueries) => {
    const loadingPromiseMap = new Map();
    return {
        get: (query) => {
            let loadingPromise = loadingPromiseMap.get(query);
            const isNew = !loadingPromise;
            if (!loadingPromise) {
                const { promise, resolve } = Promise.withResolvers();
                loadingPromise = { resolve, promise, releaseOnResolve: false };
                loadingPromiseMap.set(query, loadingPromise);
            }
            return {
                promise: loadingPromise.promise,
                isNew,
            };
        },
        resolve: (query, rows) => {
            const loadingPromise = loadingPromiseMap.get(query);
            if (!loadingPromise)
                return;
            if (loadingPromise.promise.status !== "fulfilled") {
                loadingPromise.resolve(rows);
            }
            else {
                loadingPromise.promise = Promise.resolve(rows);
            }
            // Set status and value fields for React's `use` Hook to unwrap synchronously.
            // While undocumented in React docs, React still uses these properties internally,
            // and Evolu's own promise caching logic depends on checking `promise.status`.
            // https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md
            void Object.assign(loadingPromise.promise, {
                status: "fulfilled",
                value: rows,
            });
            if (loadingPromise.releaseOnResolve) {
                loadingPromiseMap.delete(query);
            }
        },
        releaseUnsubscribedOnMutation: () => {
            [...loadingPromiseMap.entries()]
                .filter(([query]) => !subscribedQueries.has(query))
                .forEach(([query, loadingPromise]) => {
                if (loadingPromise.promise.status === "fulfilled") {
                    loadingPromiseMap.delete(query);
                }
                else {
                    loadingPromise.releaseOnResolve = true;
                }
            });
        },
        getQueries: () => Array.from(loadingPromiseMap.keys()),
    };
};

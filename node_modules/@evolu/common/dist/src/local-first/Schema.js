import * as Kysely from "kysely";
import { createRecord, getProperty, mapObject, } from "../Object.js";
import { ok } from "../Result.js";
import { sql, SqliteBoolean, } from "../Sqlite.js";
import { array, DateIso, nullableToOptional, nullOr, object, omit, optional, record, set, String, validMutationSize, } from "../Type.js";
import { OwnerId } from "./Owner.js";
import { readonly } from "../Function.js";
export const evoluSchemaToDbSchema = (schema, indexesConfig) => {
    const tables = mapObject(schema, (table) => new Set(Object.keys(table).filter((k) => k !== "id")));
    const indexes = indexesConfig
        ? indexesConfig(createIndex).map((index) => ({
            name: index.toOperationNode().name.name,
            sql: index.compile().sql,
        }))
        : [];
    return { tables, indexes };
};
/**
 * System columns that are implicitly defined by Evolu.
 *
 * - `createdAt`: Set by Evolu on row creation, derived from {@link Timestamp}.
 * - `updatedAt`: Set by Evolu on every row change, derived from {@link Timestamp}.
 * - `isDeleted`: Soft delete flag created by Evolu and used by the developer to
 *   mark rows as deleted.
 * - `ownerId`: Represents ownership and logically partitions the database.
 */
export const SystemColumns = object({
    createdAt: DateIso,
    updatedAt: DateIso,
    isDeleted: nullOr(SqliteBoolean),
    ownerId: OwnerId,
});
export const systemColumns = readonly(new Set(Object.keys(SystemColumns.props)));
export const systemColumnsWithId = readonly([...systemColumns, "id"]);
/**
 * Type Factory to create insertable {@link Type}. It makes nullable Types
 * optional (so they are not required), omits Id, and ensures the
 * {@link maxMutationSize}.
 *
 * ### Example
 *
 * ```ts
 * const InsertableTodo = insertable(Schema.todo);
 * type InsertableTodo = typeof InsertableTodo.Type;
 * const todo = InsertableTodo.from({ title });
 * if (!todo.ok) return; // handle errors
 * ```
 */
export const insertable = (props) => {
    const optionalNullable = nullableToOptional(props);
    const withoutId = omit(optionalNullable, "id");
    return validMutationSize(withoutId);
};
/**
 * Type Factory to create updateable {@link Type}. It makes everything except for
 * the `id` column optional (so they are not required) and ensures the
 * {@link maxMutationSize}.
 *
 * ### Example
 *
 * ```ts
 * const UpdateableTodo = updateable(Schema.todo);
 * type UpdateableTodo = typeof UpdateableTodo.Type;
 *
 * // `id` is required; all other fields are optional.
 * const todoResult = UpdateableTodo.from({
 *   id: "123",
 *   title: "New Title",
 * });
 * if (!todo.ok) return; // handle errors
 * ```
 */
export const updateable = (props) => {
    const propsWithIsDeleted = { ...props, isDeleted: SqliteBoolean };
    const updateableProps = mapObject(propsWithIsDeleted, (value, key) => key === "id" ? value : optional(value));
    return validMutationSize(object(updateableProps));
};
/**
 * Type Factory to create an upsertable Type. It makes nullable Types optional
 * (so they are not required) and ensures the {@link maxMutationSize}.
 *
 * Upsert is like insert, except it requires an ID. It's useful for inserting
 * rows with external ID via {@link createIdFromString}.
 *
 * Note that it's not possible to upsert a row with `createdAt` nor `updatedAt`,
 * because they are derived from {@link CrdtMessage} timestamp. For external
 * createdAt, use a different column.
 *
 * ### Example
 *
 * ```ts
 * const UpsertableTodo = upsertable(Schema.todo);
 * type UpsertableTodo = typeof UpsertableTodo.Type;
 * const todo = UpsertableTodo.from({
 *   id,
 *   title,
 * });
 * if (!todo.ok) return; // handle errors
 * ```
 */
export const upsertable = (props) => {
    const propsWithDefaults = {
        ...props,
        isDeleted: optional(SqliteBoolean),
    };
    return validMutationSize(nullableToOptional(propsWithDefaults));
};
export const DbIndex = object({ name: String, sql: String });
export const DbSchema = object({
    tables: record(String, set(String)),
    indexes: array(DbIndex),
});
/** Get the current database schema by reading SQLite metadata. */
export const getDbSchema = (deps) => ({ allIndexes = false } = {}) => {
    const tables = createRecord();
    const tableAndColumnInfoRows = deps.sqlite.exec(sql `
      select
        sqlite_master.name as tableName,
        table_info.name as columnName
      from
        sqlite_master
        join pragma_table_info(sqlite_master.name) as table_info;
    `);
    if (!tableAndColumnInfoRows.ok)
        return tableAndColumnInfoRows;
    tableAndColumnInfoRows.value.rows.forEach((row) => {
        const { tableName, columnName } = row;
        (tables[tableName] ??= new Set()).add(columnName);
    });
    const indexesRows = deps.sqlite.exec(allIndexes
        ? sql `
            select name, sql
            from sqlite_master
            where type = 'index' and name not like 'sqlite_%';
          `
        : sql `
            select name, sql
            from sqlite_master
            where
              type = 'index'
              and name not like 'sqlite_%'
              and name not like 'evolu_%';
          `);
    if (!indexesRows.ok)
        return indexesRows;
    const indexes = indexesRows.value.rows.map((row) => ({
        name: row.name,
        /**
         * SQLite returns "CREATE INDEX" for "create index" for some reason.
         * Other keywords remain unchanged. We have to normalize the casing for
         * {@link indexesAreEqual} manually.
         */
        sql: row.sql
            .replace("CREATE INDEX", "create index")
            .replace("CREATE UNIQUE INDEX", "create unique index"),
    }));
    return ok({ tables, indexes });
};
const indexesAreEqual = (self, that) => self.name === that.name && self.sql === that.sql;
export const ensureDbSchema = (deps) => (newSchema, currentSchema) => {
    const queries = [];
    if (!currentSchema) {
        const dbSchema = getDbSchema(deps)();
        if (!dbSchema.ok)
            return dbSchema;
        currentSchema = dbSchema.value;
    }
    for (const [tableName, newColumns] of Object.entries(newSchema.tables)) {
        const currentColumns = getProperty(currentSchema.tables, tableName);
        if (!currentColumns) {
            queries.push(createAppTable(tableName, newColumns));
        }
        else {
            for (const newColumn of newColumns.difference(currentColumns)) {
                queries.push(sql `
            alter table ${sql.identifier(tableName)}
            add column ${sql.identifier(newColumn)} any;
          `);
            }
        }
    }
    // Remove current indexes that are not in the newSchema.
    currentSchema.indexes
        .filter((currentIndex) => !newSchema.indexes.some((newIndex) => indexesAreEqual(newIndex, currentIndex)))
        .forEach((index) => {
        queries.push(sql `drop index ${sql.identifier(index.name)};`);
    });
    // Add new indexes that are not in the currentSchema.
    newSchema.indexes
        .filter((newIndex) => !currentSchema.indexes.some((currentIndex) => indexesAreEqual(newIndex, currentIndex)))
        .forEach((newIndex) => {
        queries.push({ sql: `${newIndex.sql};`, parameters: [] });
    });
    for (const query of queries) {
        const result = deps.sqlite.exec(query);
        if (!result.ok)
            return result;
    }
    return ok();
};
const createAppTable = (tableName, columns) => sql `
  create table ${sql.identifier(tableName)} (
    "id" text,
    ${sql.raw(`${[...systemColumns, ...columns]
    // With strict tables and any type, data is preserved exactly as received
    // without any type affinity coercion. This allows storing any data type
    // while maintaining strict null enforcement for primary key columns.
    // TODO: Use proper SQLite types for system columns (text for createdAt,
    // updatedAt, ownerId, integer for isDeleted) instead of "any".
    .map((name) => `${sql.identifier(name).sql} any`)
    .join(", ")}, `)}
    primary key ("ownerId", "id")
  )
  without rowid, strict;
`;
// https://kysely.dev/docs/recipes/splitting-query-building-and-execution
export const kysely = new Kysely.Kysely({
    dialect: {
        createAdapter: () => new Kysely.SqliteAdapter(),
        createDriver: () => new Kysely.DummyDriver(),
        createIntrospector() {
            throw new Error("Not implemeneted");
        },
        createQueryCompiler: () => new Kysely.SqliteQueryCompiler(),
    },
});
const createIndex = kysely.schema.createIndex.bind(kysely.schema);

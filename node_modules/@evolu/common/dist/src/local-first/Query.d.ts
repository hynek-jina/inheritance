import { Brand } from "../Brand.js";
import { Result } from "../Result.js";
import { SqliteDep, SqliteError, SqliteQuery, SqliteRow, SqliteValue } from "../Sqlite.js";
import { Store, StoreSubscribe } from "../Store.js";
import { Id } from "../Type.js";
import { Simplify } from "../Types.js";
/**
 * A type-safe SQL query.
 *
 * ### Example
 *
 * ```ts
 * const allTodos = evolu.createQuery((db) =>
 *   db.selectFrom("todo").selectAll(),
 * );
 * type AllTodosRow = typeof allTodos.Row;
 * ```
 */
export type Query<R extends Row = Row> = string & Brand<"Query"> & {
    /**
     * A shorthand for {@link InferRow}.
     *
     * ### Example
     *
     * ```ts
     * const allTodos = evolu.createQuery((db) =>
     *   db.selectFrom("todo").selectAll(),
     * );
     * type AllTodosRow = typeof allTodos.Row;
     * ```
     */
    Row: R;
};
/**
 * Evolu serializes {@link SqliteQuery} into a string to be easily used as a key
 * and for comparison.
 */
export declare const serializeQuery: <R extends Row>(query: SqliteQuery) => Query<R>;
export declare const deserializeQuery: <R extends Row>(query: Query<R>) => SqliteQuery;
export type InferRow<T extends Query> = T extends Query<infer R> ? R : never;
export interface Row {
    readonly [key: string]: SqliteValue | Row | ReadonlyArray<Row>;
}
export declare const emptyRows: ReadonlyArray<Row>;
/** Rows returned by a query. */
export type QueryRows<R extends Row = Row> = ReadonlyArray<Readonly<Simplify<R>>>;
export type Queries<R extends Row = Row> = ReadonlyArray<Query<R>>;
export type QueriesToQueryRows<Q extends Queries> = {
    [P in keyof Q]: Q[P] extends Query<infer R> ? QueryRows<R> : never;
};
export type QueriesToQueryRowsPromises<Q extends Queries> = {
    [P in keyof Q]: Q[P] extends Query<infer R> ? Promise<QueryRows<R>> : never;
};
export type QueryRowsMap = ReadonlyMap<Query, ReadonlyArray<Row>>;
export interface SubscribedQueries {
    subscribe: (query: Query) => StoreSubscribe;
    has: (query: Query) => boolean;
    get: () => ReadonlyArray<Query>;
}
export declare const createSubscribedQueries: (rowsStore: Store<QueryRowsMap>) => SubscribedQueries;
export interface GetQueryRowsCacheDep {
    readonly getQueryRowsCache: GetQueryRowsCache;
}
export type GetQueryRowsCache = (tabId: Id) => QueryRowsCache;
export interface QueryRowsCache {
    readonly set: (queriesRows: ReadonlyArray<readonly [Query, ReadonlyArray<SqliteRow>]>) => void;
    readonly get: () => QueryRowsMap;
}
export declare const createGetQueryRowsCache: () => GetQueryRowsCache;
export declare const loadQueries: (deps: GetQueryRowsCacheDep & SqliteDep) => (tabId: Id, queries: ReadonlyArray<Query>) => Result<ReadonlyArray<QueryPatches>, SqliteError>;
export interface QueryPatches {
    readonly query: Query;
    readonly patches: ReadonlyArray<Patch>;
}
export type Patch = ReplaceAllPatch | ReplaceAtPatch;
export interface ReplaceAllPatch {
    readonly op: "replaceAll";
    readonly value: ReadonlyArray<Row>;
}
export interface ReplaceAtPatch {
    readonly op: "replaceAt";
    readonly index: number;
    readonly value: Row;
}
/**
 * We detect only changes in the whole result and in-place edits. In the future,
 * we will add more heuristics. We will probably not implement the Myers diff
 * algorithm because it's faster to rerender all than to compute many detailed
 * patches. We will only implement logic a developer would implement manually,
 * if necessary.
 */
export declare const makePatches: (previousRows: ReadonlyArray<Row> | undefined, nextRows: ReadonlyArray<Row>) => ReadonlyArray<Patch>;
export declare const applyPatches: (patches: ReadonlyArray<Patch>, current: ReadonlyArray<Row>) => ReadonlyArray<Row>;
/**
 * A unique identifier prepended to JSON-encoded strings. This allows safe
 * detection and parsing of only those columns that require JSON.parse.
 *
 * The identifier is a cryptographically random Evolu Id, ensuring uniqueness
 * and preventing malicious actors from inserting fake data that could be
 * misinterpreted as JSON by the application.
 *
 * Note: The same queries created by different browser tabs will have different
 * identifiers and thus be considered different and cached separately. This is
 * usually not a big deal, but if needed, the DB cache can be optimized by
 * passing the kyselyJsonIdentifier into the DB worker during initialization,
 * allowing queries to be grouped and recognized across tabs or sessions.
 *
 * See: https://github.com/kysely-org/kysely/issues/1372#issuecomment-2702773948
 */
export declare const kyselyJsonIdentifier: string & Brand<"Id">;
export declare const parseSqliteJsonArray: <T>(arr: ReadonlyArray<T>) => ReadonlyArray<T>;
//# sourceMappingURL=Query.d.ts.map
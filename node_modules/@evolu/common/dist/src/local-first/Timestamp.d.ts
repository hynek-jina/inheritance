import { RandomBytesDep } from "../Crypto.js";
import { Order } from "../Order.js";
import { Result } from "../Result.js";
import { TimeDep } from "../Time.js";
import { DateIso, InferType } from "../Type.js";
export interface TimestampConfig {
    /**
     * Maximum physical clock drift allowed in ms.
     *
     * The default value is 5 * 60 * 1000 (5 minutes).
     */
    readonly maxDrift: number;
}
export interface TimestampConfigDep {
    readonly timestampConfig: TimestampConfig;
}
export type TimestampError = TimestampDriftError | TimestampCounterOverflowError | TimestampTimeOutOfRangeError;
export interface TimestampDriftError {
    readonly type: "TimestampDriftError";
    readonly next: Millis;
    readonly now: Millis;
}
export interface TimestampCounterOverflowError {
    readonly type: "TimestampCounterOverflowError";
}
export interface TimestampTimeOutOfRangeError {
    readonly type: "TimestampTimeOutOfRangeError";
}
/**
 * Millis is a timestamp in milliseconds, like `Date.now()`, but limited to the
 * maximum value representable in 6 bytes (281474976710655) minus 1 (reserved
 * for infinity). This enables more efficient binary serialization, saving 2
 * bytes compared to the typical 8-byte (64-bit) timestamp representation.
 *
 * This limit is enforced to prevent data corruption. If a device's clock
 * exceeds this range, Evolu will stop saving data until the clock is
 * corrected.
 *
 * `new Date(281474976710654).toString()` = Tue Aug 02 10889 07:31:49
 */
export declare const Millis: import("../Type.js").BrandType<import("../Type.js").BrandType<import("../Type.js").Type<"Brand", number & import("../Brand.js").Brand<"Int"> & import("../Brand.js").Brand<"NonNegative">, number, import("../Type.js").NonNegativeError, number & import("../Brand.js").Brand<"Int">, import("../Type.js").IntError | import("../Type.js").NumberError>, `LessThanOrEqualTo${number}`, import("../Type.js").LessThanOrEqualToError<number>, import("../Type.js").NonNegativeError | import("../Type.js").IntError | import("../Type.js").NumberError>, "Millis", import("../Type.js").BrandWithoutRefineError<"Millis", import("../Type.js").NonNegativeError | import("../Type.js").IntError | import("../Type.js").NumberError | import("../Type.js").LessThanOrEqualToError<number>>, never>;
export type Millis = typeof Millis.Type;
export declare const minMillis: Millis;
export declare const maxMillis: Millis;
export declare const Counter: import("../Type.js").BrandType<import("../Type.js").BrandType<import("../Type.js").Type<"Brand", number & import("../Brand.js").Brand<"Int"> & import("../Brand.js").Brand<"NonNegative">, number, import("../Type.js").NonNegativeError, number & import("../Brand.js").Brand<"Int">, import("../Type.js").IntError | import("../Type.js").NumberError>, "LessThanOrEqualTo65535", import("../Type.js").LessThanOrEqualToError<65535>, import("../Type.js").NonNegativeError | import("../Type.js").IntError | import("../Type.js").NumberError>, "Counter", import("../Type.js").BrandWithoutRefineError<"Counter", import("../Type.js").NonNegativeError | import("../Type.js").IntError | import("../Type.js").NumberError | import("../Type.js").LessThanOrEqualToError<65535>>, never>;
export type Counter = typeof Counter.Type;
export declare const minCounter: Counter;
export declare const maxCounter: Counter;
/**
 * A NodeId uniquely identifies an owner's device. Generated once per device
 * using cryptographic randomness.
 *
 * Collision probability (birthday paradox):
 *
 * - 1,000 devices: ~0.00000000000271% (negligible).
 * - 1M devices: ~0.00000271% (1 in 37M chance).
 * - 135M devices: ~1% chance.
 * - 4.29B devices: ~50% chance.
 *
 * https://lemire.me/blog/2019/12/12/are-64-bit-random-identifiers-free-from-collision
 *
 * What happens if different devices generate the same NodeId?
 *
 * If devices with the same NodeId use different owners, no issues occur.
 *
 * If devices with the same NodeId use the same owner, problems only arise when
 * they generate CRDT messages with identical timestamps (same millis, counter,
 * and NodeId). In this case, the protocol sync algorithm treats them as the
 * same message: the first will be synced with the relay, while the affected
 * message will not be delivered. The affected devices will see different data
 * yet they will think they are synced. This is extremely rare and can be
 * resolved by resetting one device to generate a new NodeId.
 */
export declare const NodeId: import("../Type.js").BrandType<import("../Type.js").Type<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError>, "NodeId", import("../Type.js").RegexError<"NodeId">, import("../Type.js").StringError>;
export type NodeId = typeof NodeId.Type;
export declare const minNodeId: NodeId;
export declare const maxNodeId: NodeId;
/**
 * Hybrid Logical Clock timestamp.
 *
 * Timestamps serve as globally unique, causally ordered identifiers for CRDT
 * messages in Evolu's sync protocol.
 *
 * ### Why Hybrid Logical Clocks
 *
 * Evolu uses Hybrid Logical Clocks (HLC), which combine physical time (millis)
 * with a logical counter. This hybrid approach preserves causality like logical
 * clocks while staying close to physical time for better human
 * interpretability.
 *
 * The counter component ensures causality is maintained even when physical
 * clocks are imperfect. When clocks drift or operations occur concurrently, the
 * counter increments to establish a total order. This means Evolu achieves
 * well-defined, eventually-consistent behavior regardless of physical clock
 * accuracy.
 *
 * Vector clocks can accurately track causality and detect concurrent
 * operations, but they require unbounded space in peer-to-peer systems and
 * crucially, still don't solve our fundamental problem: when they detect
 * operations as concurrent, we still need a deterministic way to choose a
 * winner. Additionally, any deterministic conflict resolution can be gamed by
 * malicious actors.
 *
 * HLC timestamps work well in practice because modern device clocks accurately
 * reflect the order of sequential edits in the common case. Evolu's `maxDrift`
 * configuration protects against buggy clocks and prevents problematic
 * future-dated entries from propagating through the network.
 *
 * ### References
 *
 * - https://muratbuffalo.blogspot.com/2014/07/hybrid-logical-clocks.html
 * - https://sergeiturukin.com/2017/06/26/hybrid-logical-clocks.html
 * - https://jaredforsyth.com/posts/hybrid-logical-clocks/
 * - https://willowprotocol.org/more/timestamps_really/index.html
 *
 * ### Privacy Considerations
 *
 * Timestamps are metadata visible to relays and collaborators. While it can be
 * considered a privacy leak, let us explain why it's necessary, and how to
 * avoid it if maximum privacy is required.
 *
 * With real-time communication, participants always see activity (receiving
 * bytes). We cannot trust anyone not to store that information, so explicitly
 * exposing timestamps doesn't add additional risk.
 *
 * If we really want not to leak user activity, we can implement a local write
 * queue:
 *
 * 1. Write changes immediately to a local-only table
 * 2. Periodically and randomly flush messages to sync tables
 *
 * **Trade-off:** It breaks real-time collaboration.
 */
export declare const Timestamp: import("../Type.js").ObjectType<{
    millis: import("../Type.js").BrandType<import("../Type.js").BrandType<import("../Type.js").Type<"Brand", number & import("../Brand.js").Brand<"Int"> & import("../Brand.js").Brand<"NonNegative">, number, import("../Type.js").NonNegativeError, number & import("../Brand.js").Brand<"Int">, import("../Type.js").IntError | import("../Type.js").NumberError>, `LessThanOrEqualTo${number}`, import("../Type.js").LessThanOrEqualToError<number>, import("../Type.js").NonNegativeError | import("../Type.js").IntError | import("../Type.js").NumberError>, "Millis", import("../Type.js").BrandWithoutRefineError<"Millis", import("../Type.js").NonNegativeError | import("../Type.js").IntError | import("../Type.js").NumberError | import("../Type.js").LessThanOrEqualToError<number>>, never>;
    counter: import("../Type.js").BrandType<import("../Type.js").BrandType<import("../Type.js").Type<"Brand", number & import("../Brand.js").Brand<"Int"> & import("../Brand.js").Brand<"NonNegative">, number, import("../Type.js").NonNegativeError, number & import("../Brand.js").Brand<"Int">, import("../Type.js").IntError | import("../Type.js").NumberError>, "LessThanOrEqualTo65535", import("../Type.js").LessThanOrEqualToError<65535>, import("../Type.js").NonNegativeError | import("../Type.js").IntError | import("../Type.js").NumberError>, "Counter", import("../Type.js").BrandWithoutRefineError<"Counter", import("../Type.js").NonNegativeError | import("../Type.js").IntError | import("../Type.js").NumberError | import("../Type.js").LessThanOrEqualToError<65535>>, never>;
    nodeId: import("../Type.js").BrandType<import("../Type.js").Type<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError>, "NodeId", import("../Type.js").RegexError<"NodeId">, import("../Type.js").StringError>;
}>;
export interface Timestamp extends InferType<typeof Timestamp> {
}
/** Equality function for comparing {@link Timestamp}. */
export declare const eqTimestamp: import("../Eq.js").Eq<{
    readonly millis: number & import("../Brand.js").Brand<"Int"> & import("../Brand.js").Brand<"NonNegative"> & import("../Brand.js").Brand<`LessThanOrEqualTo${number}`> & import("../Brand.js").Brand<"Millis">;
    readonly counter: number & import("../Brand.js").Brand<"Int"> & import("../Brand.js").Brand<"NonNegative"> & import("../Brand.js").Brand<"LessThanOrEqualTo65535"> & import("../Brand.js").Brand<"Counter">;
    readonly nodeId: string & import("../Brand.js").Brand<"NodeId">;
}>;
export declare const createTimestamp: ({ millis, counter, nodeId, }?: Partial<Timestamp>) => Timestamp;
export declare const createInitialTimestamp: (deps: RandomBytesDep) => Timestamp;
export declare const sendTimestamp: (deps: TimeDep & TimestampConfigDep) => (timestamp: Timestamp) => Result<Timestamp, TimestampDriftError | TimestampCounterOverflowError | TimestampTimeOutOfRangeError>;
export declare const receiveTimestamp: (deps: TimeDep & TimestampConfigDep) => (local: Timestamp, remote: Timestamp) => Result<Timestamp, TimestampDriftError | TimestampCounterOverflowError | TimestampTimeOutOfRangeError>;
/** Sortable bytes representation of {@link Timestamp}. */
export declare const TimestampBytes: import("../Type.js").BrandType<import("../Type.js").Type<"Uint8Array", Uint8Array<ArrayBufferLike>, Uint8Array<ArrayBufferLike>, import("../Type.js").Uint8ArrayError, Uint8Array<ArrayBufferLike>, import("../Type.js").Uint8ArrayError>, "TimestampBytes", import("../Type.js").BrandWithoutRefineError<"TimestampBytes", import("../Type.js").Uint8ArrayError>, never>;
export type TimestampBytes = typeof TimestampBytes.Type;
export declare const timestampBytesLength: number & import("../Brand.js").Brand<"Int"> & import("../Brand.js").Brand<"NonNegative">;
export declare const timestampToTimestampBytes: (timestamp: Timestamp) => TimestampBytes;
export declare const timestampBytesToTimestamp: (timestamp: TimestampBytes) => Timestamp;
/**
 * An {@link Order} for {@link TimestampBytes}.
 *
 * This `Order` uses lexicographic byte order to compare serialized
 * {@link TimestampBytes} produced by {@link timestampToTimestampBytes}. See
 * {@link orderUint8Array} for the underlying implementation.
 */
export declare const orderTimestampBytes: Order<TimestampBytes>;
/**
 * Convert a {@link Timestamp} to an ISO 8601 {@link DateIso} string.
 *
 * The conversion uses the timestamp's `millis` (a {@link Millis} value) and
 * `Date.prototype.toISOString()` to produce a `DateIso`.
 */
export declare const timestampToDateIso: (timestamp: Timestamp) => DateIso;
//# sourceMappingURL=Timestamp.d.ts.map
import * as bip39 from "@scure/bip39";
import { wordlist } from "@scure/bip39/wordlists/english.js";
import { createSlip21, EncryptionKey, Entropy16, Entropy32, } from "../Crypto.js";
import { getOrNull } from "../Result.js";
import { brand, Id, IdBytes, idBytesToId, idToIdBytes, NonNegativeInt, } from "../Type.js";
/** OwnerId is a branded {@link Id} that uniquely identifies an {@link Owner}. */
export const OwnerId = brand("OwnerId", Id);
/** Bytes representation of {@link OwnerId}. */
export const OwnerIdBytes = brand("OwnerIdBytes", IdBytes);
/** Converts {@link OwnerId} to {@link OwnerIdBytes}. */
export const ownerIdToOwnerIdBytes = (ownerId) => idToIdBytes(ownerId);
/** Converts {@link OwnerIdBytes} to {@link OwnerId}. */
export const ownerIdBytesToOwnerId = (ownerIdBytes) => idBytesToId(ownerIdBytes);
export const ownerWriteKeyLength = NonNegativeInt.orThrow(16);
/** Symmetric encryption key for {@link Owner} data protection. */
export const OwnerEncryptionKey = brand("OwnerEncryptionKey", EncryptionKey);
/**
 * A secure token for write operations. It's derived from {@link OwnerSecret} by
 * default and can be rotated via {@link createOwnerWriteKey}.
 */
export const OwnerWriteKey = brand("OwnerWriteKey", Entropy16);
/**
 * Creates a new random {@link OwnerWriteKey} for rotation.
 *
 * The initial OwnerWriteKey is deterministically derived from
 * {@link OwnerSecret}. Use `createOwnerWriteKey` to rotate (replace) the write
 * key without changing the owner identity.
 */
export const createOwnerWriteKey = (deps) => deps.randomBytes.create(16);
/**
 * 32 bytes of cryptographic entropy used to derive {@link Owner} keys.
 *
 * Can be created using {@link createOwnerSecret} or converted from a
 * {@link Mnemonic} using {@link mnemonicToOwnerSecret}.
 */
export const OwnerSecret = brand("OwnerSecret", Entropy32);
/** Creates a {@link OwnerSecret}. */
export const createOwnerSecret = (deps) => deps.randomBytes.create(32);
/** Converts an {@link OwnerSecret} to a {@link Mnemonic}. */
export const ownerSecretToMnemonic = (secret) => bip39.entropyToMnemonic(secret, wordlist);
/** Converts a {@link Mnemonic} to an {@link OwnerSecret}. */
export const mnemonicToOwnerSecret = (mnemonic) => bip39.mnemonicToEntropy(mnemonic, wordlist);
/**
 * Creates an {@link Owner} from a {@link OwnerSecret} using SLIP-21 key
 * derivation.
 */
const createOwner = (secret) => ({
    id: ownerIdBytesToOwnerId(OwnerIdBytes.orThrow(createSlip21(secret, ["Evolu", "OwnerIdBytes"]).slice(0, 16))),
    encryptionKey: OwnerEncryptionKey.orThrow(createSlip21(secret, ["Evolu", "OwnerEncryptionKey"])),
    writeKey: OwnerWriteKey.orThrow(createSlip21(secret, ["Evolu", "OwnerWriteKey"]).slice(0, 16)),
});
/** Creates an {@link AppOwner} from an {@link OwnerSecret}. */
export const createAppOwner = (secret) => ({
    ...createOwner(secret),
    type: "AppOwner",
    mnemonic: ownerSecretToMnemonic(secret),
});
/** Creates a {@link ShardOwner} from an {@link OwnerSecret}. */
export const createShardOwner = (secret) => {
    return {
        ...createOwner(secret),
        type: "ShardOwner",
    };
};
/**
 * Derives a {@link ShardOwner} from an {@link AppOwner} using the specified path.
 *
 * **Advantages of derived owners:**
 *
 * - **Deterministic**: Same path always produces the same ShardOwner across all
 *   devices
 * - **Immediate availability**: Can be hardcoded and used before sync occurs
 * - **Consistent setup**: All devices start with identical data structure
 * - **Lifecycle management**: Can implement epoch patterns for clean data
 *   deletion and recreation
 *
 * **Common patterns:**
 *
 * - Use paths like `["shard", 1]` for versioned data lifecycle
 * - Use paths like `["project", "MyApp", 1]` for named partitions with versions
 * - Each device can derive the same owners and set up initial structure
 */
export const deriveShardOwner = (owner, path) => {
    const secret = createSlip21(owner.encryptionKey, path);
    return {
        ...createOwner(secret),
        type: "ShardOwner",
    };
};
/**
 * Creates a {@link SharedOwner} from an {@link OwnerSecret} for collaborative
 * write access.
 *
 * Use {@link createSharedReadonlyOwner} to create a read-only version for
 * sharing.
 */
export const createSharedOwner = (secret) => ({
    ...createOwner(secret),
    type: "SharedOwner",
});
/** Creates a {@link SharedReadonlyOwner} from a {@link SharedOwner}. */
export const createSharedReadonlyOwner = (sharedOwner) => ({
    type: "SharedReadonlyOwner",
    id: sharedOwner.id,
    encryptionKey: sharedOwner.encryptionKey,
});
/**
 * Creates an {@link OwnerWebSocketTransport} for the given relay URL and
 * {@link OwnerId}.
 *
 * The URL must be a WebSocket base URL without query parameters or fragments
 * (e.g., `wss://relay.evolu.dev`, not `wss://relay.evolu.dev?foo=bar`). The
 * function appends the `ownerId` as a query parameter.
 *
 * ### Example
 *
 * ```ts
 * // Create transport "wss://relay.evolu.dev?ownerId=..."
 * const transport = createOwnerWebSocketTransport({
 *   url: "wss://relay.evolu.dev",
 *   ownerId: owner.id,
 * });
 *
 * // Use with createEvolu
 * const evolu = createEvolu(deps)(Schema, {
 *   transports: [transport],
 * });
 * ```
 */
export const createOwnerWebSocketTransport = (config) => ({
    type: "WebSocket",
    url: `${config.url}?ownerId=${config.ownerId}`,
});
/**
 * Extracts {@link OwnerId} from an {@link OwnerWebSocketTransport} URL query
 * string.
 *
 * Parses the query string `?ownerId=...` and validates that the extracted value
 * is a valid {@link OwnerId}.
 *
 * ### Example
 *
 * ```ts
 * parseOwnerIdFromOwnerWebSocketTransportUrl(
 *   "/sync?ownerId=_12345678abcdefgh",
 * );
 * // Returns: OwnerId or null
 * ```
 */
export const parseOwnerIdFromOwnerWebSocketTransportUrl = (url) => getOrNull(OwnerId.fromUnknown(url.split("=")[1]));

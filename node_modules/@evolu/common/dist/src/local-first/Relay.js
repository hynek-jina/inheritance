import { filterArray, firstInArray, isNonEmptyReadonlyArray, mapArray, } from "../Array.js";
import { createInstances } from "../Instances.js";
import { err, ok } from "../Result.js";
import { sql } from "../Sqlite.js";
import { createMutex, isAsync } from "../Task.js";
import { PositiveInt } from "../Type.js";
import { ownerIdBytesToOwnerId, } from "./Owner.js";
import { createBaseSqliteStorage, getOwnerUsage, getTimestampInsertStrategy, updateOwnerUsage, } from "./Storage.js";
import { timestampToTimestampBytes } from "./Timestamp.js";
export const createRelaySqliteStorage = (deps) => (config) => {
    const sqliteStorageBase = createBaseSqliteStorage(deps)(config);
    /**
     * Mutex instances are cached per OwnerId to prevent concurrent writes for
     * the same owner. Instances are never evicted, causing a memory leak
     * proportional to unique owner count. However, per-instance overhead should
     * be small. Monitor production memory usage to determine if
     * eviction/cleanup is needed.
     */
    const ownerMutexes = createInstances();
    return {
        ...sqliteStorageBase,
        /**
         * Lazily authorizes the initiator's {@link OwnerWriteKey} for the given
         * {@link OwnerId}.
         *
         * - If the {@link OwnerId} does not exist, it is created and associated with
         *   the provided write key.
         * - If the {@link OwnerId} exists, the provided write key is compared to the
         *   stored key.
         */
        validateWriteKey: (ownerId, writeKey) => {
            const selectWriteKey = deps.sqlite.exec(sql `
            select writeKey
            from evolu_writeKey
            where ownerId = ${ownerId};
          `);
            if (!selectWriteKey.ok) {
                config.onStorageError(selectWriteKey.error);
                return false;
            }
            const { rows } = selectWriteKey.value;
            if (isNonEmptyReadonlyArray(rows)) {
                return deps.timingSafeEqual(rows[0].writeKey, writeKey);
            }
            const insertWriteKey = deps.sqlite.exec(sql `
          insert into evolu_writeKey (ownerId, writeKey)
          values (${ownerId}, ${writeKey});
        `);
            if (!insertWriteKey.ok) {
                config.onStorageError(insertWriteKey.error);
                return false;
            }
            return true;
        },
        setWriteKey: (ownerId, writeKey) => {
            const upsertWriteKey = deps.sqlite.exec(sql `
          insert into evolu_writeKey (ownerId, writeKey)
          values (${ownerId}, ${writeKey})
          on conflict (ownerId) do update
            set writeKey = excluded.writeKey;
        `);
            if (!upsertWriteKey.ok) {
                config.onStorageError(upsertWriteKey.error);
                return false;
            }
            return true;
        },
        writeMessages: async (ownerIdBytes, messages) => {
            const ownerId = ownerIdBytesToOwnerId(ownerIdBytes);
            const messagesWithTimestampBytes = mapArray(messages, (m) => ({
                timestamp: timestampToTimestampBytes(m.timestamp),
                change: m.change,
            }));
            const result = await ownerMutexes
                .ensure(ownerId, createMutex)
                .withLock(async () => {
                const existingTimestampsResult = sqliteStorageBase.getExistingTimestamps(ownerIdBytes, mapArray(messagesWithTimestampBytes, (m) => m.timestamp));
                if (!existingTimestampsResult.ok)
                    return existingTimestampsResult;
                const existingTimestampsSet = new Set(existingTimestampsResult.value.map((t) => t.toString()));
                const newMessages = filterArray(messagesWithTimestampBytes, (m) => !existingTimestampsSet.has(m.timestamp.toString()));
                // Nothing to write
                if (!isNonEmptyReadonlyArray(newMessages)) {
                    return ok();
                }
                const usage = getOwnerUsage(deps)(ownerIdBytes, firstInArray(newMessages).timestamp);
                if (!usage.ok)
                    return usage;
                const { storedBytes } = usage.value;
                const incomingBytes = newMessages.reduce((sum, m) => sum + m.change.length, 0);
                const newStoredBytes = PositiveInt.orThrow((storedBytes ?? 0) + incomingBytes);
                const result = config.isOwnerWithinQuota(ownerId, newStoredBytes);
                const isWithinQuota = isAsync(result) ? await result : result;
                if (!isWithinQuota) {
                    return err({ type: "StorageQuotaError", ownerId });
                }
                let { firstTimestamp, lastTimestamp } = usage.value;
                return deps.sqlite.transaction(() => {
                    for (const { timestamp, change } of newMessages) {
                        let strategy;
                        [strategy, firstTimestamp, lastTimestamp] =
                            getTimestampInsertStrategy(timestamp, firstTimestamp, lastTimestamp);
                        {
                            const result = sqliteStorageBase.insertTimestamp(ownerIdBytes, timestamp, strategy);
                            if (!result.ok)
                                return result;
                        }
                        {
                            const result = deps.sqlite.exec(sql `
                    insert into evolu_message ("ownerId", "timestamp", "change")
                    values (${ownerIdBytes}, ${timestamp}, ${change})
                    on conflict do nothing;
                  `);
                            if (!result.ok)
                                return result;
                        }
                    }
                    return updateOwnerUsage(deps)(ownerIdBytes, newStoredBytes, firstTimestamp, lastTimestamp);
                });
            })();
            if (!result.ok && result.error.type !== "AbortError") {
                switch (result.error.type) {
                    case "SqliteError":
                        config.onStorageError(result.error);
                        return err({ type: "StorageWriteError", ownerId });
                    case "StorageQuotaError":
                        return err({ type: "StorageQuotaError", ownerId });
                }
            }
            return ok();
        },
        readDbChange: (ownerId, timestamp) => {
            const result = deps.sqlite.exec(sql `
          select "change"
          from evolu_message
          where "ownerId" = ${ownerId} and "timestamp" = ${timestamp};
        `);
            if (!result.ok) {
                config.onStorageError(result.error);
                return null;
            }
            return result.value.rows[0]?.change;
        },
        deleteOwner: (ownerId) => {
            const transactionResult = deps.sqlite.transaction(() => {
                const deleteWriteKey = deps.sqlite.exec(sql `
            delete from evolu_writeKey where ownerId = ${ownerId};
          `);
                if (!deleteWriteKey.ok)
                    return deleteWriteKey;
                const deleteMessages = deps.sqlite.exec(sql `
            delete from evolu_message where ownerId = ${ownerId};
          `);
                if (!deleteMessages.ok)
                    return deleteMessages;
                const deleteUsage = deps.sqlite.exec(sql `
            delete from evolu_usage where ownerId = ${ownerId};
          `);
                if (!deleteUsage.ok)
                    return deleteUsage;
                const deleteBaseOwner = sqliteStorageBase.deleteOwner(ownerId);
                if (!deleteBaseOwner)
                    return err(null);
                return ok();
            });
            if (!transactionResult.ok) {
                if (transactionResult.error)
                    config.onStorageError(transactionResult.error);
                return false;
            }
            return true;
        },
    };
};
export const createRelayStorageTables = (deps) => {
    for (const query of [
        sql `
      create table evolu_writeKey (
        "ownerId" blob not null,
        "writeKey" blob not null,
        primary key ("ownerId")
      )
      strict;
    `,
        sql `
      create table evolu_message (
        "ownerId" blob not null,
        "timestamp" blob not null,
        "change" blob not null,
        primary key ("ownerId", "timestamp")
      )
      strict;
    `,
    ]) {
        const result = deps.sqlite.exec(query);
        if (!result.ok)
            return result;
    }
    return ok();
};
export const createRelayLogger = (deps) => ({
    started: (enableLogging, port) => {
        deps.console.enabled = true;
        deps.console.log(`Evolu Relay started on port ${port}`);
        deps.console.enabled = enableLogging;
    },
    storageError: (error) => {
        deps.console.error("[relay]", "storage", error);
    },
    upgradeSocketError: (error) => {
        deps.console.warn("[relay]", "socket error", { error });
    },
    invalidOrMissingOwnerIdInUrl: (url) => {
        deps.console.warn("[relay]", "invalid or missing ownerId in URL", { url });
    },
    unauthorizedOwner: (ownerId) => {
        deps.console.warn("[relay]", "unauthorized owner", { ownerId });
    },
    connectionEstablished: (totalConnectionCount) => {
        deps.console.log("[relay]", "connection", { totalConnectionCount });
    },
    connectionWebSocketError: (error) => {
        deps.console.error("[relay]", "error", { error });
    },
    relayOptionSubscribe: (ownerId, getSubscriberCount) => {
        if (deps.console.enabled)
            deps.console.log("[relay]", "subscribe", {
                ownerId,
                subscriberCount: getSubscriberCount(),
            });
    },
    relayOptionUnsubscribe: (ownerId, getSubscriberCount) => {
        if (deps.console.enabled)
            deps.console.log("[relay]", "unsubscribe", {
                ownerId,
                subscriberCount: getSubscriberCount(),
            });
    },
    relayOptionBroadcast: (ownerId, broadcastCount, totalSubscribers) => {
        deps.console.log("[relay]", "broadcast", {
            ownerId,
            broadcastCount,
            totalSubscribers,
        });
    },
    messageLength: (messageLength) => {
        deps.console.log("[relay]", "on message", { messageLength });
    },
    applyProtocolMessageAsRelayError: (error) => {
        deps.console.error("[relay]", "applyProtocolMessageAsRelay", error);
    },
    responseLength: (responseLength) => {
        deps.console.log("[relay]", "responseLength", { responseLength });
    },
    applyProtocolMessageAsRelayUnknownError: (error) => {
        deps.console.error("[relay]", "applyProtocolMessageAsRelayUnknownError", error);
    },
    connectionClosed: (totalConnectionCount) => {
        deps.console.log("[relay]", "close", { totalConnectionCount });
    },
    shuttingDown: () => {
        deps.console.log("Shutting down Evolu Relay...");
    },
    webSocketServerDisposed: () => {
        deps.console.log("Evolu Relay WebSocketServer disposed");
    },
    httpServerDisposed: () => {
        deps.console.log("Evolu Relay HTTP server disposed");
    },
});

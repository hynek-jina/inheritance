import { NonEmptyReadonlyArray } from "../Array.js";
import { ConsoleDep } from "../Console.js";
import { RandomBytesDep, SymmetricCryptoDecryptError, SymmetricCryptoDep } from "../Crypto.js";
import { TransferableError } from "../Error.js";
import { RandomDep } from "../Random.js";
import { Result } from "../Result.js";
import { SqliteDep, SqliteError } from "../Sqlite.js";
import { TimeDep } from "../Time.js";
import { CreateWebSocketDep } from "../WebSocket.js";
import { AppOwner, AppOwnerDep, Owner, OwnerTransport, ReadonlyOwner } from "./Owner.js";
import { ProtocolError, ProtocolInvalidDataError, ProtocolTimestampMismatchError } from "./Protocol.js";
import { DbSchemaDep, MutationChange } from "./Schema.js";
import { BaseSqliteStorage, Storage } from "./Storage.js";
import { Millis, Timestamp, TimestampConfigDep, TimestampCounterOverflowError, TimestampDriftError, TimestampTimeOutOfRangeError } from "./Timestamp.js";
export interface Sync extends Disposable {
    /**
     * Assigns or removes an owner to/from transports with reference counting.
     *
     * Owners are only synced if assigned to at least one transport. Uses
     * `owner.transports` or falls back to {@link SyncConfig} transports. Multiple
     * calls increment/decrement reference counts (useful for React Hooks).
     */
    readonly useOwner: (use: boolean, owner: SyncOwner) => void;
    readonly applyChanges: (changes: NonEmptyReadonlyArray<MutationChange>) => Result<void, SqliteError | TimestampCounterOverflowError | TimestampDriftError | TimestampTimeOutOfRangeError>;
}
export interface SyncDep {
    readonly sync: Sync;
}
/**
 * Represents an owner for sync operations.
 *
 * Includes readonly owner fields plus optional write key (for clients that
 * write) and optional transports to override SyncConfig transports per owner.
 */
export interface SyncOwner extends ReadonlyOwner {
    readonly writeKey?: Owner["writeKey"];
    readonly transports?: ReadonlyArray<OwnerTransport>;
}
export interface SyncConfig {
    readonly appOwner: AppOwner;
    readonly transports: ReadonlyArray<OwnerTransport>;
    /**
     * Delay in milliseconds before disposing unused WebSocket connections.
     * Defaults to 100ms.
     */
    readonly disposalDelayMs?: number;
    readonly onError: (error: ProtocolError | ProtocolInvalidDataError | ProtocolTimestampMismatchError | SqliteError | SymmetricCryptoDecryptError | TimestampCounterOverflowError | TimestampDriftError | TimestampTimeOutOfRangeError | TransferableError) => void;
    readonly onReceive: () => void;
}
export declare const createSync: (deps: ClockDep & ConsoleDep & CreateWebSocketDep & DbSchemaDep & RandomBytesDep & RandomDep & SqliteDep & SymmetricCryptoDep & TimeDep & TimestampConfigDep) => (config: SyncConfig) => Result<Sync, SqliteError>;
export interface ClockDep {
    readonly clock: Clock;
}
export interface Clock {
    readonly get: () => Timestamp;
    readonly save: (timestamp: Timestamp) => Result<void, SqliteError>;
}
export declare const createClock: (deps: RandomBytesDep & SqliteDep) => (initialTimestamp?: Timestamp) => Clock;
export interface ClientStorage extends Storage, BaseSqliteStorage {
}
export interface ClientStorageDep {
    readonly storage: ClientStorage;
}
export declare const applyLocalOnlyChange: (deps: SqliteDep & TimeDep & AppOwnerDep) => (change: MutationChange) => Result<void, SqliteError>;
/**
 * Attempts to apply quarantined messages that may now be valid after a schema
 * update. Messages are quarantined when they reference tables or columns that
 * don't exist in the current schema (e.g., from a newer app version).
 */
export declare const tryApplyQuarantinedMessages: (deps: DbSchemaDep & SqliteDep) => () => Result<void, SqliteError>;
/**
 * TODO: Rework for the new owners API.
 *
 * The possible states of a synchronization process. The `SyncState` can be one
 * of the following:
 *
 * - {@link SyncStateInitial}
 * - {@link SyncStateIsSyncing}
 * - {@link SyncStateIsSynced}
 * - {@link SyncStateIsNotSynced}
 */
export type SyncState = SyncStateInitial | SyncStateIsSyncing | SyncStateIsSynced | SyncStateIsNotSynced;
/**
 * The initial synchronization state when the app starts. In this state, the app
 * needs to determine whether the data is synced.
 */
export interface SyncStateInitial {
    readonly type: "SyncStateInitial";
}
export interface SyncStateIsSyncing {
    readonly type: "SyncStateIsSyncing";
}
export interface SyncStateIsSynced {
    readonly type: "SyncStateIsSynced";
    readonly time: Millis;
}
export interface SyncStateIsNotSynced {
    readonly type: "SyncStateIsNotSynced";
    readonly error: NetworkError | ServerError | PaymentRequiredError;
}
export interface NetworkError {
    readonly type: "NetworkError";
}
export interface ServerError {
    readonly type: "ServerError";
    readonly status: number;
}
export interface PaymentRequiredError {
    readonly type: "PaymentRequiredError";
}
export declare const initialSyncState: SyncStateInitial;
//# sourceMappingURL=Sync.d.ts.map
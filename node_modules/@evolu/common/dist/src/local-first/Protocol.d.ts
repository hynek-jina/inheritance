/**
 * Evolu Protocol
 *
 * Evolu Protocol is a local-first, end-to-end encrypted binary synchronization
 * protocol optimized for minimal size and maximum speed. It enables data sync
 * between a client and a relay. In the future, direct peer-to-peer (P2P) sync
 * between clients will be possible without a relay.
 *
 * Relays don't need to sync with each other—clients using those relays will
 * sync them eventually. If a relay is offline (e.g., for maintenance), it will
 * sync automatically later via client sync logic. For relay backup using
 * SQLite, see https://sqlite.org/rsync.html (uses a similar algorithm to Evolu
 * RBSR).
 *
 * Evolu Protocol is designed for SQLite but can be extended to any database. It
 * implements [Range-Based Set
 * Reconciliation](https://arxiv.org/abs/2212.13567). To learn how RBSR works,
 * check [Negentropy](https://logperiodic.com/rbsr.html). Evolu Protocol is
 * similar to Negentropy but uses different encoding and also provides data
 * transfer, ownership, real-time broadcasting, request-response semantics, and
 * error handling.
 *
 * ### Message structure
 *
 * | Field                          | Notes                     |
 * | :----------------------------- | :------------------------ |
 * | **Header**                     |                           |
 * | - {@link protocolVersion}      |                           |
 * | - {@link OwnerId}              | {@link Owner}             |
 * | - messageType                  | {@link MessageType}       |
 * | **Request (messageType=0)**    |                           |
 * | - hasWriteKey                  | 0 = no, 1 = yes           |
 * | - {@link OwnerWriteKey}        | If hasWriteKey = 1        |
 * | - subscriptionFlag             | {@link SubscriptionFlags} |
 * | **Response (messageType=1)**   |                           |
 * | - {@link ProtocolErrorCode}    |                           |
 * | **Broadcast (messageType=2)**  |                           |
 * | - (no additional fields)       |                           |
 * | **Messages**                   |                           |
 * | - {@link NonNegativeInt}       | A number of messages.     |
 * | - {@link EncryptedCrdtMessage} |                           |
 * | **Ranges**                     |                           |
 * | - {@link NonNegativeInt}       | Number of ranges.         |
 * | - {@link Range}                |                           |
 *
 * ### WriteKey validation
 *
 * The initiator sends a hasWriteKey flag and optionally a WriteKey. The
 * WriteKey is required when sending messages as a secure token proving the
 * initiator can write changes. It's ok to not send a WriteKey if the initiator
 * is only syncing (read-only) and not sending messages. The non-initiator
 * validates the WriteKey immediately after parsing the initiator header, before
 * processing any messages or ranges.
 *
 * ### Synchronization
 *
 * - **Messages**: Sends {@link EncryptedCrdtMessage}s in either direction.
 * - **Ranges**: Determines messages to sync. Usage varies by transport—e.g., sent
 *   only on WebSocket connection open or with every fetch request.
 *
 * Synchronization involves an initiator and a non-initiator. The **initiator**
 * is typically a client, and the **non-initiator** is typically a relay. Each
 * side processes the received message and responds with a new `ProtocolMessage`
 * if further sync is needed or possible, continuing until both sides are
 * synchronized.
 *
 * The **non-initiator always responds** to provide sync completion feedback,
 * even with empty messages containing only the header and no error. This allows
 * the initiator to detect when synchronization is complete.
 *
 * Both **Messages** and **Ranges** are optional, allowing each side to send,
 * sync, or only subscribe data as needed.
 *
 * When the initiator sends data, the {@link OwnerWriteKey} is required as a
 * secure token proving the initiator can write changes. The non-initiator
 * responds without a {@link OwnerWriteKey}, since the initiator’s request
 * already signals it wants data. If the non-initiator detects an issue, it
 * sends an error code via the `Error` field in the header back to the
 * initiator. In relay-to-relay or P2P sync, both sides may require the
 * {@link OwnerWriteKey} depending on who is the initiator.
 *
 * ### Protocol errors
 *
 * The protocol uses error codes in the header to signal issues:
 *
 * - {@link ProtocolWriteKeyError}: The provided WriteKey is invalid or missing.
 * - {@link ProtocolWriteError}: A serious relay-side write failure occurred.
 * - {@link ProtocolQuotaError}: Storage or billing quota exceeded.
 * - {@link ProtocolSyncError}: A serious relay-side synchronization failure
 *   occurred.
 * - {@link ProtocolVersionError}: Protocol version mismatch.
 * - {@link ProtocolInvalidDataError}: The message is malformed or corrupted.
 *
 * All protocol errors except `ProtocolInvalidDataError` include the `OwnerId`
 * to allow clients to associate errors with the correct owner.
 *
 * ### Message size limit
 *
 * The protocol enforces a strict maximum size for all messages, defined by
 * {@link ProtocolMessageMaxSize}. This ensures every {@link ProtocolMessage} is
 * less than or equal to this limit, enabling stateless transports, simplified
 * relay implementation, and predictable memory usage. When all messages don't
 * fit within the limit, the protocol automatically continues synchronization in
 * subsequent rounds using range-based reconciliation.
 *
 * Database mutations are limited to 640KB, which is smaller than the protocol
 * message limit to ensure efficient sync with
 * {@link defaultProtocolMessageRangesMaxSize}.
 *
 * ### Why Binary?
 *
 * The protocol avoids JSON because:
 *
 * - Encrypted data doesn’t compress well, unlike plain JSON.
 * - Message size must be controlled during creation.
 * - Sequential byte reading is faster than parsing and avoids conversions.
 *
 * It uses structure-aware encoding, significantly outperforming generic binary
 * serialization formats with the following optimizations:
 *
 * - **NonNegativeInt:** Up to 33% smaller than MessagePack.
 * - **DateIso:** Up to 75% smaller.
 * - **Timestamp Encoding:** Delta encoding for milliseconds and run-length
 *   encoding (RLE) for counters and NodeIds.
 * - **Small Integers (0 to 19):** Reduces size by 1 byte per integer.
 *
 * To avoid reinventing serialization where it’s unnecessary—like for JSON and
 * certain numbers—the Evolu Protocol relies on MessagePack.
 *
 * ### Versioning
 *
 * Evolu Protocol uses explicit versioning to ensure compatibility between
 * clients and relays (or peers). Each protocol message begins with a version
 * number and an `ownerId` in its header.
 *
 * **How version negotiation works:**
 *
 * - The initiator (usually a client) sends a `ProtocolMessage` that includes its
 *   protocol version and the `ownerId`.
 * - The non-initiator (usually a relay or peer) checks the version.
 *
 *   - If the versions match, synchronization proceeds as normal.
 *   - If the versions do not match, the non-initiator responds with a message
 *       containing **its own protocol version and the same `ownerId`**.
 * - The initiator can then detect the version mismatch for that specific owner
 *   and handle it appropriately (e.g., prompt for an update or halt sync).
 *
 * Version negotiation is per-owner, allowing Evolu Protocol to evolve safely
 * over time and provide clear feedback about version mismatches.
 *
 * ### Credible exit
 *
 * The protocol specification is intentionally non-configurable to ensure
 * universal compatibility. This design allows applications (users) to switch
 * between any compliant relay without negotiation or compatibility checks
 * beyond version matching. Relays are generic infrastructure that any
 * application can use interchangeably making exit from any single provider
 * technically feasible and economically viable.
 *
 * @module
 */
import { NonEmptyReadonlyArray } from "../Array.js";
import { Brand } from "../Brand.js";
import { Buffer } from "../Buffer.js";
import { EncryptionKey, RandomBytesDep, SymmetricCryptoDecryptError, SymmetricCryptoDep } from "../Crypto.js";
import { Result } from "../Result.js";
import { SqliteValue } from "../Sqlite.js";
import { NonNegativeInt, PositiveInt } from "../Type.js";
import { Owner, OwnerError, OwnerId, OwnerWriteKey } from "./Owner.js";
import { BaseRange, CrdtMessage, DbChange, EncryptedCrdtMessage, EncryptedDbChange, FingerprintRange, RangeType, SkipRange, StorageDep } from "./Storage.js";
import { NodeId, Timestamp } from "./Timestamp.js";
/**
 * Protocol message maximum size.
 *
 * Defines the upper limit for how large a single protocol message can be.
 * Implementations must enforce a maximum size between 1MB and 100MB to ensure
 * compatibility across all Evolu implementations (the maximum size of mutation
 * change is hardcoded and enforced hence the maximum size can't be smaller).
 *
 * Larger maximum sizes can be configured by relays to reduce roundtrips. For
 * example, a dedicated relay with ample resources could configure a 100MB
 * maximum to minimize roundtrips for large syncs.
 *
 * Only relays can safely configure larger sizes, as clients will handle them.
 * Increasing this value on the client side would break compatibility with
 * relays that enforce smaller limits.
 */
export declare const ProtocolMessageMaxSize: import("../Type.js").BrandType<import("../Type.js").Type<"Brand", number & Brand<"Int">, number, import("../Type.js").IntError, number, import("../Type.js").NumberError>, "Between1000000-100000000", import("../Type.js").BetweenError<1000000, 100000000>, import("../Type.js").IntError | import("../Type.js").NumberError>;
export type ProtocolMessageMaxSize = typeof ProtocolMessageMaxSize.Type;
/**
 * Default {@link ProtocolMessageMaxSize} (1MB).
 *
 * The standard size used across Evolu implementations. Relays with more
 * resources can configure larger sizes to reduce roundtrips.
 */
export declare const defaultProtocolMessageMaxSize: ProtocolMessageMaxSize;
/**
 * Protocol message ranges maximum size.
 *
 * Defines the upper limit for how large the ranges section of a protocol
 * message can be. Implementations must enforce a maximum size between 3KB and
 * 100KB to ensure compatibility.
 *
 * The upper bound is set to ensure ranges fit within the default 1MB
 * {@link defaultProtocolMessageMaxSize}, maintaining compatibility between all
 * clients and relays.
 */
export declare const ProtocolMessageRangesMaxSize: import("../Type.js").BrandType<import("../Type.js").Type<"Brand", number & Brand<"Int">, number, import("../Type.js").IntError, number, import("../Type.js").NumberError>, "Between3000-100000", import("../Type.js").BetweenError<3000, 100000>, import("../Type.js").IntError | import("../Type.js").NumberError>;
export type ProtocolMessageRangesMaxSize = typeof ProtocolMessageRangesMaxSize.Type;
/**
 * Default {@link ProtocolMessageRangesMaxSize} (30KB).
 *
 * The standard size used across Evolu implementations. Relays with more
 * resources can configure larger sizes to reduce roundtrips.
 */
export declare const defaultProtocolMessageRangesMaxSize: ProtocolMessageRangesMaxSize;
/** Evolu Protocol Message. */
export type ProtocolMessage = Uint8Array & Brand<"ProtocolMessage">;
/** Evolu Protocol version. */
export declare const protocolVersion: number & Brand<"Int"> & Brand<"NonNegative">;
export declare const MessageType: {
    /** Request message from initiator (client) to non-initiator (relay). */
    readonly Request: 0;
    /** Response message from non-initiator (relay) to initiator (client). */
    readonly Response: 1;
    /** Broadcast message from non-initiator (relay) to subscribed clients. */
    readonly Broadcast: 2;
};
export type MessageType = (typeof MessageType)[keyof typeof MessageType];
export declare const SubscriptionFlags: {
    /** No subscription changes for this owner. */
    readonly None: 0;
    /** Subscribe to updates for this owner. */
    readonly Subscribe: 1;
    /** Unsubscribe from updates for this owner. */
    readonly Unsubscribe: 2;
};
export type SubscriptionFlag = (typeof SubscriptionFlags)[keyof typeof SubscriptionFlags];
export declare const ProtocolErrorCode: {
    readonly NoError: 0;
    /** A code for {@link ProtocolWriteKeyError}. */
    readonly WriteKeyError: 1;
    /** A code for {@link ProtocolWriteError}. */
    readonly WriteError: 2;
    /** A code for {@link ProtocolQuotaError}. */
    readonly QuotaError: 3;
    /** A code for {@link ProtocolSyncError}. */
    readonly SyncError: 4;
};
type ProtocolErrorCode = (typeof ProtocolErrorCode)[keyof typeof ProtocolErrorCode];
export type ProtocolError = ProtocolVersionError | ProtocolInvalidDataError | ProtocolWriteKeyError | ProtocolWriteError | ProtocolSyncError | ProtocolQuotaError | ProtocolTimestampMismatchError;
/**
 * Represents a version mismatch in the Evolu Protocol. Occurs when the
 * initiator and non-initiator are using incompatible protocol versions.
 */
export interface ProtocolVersionError extends OwnerError {
    readonly type: "ProtocolVersionError";
    readonly version: NonNegativeInt;
    /** Indicates which side is obsolete and should update. */
    readonly isInitiator: boolean;
}
/** Error for invalid or corrupted protocol message data. */
export interface ProtocolInvalidDataError {
    readonly type: "ProtocolInvalidDataError";
    readonly data: globalThis.Uint8Array;
    readonly error: unknown;
}
/** Error when a {@link OwnerWriteKey} is invalid, missing, or fails validation. */
export interface ProtocolWriteKeyError extends OwnerError {
    readonly type: "ProtocolWriteKeyError";
}
/**
 * Error indicating a serious relay-side write failure. Clients should log this
 * error and show a generic sync error to the user.
 */
export interface ProtocolWriteError extends OwnerError {
    readonly type: "ProtocolWriteError";
}
/**
 * Error when storage or billing quota is exceeded.
 *
 * When relay rejects writes due to quota, the affected device stops syncing
 * because RBSR requires both sides to converge—if the relay won't accept the
 * client's data, they can never reach the same state. Only the device with
 * excess local data is affected. Other devices that haven't exceeded quota can
 * still sync normally.
 *
 * Clients should prompt the user to contact the relay provider or upgrade their
 * plan. Quota monitoring and management is the relay provider's
 * responsibility.
 */
export interface ProtocolQuotaError extends OwnerError {
    readonly type: "ProtocolQuotaError";
}
/**
 * Error indicating a serious relay-side synchronization failure. Clients should
 * log this error and show a generic sync error to the user.
 */
export interface ProtocolSyncError extends OwnerError {
    readonly type: "ProtocolSyncError";
}
/**
 * Error when embedded timestamp doesn't match expected timestamp in
 * EncryptedDbChange. Indicates potential tampering or corruption of CRDT
 * messages.
 */
export interface ProtocolTimestampMismatchError {
    readonly type: "ProtocolTimestampMismatchError";
    readonly expected: Timestamp;
    readonly timestamp: Timestamp;
}
/**
 * Creates a {@link ProtocolMessage} from CRDT messages.
 *
 * If the message size would exceed {@link defaultProtocolMessageMaxSize}, the
 * protocol ensures all messages will be sent in the next round(s) even over
 * unidirectional and stateless transports.
 */
export declare const createProtocolMessageFromCrdtMessages: (deps: RandomBytesDep & SymmetricCryptoDep) => (owner: Owner, messages: NonEmptyReadonlyArray<CrdtMessage>, maxSize?: ProtocolMessageMaxSize) => ProtocolMessage;
/** Creates a {@link ProtocolMessage} for sync. */
export declare const createProtocolMessageForSync: (deps: StorageDep) => (ownerId: OwnerId, subscriptionFlag?: SubscriptionFlag) => ProtocolMessage | null;
export declare const createProtocolMessageForUnsubscribe: (ownerId: OwnerId) => ProtocolMessage;
/**
 * Mutable builder for constructing {@link ProtocolMessage} respecting size
 * limits.
 */
export interface ProtocolMessageBuffer {
    readonly canAddMessage: (message: EncryptedCrdtMessage) => boolean;
    readonly addMessage: (message: EncryptedCrdtMessage) => void;
    readonly canSplitRange: () => boolean;
    readonly canAddTimestampsRangeAndMessage: (timestamps: TimestampsBuffer, message: EncryptedCrdtMessage | null) => boolean;
    readonly addRange: (range: SkipRange | FingerprintRange | TimestampsRangeWithTimestampsBuffer) => void;
    readonly unwrap: () => ProtocolMessage;
    readonly getSize: () => PositiveInt;
}
export declare const createProtocolMessageBuffer: (ownerId: OwnerId, options: {
    readonly totalMaxSize?: ProtocolMessageMaxSize | undefined;
    readonly rangesMaxSize?: ProtocolMessageRangesMaxSize | undefined;
    readonly version?: NonNegativeInt;
} & ({
    readonly messageType: typeof MessageType.Request;
    readonly writeKey?: OwnerWriteKey;
    readonly subscriptionFlag?: SubscriptionFlag;
} | {
    readonly messageType: typeof MessageType.Response;
    readonly errorCode: ProtocolErrorCode;
} | {
    readonly messageType: typeof MessageType.Broadcast;
})) => ProtocolMessageBuffer;
export interface TimestampsRangeWithTimestampsBuffer extends BaseRange {
    readonly type: typeof RangeType.Timestamps;
    readonly timestamps: TimestampsBuffer;
}
export interface TimestampsBuffer {
    readonly add: (timestamp: Timestamp) => void;
    readonly addInfinite: () => void;
    readonly getCount: () => NonNegativeInt;
    readonly getLength: () => number;
    readonly append: (buffer: Buffer) => void;
}
export declare const createTimestampsBuffer: () => TimestampsBuffer;
export interface ApplyProtocolMessageAsClientOptions {
    getWriteKey?: (ownerId: OwnerId) => OwnerWriteKey | null;
    rangesMaxSize?: ProtocolMessageRangesMaxSize;
    /** For tests only. */
    version?: NonNegativeInt;
}
/**
 * Result type for {@link applyProtocolMessageAsClient} that distinguishes
 * between responses to client requests and broadcast messages.
 */
export type ApplyProtocolMessageAsClientResult = {
    readonly type: "response";
    readonly message: ProtocolMessage;
} | {
    readonly type: "no-response";
} | {
    readonly type: "broadcast";
};
export declare const applyProtocolMessageAsClient: (deps: StorageDep) => (inputMessage: Uint8Array, options?: ApplyProtocolMessageAsClientOptions) => Promise<Result<ApplyProtocolMessageAsClientResult, ProtocolInvalidDataError | ProtocolSyncError | ProtocolVersionError | ProtocolWriteError | ProtocolWriteKeyError | ProtocolQuotaError>>;
export interface ApplyProtocolMessageAsRelayOptions {
    /** To subscribe an owner for broadcasting. */
    subscribe?: (ownerId: OwnerId) => void;
    /** To unsubscribe an owner from broadcasting. */
    unsubscribe?: (ownerId: OwnerId) => void;
    /** To broadcast a protocol message to all subscribers. */
    broadcast?: (ownerId: OwnerId, message: ProtocolMessage) => void;
    totalMaxSize?: ProtocolMessageMaxSize;
    rangesMaxSize?: ProtocolMessageRangesMaxSize;
}
/**
 * Result type for {@link applyProtocolMessageAsRelay}.
 *
 * Unlike {@link ApplyProtocolMessageAsClientResult}, relays always respond with
 * a message to provide sync completion feedback. This ensures the initiator can
 * reliably detect when synchronization is complete, even when there's nothing
 * to sync. Clients may choose not to respond in certain cases (like when they
 * receive broadcast messages or when they lack a write key for syncing).
 */
export interface ApplyProtocolMessageAsRelayResult {
    readonly type: "response";
    readonly message: ProtocolMessage;
}
export declare const applyProtocolMessageAsRelay: (deps: StorageDep) => (inputMessage: Uint8Array, options?: ApplyProtocolMessageAsRelayOptions, 
/** For tests only. */
version?: number & Brand<"Int"> & Brand<"NonNegative">) => Promise<Result<ApplyProtocolMessageAsRelayResult, ProtocolInvalidDataError>>;
/**
 * Evolu uses MessagePack to handle all number variants except for
 * NonNegativeInt. For NonNegativeInt, Evolu provides more efficient encoding.
 */
export declare const encodeNumber: (buffer: Buffer, number: number) => void;
export declare const decodeNumber: (buffer: Buffer) => number;
/**
 * Encodes an array of boolean flags into a single byte.
 *
 * Each element in the array corresponds to a bit (0-7). Array can have 0-8
 * elements.
 *
 * ### Example
 *
 * ```ts
 * encodeFlags(buffer, [true, false, true]); // Encodes bits 0, 1, 2
 * ```
 */
export declare const encodeFlags: (buffer: Buffer, flags: ReadonlyArray<boolean>) => void;
/**
 * Decodes a byte into an array of boolean flags.
 *
 * ### Example
 *
 * ```ts
 * const flags = decodeFlags(buffer, 3); // Decode 3 flags
 * ```
 */
export declare const decodeFlags: (buffer: Buffer, count: PositiveInt) => ReadonlyArray<boolean>;
/**
 * Encodes and encrypts a {@link DbChange} using the provided owner's encryption
 * key. Returns an encrypted binary representation as {@link EncryptedDbChange}.
 *
 * The format includes the protocol version for backward compatibility and the
 * timestamp for tamper-proof verification that the timestamp matches the change
 * data.
 */
export declare const encodeAndEncryptDbChange: (deps: SymmetricCryptoDep) => (message: CrdtMessage, key: EncryptionKey) => EncryptedDbChange;
/**
 * Decrypts and decodes an {@link EncryptedCrdtMessage} using the provided
 * owner's encryption key. Verifies that the embedded timestamp matches the
 * expected timestamp to ensure message integrity.
 */
export declare const decryptAndDecodeDbChange: (deps: SymmetricCryptoDep) => (message: EncryptedCrdtMessage, key: EncryptionKey) => Result<DbChange, SymmetricCryptoDecryptError | ProtocolInvalidDataError | ProtocolTimestampMismatchError>;
/**
 * Encodes a non-negative integer into a variable-length integer format. It's
 * more efficient than encoding via {@link encodeNumber}.
 *
 * https://en.wikipedia.org/wiki/Variable-length_quantity
 */
export declare const encodeNonNegativeInt: (buffer: Buffer, int: NonNegativeInt) => void;
/**
 * Decodes a non-negative integer from a variable-length integer format.
 *
 * https://en.wikipedia.org/wiki/Variable-length_quantity
 */
export declare const decodeNonNegativeInt: (buffer: Buffer) => NonNegativeInt;
export declare const encodeLength: (buffer: Buffer, value: ArrayLike<any>) => void;
export declare const decodeLength: (buffer: Buffer) => NonNegativeInt;
export declare const encodeString: (buffer: Buffer, value: string) => void;
export declare const decodeString: (buffer: Buffer) => string;
export declare const encodeNodeId: (buffer: Buffer, nodeId: NodeId) => void;
export declare const decodeNodeId: (buffer: Buffer) => NodeId;
export declare const ProtocolValueType: {
    readonly String: number & Brand<"Int"> & Brand<"NonNegative">;
    readonly Number: number & Brand<"Int"> & Brand<"NonNegative">;
    readonly Null: number & Brand<"Int"> & Brand<"NonNegative">;
    readonly Bytes: number & Brand<"Int"> & Brand<"NonNegative">;
    readonly NonNegativeInt: number & Brand<"Int"> & Brand<"NonNegative">;
    readonly EmptyString: number & Brand<"Int"> & Brand<"NonNegative">;
    readonly Base64Url: number & Brand<"Int"> & Brand<"NonNegative">;
    readonly Id: number & Brand<"Int"> & Brand<"NonNegative">;
    readonly Json: number & Brand<"Int"> & Brand<"NonNegative">;
    readonly DateIsoWithNonNegativeTime: number & Brand<"Int"> & Brand<"NonNegative">;
    readonly DateIsoWithNegativeTime: number & Brand<"Int"> & Brand<"NonNegative">;
};
export declare const encodeSqliteValue: (buffer: Buffer, value: SqliteValue) => void;
export declare const decodeSqliteValue: (buffer: Buffer) => SqliteValue;
/**
 * Decodes a ProtocolMessage into a readable JSON object for debugging.
 *
 * Note: This is a stub for future implementation. It should use:
 *
 * - DecodeVersionAndOwner
 * - DecodeError or decodeWriteKeys (depending on context)
 * - DecodeMessages
 * - DecodeRanges
 *
 * If you want to help, please contribute to this function.
 */
export declare const decodeProtocolMessageToJson: (_protocolMessage: ProtocolMessage, _isInitiator: boolean) => unknown;
export {};
//# sourceMappingURL=Protocol.d.ts.map
import { bytesToHex, hexToBytes } from "../Buffer.js";
import { createRandomBytes } from "../Crypto.js";
import { createRecord, isPlainObject, objectToEntries, } from "../Object.js";
import { ok } from "../Result.js";
import { eqSqliteValue, explainSqliteQueryPlan, } from "../Sqlite.js";
import { createId, String } from "../Type.js";
/**
 * Evolu serializes {@link SqliteQuery} into a string to be easily used as a key
 * and for comparison.
 */
export const serializeQuery = (query) => {
    const params = query.parameters.map((v) => v instanceof Uint8Array
        ? ["b", bytesToHex(v)]
        : ["j", v]);
    const options = query.options
        ? objectToEntries(query.options).toSorted(([a], [b]) => a.localeCompare(b))
        : [];
    return JSON.stringify([query.sql, params, options]);
};
export const deserializeQuery = (query) => {
    const [sql, paramsArr, optionsArr] = JSON.parse(query);
    const parameters = paramsArr.map(([type, value]) => type === "b" ? hexToBytes(value) : value);
    const options = optionsArr.length
        ? Object.fromEntries(optionsArr)
        : undefined;
    return {
        sql,
        parameters,
        ...(options !== undefined && { options }),
    };
};
// To preserve identity.
export const emptyRows = [];
export const createSubscribedQueries = (rowsStore) => {
    const subscribedQueryMap = new Map();
    const subscribedQueries = {
        subscribe: (query) => (listener) => {
            subscribedQueryMap.set(query, (subscribedQueryMap.get(query) ?? 0) + 1);
            const unsubscribe = rowsStore.subscribe(listener);
            return () => {
                const count = subscribedQueryMap.get(query);
                if (count != null && count > 1) {
                    subscribedQueryMap.set(query, count - 1);
                }
                else {
                    subscribedQueryMap.delete(query);
                }
                unsubscribe();
            };
        },
        get: () => [...subscribedQueryMap.keys()],
        has: (query) => subscribedQueryMap.has(query),
    };
    return subscribedQueries;
};
export const createGetQueryRowsCache = () => {
    const tabQueryRowsCacheMap = new Map();
    return (tabId) => {
        let cache = tabQueryRowsCacheMap.get(tabId);
        if (!cache) {
            let queryRowsCache = new Map();
            cache = {
                set: (queriesRows) => {
                    queryRowsCache = new Map([...queryRowsCache, ...queriesRows]);
                },
                get: () => queryRowsCache,
            };
            tabQueryRowsCacheMap.set(tabId, cache);
        }
        return cache;
    };
};
export const loadQueries = (deps) => (tabId, queries) => {
    const queriesRows = [];
    for (const query of queries) {
        const sqlQuery = deserializeQuery(query);
        const result = deps.sqlite.exec(sqlQuery);
        if (!result.ok)
            return result;
        queriesRows.push([query, result.value.rows]);
        if (sqlQuery.options?.logExplainQueryPlan) {
            explainSqliteQueryPlan(deps)(sqlQuery);
        }
    }
    const queryRowsCache = deps.getQueryRowsCache(tabId);
    const previousState = queryRowsCache.get();
    queryRowsCache.set(queriesRows);
    const currentState = queryRowsCache.get();
    const queryPatchesArray = queries.map((query) => ({
        query,
        patches: makePatches(previousState.get(query), currentState.get(query) ?? emptyRows),
    }));
    return ok(queryPatchesArray);
};
/**
 * We detect only changes in the whole result and in-place edits. In the future,
 * we will add more heuristics. We will probably not implement the Myers diff
 * algorithm because it's faster to rerender all than to compute many detailed
 * patches. We will only implement logic a developer would implement manually,
 * if necessary.
 */
export const makePatches = (previousRows, nextRows) => {
    if (previousRows === undefined)
        return [{ op: "replaceAll", value: nextRows }];
    // TODO: Detect prepend and append, it's cheap.
    if (previousRows.length !== nextRows.length) {
        return [{ op: "replaceAll", value: nextRows }];
    }
    const length = previousRows.length;
    const replaceAtPatches = [];
    for (let i = 0; i < length; i++) {
        const previousRow = previousRows[i];
        const nextRow = nextRows[i];
        // We expect the same shape for both rows.
        for (const key in previousRow)
            if (!eqSqliteValue(previousRow[key], nextRow[key])) {
                replaceAtPatches.push({ op: "replaceAt", value: nextRow, index: i });
                break;
            }
    }
    if (length > 0 && replaceAtPatches.length === length) {
        return [{ op: "replaceAll", value: nextRows }];
    }
    return replaceAtPatches;
};
export const applyPatches = (patches, current) => patches.reduce((next, patch) => {
    switch (patch.op) {
        case "replaceAll":
            return parseSqliteJsonArray(patch.value);
        case "replaceAt": {
            const parsedRow = parseSqliteJsonArray([patch.value])[0];
            return next.toSpliced(patch.index, 1, parsedRow);
        }
    }
}, current);
/**
 * A unique identifier prepended to JSON-encoded strings. This allows safe
 * detection and parsing of only those columns that require JSON.parse.
 *
 * The identifier is a cryptographically random Evolu Id, ensuring uniqueness
 * and preventing malicious actors from inserting fake data that could be
 * misinterpreted as JSON by the application.
 *
 * Note: The same queries created by different browser tabs will have different
 * identifiers and thus be considered different and cached separately. This is
 * usually not a big deal, but if needed, the DB cache can be optimized by
 * passing the kyselyJsonIdentifier into the DB worker during initialization,
 * allowing queries to be grouped and recognized across tabs or sessions.
 *
 * See: https://github.com/kysely-org/kysely/issues/1372#issuecomment-2702773948
 */
export const kyselyJsonIdentifier = createId({
    randomBytes: createRandomBytes(),
});
export const parseSqliteJsonArray = (arr) => {
    const result = new Array(arr.length);
    for (let i = 0; i < arr.length; ++i) {
        result[i] = parse(arr[i]);
    }
    return result;
};
const parse = (obj) => {
    if (String.is(obj) && obj.startsWith(kyselyJsonIdentifier)) {
        return JSON.parse(obj.slice(kyselyJsonIdentifier.length));
    }
    if (Array.isArray(obj)) {
        return parseSqliteJsonArray(obj);
    }
    if (isPlainObject(obj)) {
        return parseObject(obj);
    }
    return obj;
};
const parseObject = (obj) => {
    const result = createRecord();
    for (const key in obj) {
        result[key] = parse(obj[key]);
    }
    return result;
};

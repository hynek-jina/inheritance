import { sha256 } from "@noble/hashes/sha2.js";
import { firstInArray, isNonEmptyReadonlyArray, } from "../Array.js";
import { assert } from "../Assert.js";
import { concatBytes } from "../Buffer.js";
import { decrement } from "../Number.js";
import { err, ok } from "../Result.js";
import { sql, SqliteValue } from "../Sqlite.js";
import { Boolean, brand, Id, NonNegativeInt, nullOr, object, PositiveInt, record, String, } from "../Type.js";
import { systemColumnsWithId } from "./Schema.js";
import { orderTimestampBytes } from "./Timestamp.js";
export const fingerprintSize = NonNegativeInt.orThrow(12);
/** A fingerprint of an empty range. */
export const zeroFingerprint = new Uint8Array(fingerprintSize);
export const InfiniteUpperBound = Symbol("InfiniteUpperBound");
export const RangeType = {
    Fingerprint: 1,
    Skip: 0,
    Timestamps: 2,
};
export const DbChangeValues = record(String, SqliteValue);
export const ValidDbChangeValues = brand("ValidDbChangeValues", DbChangeValues, (value) => {
    const invalidColumns = systemColumnsWithId.filter((key) => key in value);
    if (invalidColumns.length > 0)
        return err({
            type: "ValidDbChangeValues",
            value,
            invalidColumns,
        });
    return ok(value);
});
/**
 * A DbChange is a change to a table row. Together with a unique
 * {@link Timestamp}, it forms a {@link CrdtMessage}.
 */
export const DbChange = object({
    table: String,
    id: Id,
    values: ValidDbChangeValues,
    isInsert: Boolean,
    isDelete: nullOr(Boolean),
});
/**
 * Creates a {@link BaseSqliteStorage} implementation.
 *
 * # Stateless Design
 *
 * This implementation is fully stateless - it requires no in-memory state
 * between invocations. All necessary metadata (timestamp bounds for insertion
 * strategy optimization) is persisted in the evolu_usage table. This makes
 * Evolu Relay suitable for stateless serverless environments like AWS Lambda,
 * Cloudflare Workers with Durable Objects, and other platforms where memory
 * doesn't persist between requests. While not extensively tested in all these
 * environments yet, the stateless design should work well across them.
 */
export const createBaseSqliteStorage = (deps) => (config) => {
    return {
        insertTimestamp: (ownerId, timestamp, strategy) => {
            const level = randomSkiplistLevel(deps);
            return insertTimestamp(deps)(ownerId, timestamp, level, strategy);
        },
        getExistingTimestamps: (ownerIdBytes, timestampsBytes) => {
            const concatenatedTimestamps = concatBytes(...timestampsBytes);
            const result = deps.sqlite.exec(sql `
          with recursive
            split_timestamps(timestampBytes, pos) as (
              select
                substr(${concatenatedTimestamps}, 1, 16),
                17 as pos
              union all
              select
                substr(${concatenatedTimestamps}, pos, 16),
                pos + 16
              from split_timestamps
              where pos <= length(${concatenatedTimestamps})
            )
          select s.timestampBytes
          from
            split_timestamps s
            join evolu_timestamp t
              on t.ownerId = ${ownerIdBytes} and s.timestampBytes = t.t;
        `);
            if (!result.ok)
                return result;
            return ok(result.value.rows.map((row) => row.timestampBytes));
        },
        getSize: (ownerId) => {
            const size = getSize(deps)(ownerId);
            if (!size.ok) {
                config.onStorageError(size.error);
                return null;
            }
            return size.value;
        },
        fingerprint: (ownerId, begin, end) => {
            assertBeginEnd(begin, end);
            const result = fingerprint(deps)(ownerId, begin, end);
            if (!result.ok) {
                config.onStorageError(result.error);
                return null;
            }
            return result.value;
        },
        fingerprintRanges: (ownerId, buckets, upperBound) => {
            const ranges = fingerprintRanges(deps)(ownerId, buckets, upperBound);
            if (!ranges.ok) {
                config.onStorageError(ranges.error);
                return null;
            }
            return ranges.value;
        },
        findLowerBound: (ownerId, begin, end, upperBound) => {
            const lowerBound = findLowerBound(deps)(ownerId, begin, end, upperBound);
            if (!lowerBound.ok) {
                config.onStorageError(lowerBound.error);
                return null;
            }
            return lowerBound.value;
        },
        iterate: (ownerId, begin, end, callback) => {
            assertBeginEnd(begin, end);
            const length = end - begin;
            if (length === 0)
                return;
            // This is much faster than SQL limit with offset.
            const first = getTimestampByIndex(deps)(ownerId, begin);
            if (!first.ok) {
                config.onStorageError(first.error);
                return;
            }
            if (!callback(first.value, begin))
                return;
            if (length === 1)
                return;
            /**
             * TODO: In rare cases, we might overfetch a lot of rows here, but we
             * don't have real usage numbers yet. Fetching one row at a time would
             * probably be slower in almost all cases. In the future, we should
             * fetch in chunks (e.g., 1,000 rows at a time). For now, consider
             * logging unused rows to gather data and calculate an average, then use
             * that information to determine an optimal chunk size. Before
             * implementing chunking, be sure to run performance tests (including
             * fetching one by one).
             */
            const result = deps.sqlite.exec(sql `
          select t
          from evolu_timestamp
          where ownerId = ${ownerId} and t > ${first.value}
          order by t
          limit ${length - 1};
        `);
            if (!result.ok) {
                config.onStorageError(result.error);
                return;
            }
            for (let i = 0; i < result.value.rows.length; i++) {
                const index = NonNegativeInt.orThrow(begin + 1 + i);
                if (!callback(result.value.rows[i].t, index))
                    return;
            }
        },
        deleteOwner: (ownerId) => {
            const result = deps.sqlite.exec(sql `
          delete from evolu_timestamp where ownerId = ${ownerId};
        `);
            if (!result.ok) {
                config.onStorageError(result.error);
                return false;
            }
            return true;
        },
    };
};
const assertBeginEnd = (begin, end) => {
    assert(begin <= end, "invalid begin or end");
};
export const createBaseSqliteStorageTables = (deps) => {
    for (const query of [
        /**
         * Creates the `evolu_timestamp` table for storing timestamps of multiple
         * owners.
         *
         * All timestamps are stored in a single table using `ownerId` as part of
         * the primary key. The table implements a Skiplist structure via the `l`
         * (level) column for fast, scalable queries without the need for tree
         * balancing.
         *
         * Columns:
         *
         * - `t` – TimestampBytes
         * - `h1`/`h2` – 12-byte fingerprint split into two integers for fast XOR
         * - `c` – incremental count
         * - `l` – Skiplist level (1 to 10)
         */
        sql `
      create table evolu_timestamp (
        "ownerId" blob not null,
        "t" blob not null,
        "h1" integer,
        "h2" integer,
        "c" integer,
        "l" integer not null,
        primary key ("ownerId", "t")
      )
      strict;
    `,
        sql `
      create index evolu_timestamp_index on evolu_timestamp (
        "ownerId",
        "l",
        "t",
        "h1",
        "h2",
        "c"
      );
    `,
        /**
         * Creates the `evolu_usage` table for tracking data consumption per owner.
         *
         * Columns:
         *
         * - `ownerId` – OwnerIdBytes (primary key)
         * - `storedBytes` – total bytes stored in database
         * - `firstTimestamp` – for timestamp insertion strategies
         * - `lastTimestamp` – for timestamp insertion strategies
         */
        sql `
      create table evolu_usage (
        "ownerId" blob primary key,
        "storedBytes" integer not null,
        "firstTimestamp" blob,
        "lastTimestamp" blob
      )
      strict;
    `,
    ]) {
        const result = deps.sqlite.exec(query);
        if (!result.ok)
            return result;
    }
    return ok();
};
/**
 * Determines the insertion strategy for a timestamp based on its position
 * relative to the current first and last timestamps.
 *
 * Returns a tuple with the strategy and updated timestamp bounds.
 */
export const getTimestampInsertStrategy = (timestamp, firstTimestamp, lastTimestamp) => {
    if (orderTimestampBytes(timestamp, lastTimestamp) === 1) {
        return ["append", firstTimestamp, timestamp];
    }
    if (orderTimestampBytes(timestamp, firstTimestamp) === -1) {
        return ["prepend", timestamp, lastTimestamp];
    }
    return ["insert", firstTimestamp, lastTimestamp];
};
/**
 * AFAIK, we can't do both insert and update in one query, and that's probably
 * why append is 2x faster than insert. Prepend also has to update parents, but
 * it's constantly fast. Insert degrades for reversed (yet LIMIT X magically
 * fixes that) but it's OK for append.
 *
 * Note: SQL operations are idempotent (using `on conflict do nothing` and
 * `changes() > 0`), but this is no longer required here since we use
 * {@link BaseSqliteStorage.getExistingTimestamps} to filter out duplicates
 * before insertion, which we need for quota checks anyway.
 *
 * TODO: Remove idempotency (`on conflict do nothing` and `changes() > 0`) since
 * duplicates are now filtered before insertion.
 */
const insertTimestamp = (deps) => (ownerId, timestamp, level, strategy) => {
    const [h1, h2] = fingerprintToSqliteFingerprint(timestampBytesToFingerprint(timestamp));
    let queries = [];
    switch (strategy) {
        case "append":
            queries = [
                level === 1
                    ? sql.prepared `
                insert into evolu_timestamp
                  (ownerId, l, t, h1, h2, c)
                values
                  (${ownerId}, 1, ${timestamp}, ${h1}, ${h2}, 1)
                on conflict do nothing;
              `
                    : sql.prepared `
                with
                  fc(b, cl, pt, nt, ih1, ih2, ic) as (
                    select
                      0,
                      (
                        select max(l)
                        from evolu_timestamp
                        where ownerId = ${ownerId}
                      ),
                      zeroblob(0),
                      null,
                      0,
                      0,
                      0
                    union all
                    select
                      not b,
                      iif(b, iif(nt is null, cl - 1, cl), cl),
                      iif(b, ifnull(nt, pt), pt),
                      iif(
                        b,
                        null,
                        (
                          select t
                          from evolu_timestamp
                          where
                            ownerId = ${ownerId}
                            and l = cl
                            and t > pt
                            and t < ${timestamp}
                          order by t
                          limit 1
                        )
                      ),
                      iif(
                        b and cl < ${level} and nt is not null,
                        (
                          select (ih1 | h1) - (ih1 & h1)
                          from evolu_timestamp
                          where ownerId = ${ownerId} and t = nt
                        ),
                        ih1
                      ),
                      iif(
                        b and cl < ${level} and nt is not null,
                        (
                          select (ih2 | h2) - (ih2 & h2)
                          from evolu_timestamp
                          where ownerId = ${ownerId} and t = nt
                        ),
                        ih2
                      ),
                      iif(
                        b and cl < ${level} and nt is not null,
                        (
                          select ic + c
                          from evolu_timestamp
                          where ownerId = ${ownerId} and t = nt
                        ),
                        ic
                      )
                    from fc
                    where cl > 0
                  )
                insert into evolu_timestamp (ownerId, t, l, h1, h2, c)
                select
                  ${ownerId},
                  ${timestamp},
                  ${level},
                  (${h1} | ih1) - (${h1} & ih1),
                  (${h2} | ih2) - (${h2} & ih2),
                  ic + 1
                from fc
                order by cl asc
                limit 1
                on conflict do nothing;
              `,
            ];
            break;
        case "prepend":
            queries = [
                sql.prepared `
            insert into evolu_timestamp
              (ownerId, l, t, h1, h2, c)
            values
              (${ownerId}, ${level}, ${timestamp}, ${h1}, ${h2}, 1)
            on conflict do nothing;
          `,
                sql.prepared `
            with
              ml(ml) as (
                select max(l)
                from evolu_timestamp
                where ownerId = ${ownerId}
              ),
              fp(b, cl, pt, nt, h1, h2, c) as (
                select
                  0,
                  (select ml from ml),
                  null,
                  null,
                  null,
                  null,
                  null
                union all
                select
                  not b,
                  iif(b, cl - 1, cl),
                  iif(
                    b,
                    iif(nt is not null and (pt is null or nt < pt), nt, pt),
                    pt
                  ),
                  iif(
                    b,
                    null,
                    (
                      select t
                      from evolu_timestamp
                      where ownerId = ${ownerId} and l = cl and t > ${timestamp}
                      order by t
                      limit 1
                    )
                  ),
                  iif(
                    b and nt is not null and (pt is null or nt < pt),
                    (
                      select h1
                      from evolu_timestamp
                      where ownerId = ${ownerId} and t = nt
                    ),
                    null
                  ),
                  iif(
                    b and nt is not null and (pt is null or nt < pt),
                    (
                      select h2
                      from evolu_timestamp
                      where ownerId = ${ownerId} and t = nt
                    ),
                    null
                  ),
                  iif(
                    b and nt is not null and (pt is null or nt < pt),
                    (
                      select c
                      from evolu_timestamp
                      where ownerId = ${ownerId} and t = nt
                    ),
                    null
                  )
                from fp
                where cl > ${level}
              ),
              u(t, h1, h2) as (
                select
                  pt,
                  (${h1} | h1) - (${h1} & h1),
                  (${h2} | h2) - (${h2} & h2)
                from fp
                where h1 is not null and pt is not null
                order by pt
                -- Check skiplistMaxLevel docs.
                limit 10
              )
            update evolu_timestamp
            set
              h1 = u.h1,
              h2 = u.h2,
              c = c + 1
            from u
            where
              changes() > 0
              and ownerId = ${ownerId}
              and evolu_timestamp.t = u.t;
          `,
            ];
            break;
        case "insert":
            queries =
                level === 1
                    ? [
                        sql.prepared `
                  insert into evolu_timestamp
                    (ownerId, l, t, h1, h2, c)
                  values
                    (${ownerId}, 1, ${timestamp}, ${h1}, ${h2}, 1)
                  on conflict do nothing;
                `,
                        // DEV: Check whether a boolean flag is faster.
                        sql.prepared `
                  with
                    p(l, t, h1, h2) as (
                      select
                        (
                          select max(l) + 1
                          from evolu_timestamp
                          where ownerId = ${ownerId}
                        ),
                        null,
                        null,
                        null
                      union all
                      select
                        p.l - 1,
                        ifnull(
                          (
                            select t
                            from evolu_timestamp
                            where
                              ownerId = ${ownerId}
                              and l = p.l - 1
                              and t > ${timestamp}
                              and (p.t is null or p.t > t)
                            order by t
                            limit 1
                          ),
                          p.t
                        ),
                        (
                          select h1
                          from evolu_timestamp
                          where
                            ownerId = ${ownerId}
                            and l = p.l - 1
                            and t > ${timestamp}
                            and (p.t is null or p.t > t)
                          order by t
                          limit 1
                        ),
                        (
                          select h2
                          from evolu_timestamp
                          where
                            ownerId = ${ownerId}
                            and l = p.l - 1
                            and t > ${timestamp}
                            and (p.t is null or p.t > t)
                          order by t
                          limit 1
                        )
                      from p
                      where p.l > 2
                      -- Check skiplistMaxLevel docs.
                      limit 10
                    ),
                    u(t, h1, h2) as (
                      select
                        t,
                        (${h1} | h1) - (${h1} & h1),
                        (${h2} | h2) - (${h2} & h2)
                      from p
                      where h1 is not null
                    )
                  update evolu_timestamp
                  set
                    h1 = u.h1,
                    h2 = u.h2,
                    c = c + 1
                  from u
                  where
                    changes() > 0
                    and ownerId = ${ownerId}
                    and evolu_timestamp.t = u.t;
                `,
                    ]
                    : [
                        sql.prepared `
                  insert into evolu_timestamp (ownerId, t, l)
                  values (${ownerId}, ${timestamp}, ${level})
                  on conflict do nothing;
                `,
                        sql.prepared `
                  with
                    c0(b, cl, pt, nt, h1, h2, c) as (
                      select
                        0,
                        (
                          select max(l)
                          from evolu_timestamp
                          where ownerId = ${ownerId}
                        ),
                        0,
                        null,
                        null,
                        null,
                        null
                      union all
                      select
                        not b,
                        iif(b, iif(nt is null, cl - 1, cl), cl),
                        iif(b, ifnull(nt, pt), pt),
                        iif(
                          b,
                          null,
                          (
                            select t
                            from evolu_timestamp
                            where
                              ownerId = ${ownerId}
                              and l = cl
                              and t > pt
                              and t < ${timestamp}
                            order by t
                            limit 1
                          )
                        ),
                        iif(
                          b and cl < ${level} and nt is not null,
                          (
                            select h1
                            from evolu_timestamp
                            where ownerId = ${ownerId} and t = nt
                          ),
                          null
                        ),
                        iif(
                          b and cl < ${level} and nt is not null,
                          (
                            select h2
                            from evolu_timestamp
                            where ownerId = ${ownerId} and t = nt
                          ),
                          null
                        ),
                        iif(
                          b and cl < ${level} and nt is not null,
                          (
                            select c
                            from evolu_timestamp
                            where ownerId = ${ownerId} and t = nt
                          ),
                          null
                        )
                      from c0
                      where cl > 0
                    ),
                    c1(l, t, h1, h2, c) as (
                      select
                        ${level},
                        ${timestamp},
                        ${h1},
                        ${h2},
                        1
                      union all
                      select cl, pt, h1, h2, c
                      from c0
                      where h1 is not null
                    ),
                    c2(rn, l, t, h1, h2, c) as (
                      select row_number() over (order by l), l, t, h1, h2, c
                      from c1
                    ),
                    c3(rn, l, t, h1, h2, c) as (
                      select rn, l, t, h1, h2, c from c2 where rn = 1
                      union all
                      select
                        c3.rn + 1,
                        c2.l,
                        c2.t,
                        (c2.h1 | c3.h1) - (c2.h1 & c3.h1),
                        (c2.h2 | c3.h2) - (c2.h2 & c3.h2),
                        c2.c + c3.c
                      from
                        c3
                        join c2 on c2.rn = c3.rn + 1
                    ),
                    c4(l, t, h1, h2, c, rn) as (
                      select l, t, h1, h2, c, max(rn)
                      from c3
                      group by l
                    ),
                    -- DEV: Check whether a boolean flag is faster.
                    n(l, t, h1, h2, c) as (
                      select
                        (
                          select max(l) + 1
                          from evolu_timestamp
                          where ownerId = ${ownerId}
                        ),
                        null,
                        null,
                        null,
                        null
                      union all
                      select
                        n.l - 1,
                        ifnull(
                          (
                            select t
                            from evolu_timestamp
                            where
                              ownerId = ${ownerId}
                              and l = n.l - 1
                              and t > ${timestamp}
                              and (n.t is null or t < n.t)
                            order by t
                            limit 1
                          ),
                          n.t
                        ),
                        (
                          select h1
                          from evolu_timestamp
                          where
                            ownerId = ${ownerId}
                            and l = n.l - 1
                            and t > ${timestamp}
                            and (n.t is null or t < n.t)
                          order by t
                          limit 1
                        ),
                        (
                          select h2
                          from evolu_timestamp
                          where
                            ownerId = ${ownerId}
                            and l = n.l - 1
                            and t > ${timestamp}
                            and (n.t is null or t < n.t)
                          order by t
                          limit 1
                        ),
                        (
                          select c
                          from evolu_timestamp
                          where
                            ownerId = ${ownerId}
                            and l = n.l - 1
                            and t > ${timestamp}
                            and (n.t is null or t < n.t)
                          order by t
                          limit 1
                        )
                      from n
                      where l - 1 > (select min(l) from c4)
                    ),
                    u(ut, uh1, uh2, uc) as (
                      select t, h1, h2, c from c4 where t = ${timestamp}
                      union all
                      select
                        max(t),
                        iif(
                          l > ${level},
                          (${h1} | h1) - (${h1} & h1),
                          (
                            select (c4.h1 | n.h1) - (c4.h1 & n.h1)
                            from c4
                            where
                              c4.l = (select max(l) from c4 where c4.l < n.l)
                          )
                        ),
                        iif(
                          l > ${level},
                          (${h2} | h2) - (${h2} & h2),
                          (
                            select (c4.h2 | n.h2) - (c4.h2 & n.h2)
                            from c4
                            where
                              c4.l = (select max(l) from c4 where c4.l < n.l)
                          )
                        ),
                        iif(
                          l > ${level},
                          c + 1,
                          (
                            select n.c - c4.c
                            from c4
                            where
                              c4.l = (select max(l) from c4 where c4.l < n.l)
                          )
                        )
                      from n
                      group by t
                      -- Check skiplistMaxLevel docs.
                      limit 10
                    )
                  update evolu_timestamp
                  set
                    h1 = uh1,
                    h2 = uh2,
                    c = uc
                  from u
                  where changes() > 0 and ownerId = ${ownerId} and t = ut;
                `,
                    ];
            break;
    }
    for (const query of queries) {
        const result = deps.sqlite.exec(query);
        if (!result.ok)
            return result;
    }
    return ok();
};
export const timestampBytesToFingerprint = (timestamp) => {
    const hash = sha256(timestamp).slice(0, fingerprintSize);
    return hash;
};
/**
 * Generates a random skiplist level in the range [1, skiplistMaxLevel].
 * Probabilistic approach avoids the need for explicit tree balancing.
 */
const randomSkiplistLevel = (deps) => {
    let level = 1;
    while (deps.random.next() <= skiplistProbability &&
        level < skiplistMaxLevel) {
        level += 1;
    }
    return PositiveInt.orThrow(level);
};
/**
 * Probability used for generating Skiplist levels.
 *
 * 0.5 is little faster for the first 30k.
 */
const skiplistProbability = 0.25;
/**
 * The SQLite has weird behaviour when we have to limit CTEs even when we don't
 * actually limit anything; otherwise, it would not work. But without it, SQLite
 * insert and prepend is slow. The 10 is the maximum allowed number, which
 * "fixes" SQLite.
 *
 * Because we are using {@link skiplistProbability} 0.25, it's OK even for
 * millions of rows.
 */
const skiplistMaxLevel = 10;
const fingerprintToSqliteFingerprint = (fingerprint) => {
    let part1 = BigInt(0);
    let part2 = BigInt(0);
    for (let i = 0; i < 6; i++) {
        part1 = (part1 << BigInt(8)) | BigInt(fingerprint[i]);
    }
    for (let i = 6; i < 12; i++) {
        part2 = (part2 << BigInt(8)) | BigInt(fingerprint[i]);
    }
    return [part1.toString(), part2.toString()];
};
const sqliteFingerprintToFingerprint = ([part1String, part2String,]) => {
    let part1 = BigInt(part1String);
    let part2 = BigInt(part2String);
    const hash = new Uint8Array(12);
    for (let i = 5; i >= 0; i--) {
        hash[i] = Number(part1 & BigInt(0xff));
        part1 >>= BigInt(8);
    }
    for (let i = 11; i >= 6; i--) {
        hash[i] = Number(part2 & BigInt(0xff));
        part2 >>= BigInt(8);
    }
    return hash;
};
const getSize = (deps) => (ownerId) => {
    const result = deps.sqlite.exec(sql.prepared `
      with
        ml(ml) as (
          select max(l)
          from evolu_timestamp
          where ownerId = ${ownerId}
        ),
        sc(l, pt, c) as (
          select (select ml + 1 from ml), zeroblob(0), 0
          union all
          select
            sc.l - 1,
            ifnull(
              (
                select max(t)
                from evolu_timestamp as m
                where ownerId = ${ownerId} and m.l = sc.l - 1 and m.t > sc.pt
              ),
              sc.pt
            ),
            ifnull(
              (
                select sum(m.c)
                from evolu_timestamp as m
                where ownerId = ${ownerId} and m.l = sc.l - 1 and m.t > sc.pt
              ),
              0
            )
          from sc
          where sc.l > 1
        )
      select sum(c) as size
      from sc;
    `);
    if (!result.ok)
        return result;
    return ok(result.value.rows[0].size);
};
const findLowerBound = (deps) => (ownerId, begin, end, upperBound) => {
    assertBeginEnd(begin, end);
    if (end === 0 || begin === end || upperBound === InfiniteUpperBound) {
        return ok(end);
    }
    const result = deps.sqlite.exec(sql.prepared `
      select t
      from evolu_timestamp
      where ownerId = ${ownerId} and t >= ${upperBound}
      order by t
      limit 1;
    `);
    if (!result.ok)
        return result;
    if (result.value.rows.length === 0) {
        return ok(end);
    }
    const count = getTimestampCount(deps)(ownerId, result.value.rows[0].t);
    if (!count.ok)
        return count;
    // `decrement` converts a count to an index.
    return ok(NonNegativeInt.orThrow(decrement(count.value)));
};
const getTimestampCount = (deps) => (ownerId, timestamp) => {
    const result = deps.sqlite.exec(sql.prepared `
      with
        ml(ml) as (
          select max(l) from evolu_timestamp where ownerId = ${ownerId}
        ),
        sc(l, pt, tc) as (
          select ml + 1, zeroblob(0), 0 from ml
          union all
          select
            sc.l - 1,
            ifnull(
              (
                select max(t)
                from evolu_timestamp
                where
                  ownerId = ${ownerId}
                  and l = sc.l - 1
                  and t <= ${timestamp}
                  and t > sc.pt
                order by t
              ),
              sc.pt
            ),
            ifnull(
              (
                select sum(c)
                from evolu_timestamp
                where
                  ownerId = ${ownerId}
                  and l = sc.l - 1
                  and t <= ${timestamp}
                  and t > sc.pt
              ),
              0
            )
          from sc
          where sc.l > 1 and sc.pt != ${timestamp}
        )
      select sum(tc) as count
      from sc;
    `);
    if (!result.ok)
        return result;
    return ok(result.value.rows[0].count);
};
/**
 * TODO: We reuse {@link fingerprintRanges}, which returns upper bound, which we
 * don't need, so fingerprintRanges should have a parameter for that.
 */
const fingerprint = (deps) => (ownerId, begin, end) => {
    // There is no need to fingerprint an empty range.
    if (end - begin === 0) {
        return ok(zeroFingerprint);
    }
    if (begin === 0) {
        const result = fingerprintRanges(deps)(ownerId, [end]);
        if (!result.ok)
            return result;
        return ok(result.value[0].fingerprint);
    }
    // We should have a param to skip the first result.
    const result = fingerprintRanges(deps)(ownerId, [begin, end]);
    if (!result.ok)
        return result;
    return ok(result.value[1].fingerprint);
};
/**
 * First, check this: https://logperiodic.com/rbsr.html#tree-friendly-functions
 *
 * We are a little smarter. We leverage continuous ranges to have half of
 * traversals. 16 instead of 32. And we compute all of them in a single SQL
 * select. If only we could get rid of those subqueries. Then, it would be
 * perfect. Btw, reading h1, h2, c in the second step would be slighly faster.
 */
const fingerprintRanges = (deps) => (ownerId, buckets, upperBound = InfiniteUpperBound) => {
    const bucketsJson = JSON.stringify(buckets);
    const result = deps.sqlite.exec(sql.prepared `
      with
        ml(ml) as (
          select max(l) from evolu_timestamp where ownerId = ${ownerId}
        ),
        c0(c) as (select value as c from json_each(${bucketsJson})),
        c1(c, b, nt, nc, nh1, nh2, ft, tt, dl, ic, h1, h2) as (
          select
            c,
            1,
            null,
            null,
            null,
            null,
            zeroblob(0),
            X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF',
            ml,
            0,
            0,
            0
          from
            c0,
            ml
          union all
          select
            c,
            not b,
            iif(
              b,
              (
                select t
                from evolu_timestamp
                where l = dl and t > ft and t < tt and ownerId = ${ownerId}
                order by t
                limit 1
              ),
              null
            ),
            iif(
              b,
              (
                select c
                from evolu_timestamp
                where l = dl and t > ft and t < tt and ownerId = ${ownerId}
                order by t
                limit 1
              ),
              null
            ),
            iif(
              b,
              (
                select h1
                from evolu_timestamp
                where l = dl and t > ft and t < tt and ownerId = ${ownerId}
                order by t
                limit 1
              ),
              null
            ),
            iif(
              b,
              (
                select h2
                from evolu_timestamp
                where l = dl and t > ft and t < tt and ownerId = ${ownerId}
                order by t
                limit 1
              ),
              null
            ),
            iif(b, ft, iif(ic + nc <= c, nt, ft)),
            iif(b, tt, iif(ic + nc <= c, tt, ifnull(nt, tt))),
            iif(b, dl, iif(ic + nc <= c, dl, dl - 1)),
            iif(b, ic, iif(ic + nc <= c, ic + nc, ic)),
            iif(b, h1, iif(ic + nc <= c, ${x("h1", "nh1")}, h1)),
            iif(b, h2, iif(ic + nc <= c, ${x("h2", "nh2")}, h2))
          from c1
          where iif(b, 1, ic != c)
        ),
        c2(h1, h2, t, rn) as (
          select
            h1,
            h2,
            (
              select min(t)
              from evolu_timestamp
              where t > ft and ownerId = ${ownerId}
            ),
            row_number() over (order by c)
          from c1
          where c = ic and b = 1
        ),
        c3(oh1, oh2, b, rn, h1, h2) as (
          select h1, h2, t, rn, h1, h2 from c2 where rn = 1
          union all
          select
            c2.h1,
            c2.h2,
            t,
            c2.rn,
            ${x("c3.oh1", "c2.h1")},
            ${x("c3.oh2", "c2.h2")}
          from
            c2
            join c3 on c2.rn = c3.rn + 1
        )
      select b, cast(h1 as text) as h1, cast(h2 as text) as h2
      from c3;
    `);
    if (!result.ok)
        return result;
    const fingerprintRanges = result.value.rows.map((row, i, arr) => ({
        type: RangeType.Fingerprint,
        upperBound: i === arr.length - 1 ? upperBound : row.b,
        fingerprint: sqliteFingerprintToFingerprint([
            row.h1,
            row.h2,
        ]),
    }));
    return ok(fingerprintRanges);
};
// XOR in SQLite
const x = (a, b) => sql.raw(`(${a} | ${b}) - (${a} & ${b})`);
export const getTimestampByIndex = (deps) => (ownerId, index) => {
    const result = deps.sqlite.exec(sql.prepared `
      with
        fi(b, cl, ic, pt, mt, nt, nc) as (
          select
            0,
            (
              select max(l)
              from evolu_timestamp
              where ownerId = ${ownerId}
            ),
            0,
            zeroblob(0),
            X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF',
            null,
            0
          union all
          select
            not b,
            iif(
              b,
              iif(nt is null or nt > mt or ic + nc > ${index + 1}, cl - 1, cl),
              cl
            ),
            iif(
              b,
              iif(nt is null or nt > mt or ic + nc > ${index + 1}, ic, ic + nc),
              ic
            ),
            iif(
              b,
              iif(nt is null or nt > mt or ic + nc > ${index + 1}, pt, nt),
              pt
            ),
            iif(
              b,
              iif(
                nt is null or nt > mt or ic + nc > ${index + 1},
                iif(nt is not null and nt < mt, nt, mt),
                mt
              ),
              mt
            ),
            iif(
              b,
              null,
              (
                select t
                from evolu_timestamp
                where ownerId = ${ownerId} and l = cl and t > pt
                order by t
                limit 1
              )
            ),
            iif(
              b,
              null,
              (
                select c
                from evolu_timestamp
                where ownerId = ${ownerId} and l = cl and t > pt
                order by t
                limit 1
              )
            )
          from fi
          where ic != ${index + 1}
        )
      select pt
      from fi
      where ic == ${index + 1};
    `);
    if (!result.ok)
        return result;
    return ok(result.value.rows[0].pt);
};
/** Retrieves usage information for an owner from the evolu_usage table. */
export const getOwnerUsage = (deps) => (ownerIdBytes, initialTimestamp) => {
    const result = deps.sqlite.exec(sql `
      select storedBytes, firstTimestamp, lastTimestamp
      from evolu_usage
      where ownerId = ${ownerIdBytes};
    `);
    if (!result.ok)
        return result;
    if (!isNonEmptyReadonlyArray(result.value.rows)) {
        return ok({
            storedBytes: null,
            firstTimestamp: initialTimestamp,
            lastTimestamp: initialTimestamp,
        });
    }
    const row = firstInArray(result.value.rows);
    assert(row.firstTimestamp, "not null");
    assert(row.lastTimestamp, "not null");
    return ok({
        storedBytes: row.storedBytes,
        firstTimestamp: row.firstTimestamp,
        lastTimestamp: row.lastTimestamp,
    });
};
/**
 * Updates timestamp bounds in evolu_usage table.
 *
 * Used by both relay and client to maintain firstTimestamp/lastTimestamp after
 * processing messages.
 */
export const updateOwnerUsage = (deps) => (ownerIdBytes, storedBytes, firstTimestamp, lastTimestamp) => {
    const result = deps.sqlite.exec(sql `
      insert into evolu_usage
        ("ownerId", "storedBytes", "firstTimestamp", "lastTimestamp")
      values
        (${ownerIdBytes}, ${storedBytes}, ${firstTimestamp}, ${lastTimestamp})
      on conflict (ownerId) do update
        set
          storedBytes = ${storedBytes},
          firstTimestamp = ${firstTimestamp},
          lastTimestamp = ${lastTimestamp};
    `);
    if (!result.ok)
        return result;
    return ok();
};

import { firstInArray, isNonEmptyArray, } from "../Array.js";
import { assertNonEmptyReadonlyArray } from "../Assert.js";
import { createSymmetricCrypto, } from "../Crypto.js";
import { ok } from "../Result.js";
import { createSqlite, sql, } from "../Sqlite.js";
import { SimpleName } from "../Type.js";
import { createInitializedWorkerWithHandlers, } from "../Worker.js";
import { createAppOwner, createOwnerSecret, mnemonicToOwnerSecret, } from "./Owner.js";
import { protocolVersion } from "./Protocol.js";
import { createGetQueryRowsCache, loadQueries, } from "./Query.js";
import { ensureDbSchema, getDbSchema, } from "./Schema.js";
import { createBaseSqliteStorageTables } from "./Storage.js";
import { applyLocalOnlyChange, createClock, createSync, tryApplyQuarantinedMessages, } from "./Sync.js";
import { timestampBytesToTimestamp, timestampToTimestampBytes, } from "./Timestamp.js";
export const defaultDbConfig = {
    name: SimpleName.orThrow("Evolu"),
    transports: [{ type: "WebSocket", url: "wss://free.evoluhq.com" }],
    maxDrift: 5 * 60 * 1000,
    enableLogging: false,
};
export const createDbWorkerForPlatform = (platformDeps) => createInitializedWorkerWithHandlers({
    init: async (initMessage, postMessage) => {
        platformDeps.console.enabled = initMessage.config.enableLogging ?? false;
        const deps = await createDbWorkerDeps(platformDeps, initMessage, postMessage);
        if (!deps.ok) {
            postMessage({ type: "onError", error: deps.error });
            return null;
        }
        return deps.value;
    },
    handlers,
});
const createDbWorkerDeps = async (platformDeps, initMessage, postMessage) => {
    const sqlite = await createSqlite(platformDeps)(initMessage.config.name, {
        memory: initMessage.config.inMemory ?? false,
        encryptionKey: initMessage.config.encryptionKey ?? undefined,
    });
    if (!sqlite.ok)
        return sqlite;
    const deps = { ...platformDeps, sqlite: sqlite.value };
    return deps.sqlite.transaction(() => {
        const dbSchema = getDbSchema(deps)();
        if (!dbSchema.ok)
            return dbSchema;
        const dbIsInitialized = "evolu_version" in dbSchema.value.tables;
        let appOwner;
        let clock;
        if (dbIsInitialized) {
            const currentVersion = deps.sqlite.exec(sql `select protocolVersion from evolu_version limit 1;`);
            if (!currentVersion.ok)
                return currentVersion;
            const configResult = deps.sqlite.exec(sql `
        select
          clock,
          appOwnerId,
          appOwnerEncryptionKey,
          appOwnerWriteKey,
          appOwnerMnemonic
        from evolu_config
        limit 1;
      `);
            if (!configResult.ok)
                return configResult;
            assertNonEmptyReadonlyArray(configResult.value.rows);
            const config = firstInArray(configResult.value.rows);
            appOwner = {
                type: "AppOwner",
                id: config.appOwnerId,
                encryptionKey: config.appOwnerEncryptionKey,
                writeKey: config.appOwnerWriteKey,
                mnemonic: config.appOwnerMnemonic,
            };
            clock = createClock(deps)(timestampBytesToTimestamp(config.clock));
        }
        else {
            appOwner =
                initMessage.config.externalAppOwner ??
                    createAppOwner(createOwnerSecret(platformDeps));
            clock = createClock(deps)();
            const result = initializeDb(deps)(appOwner, clock.get());
            if (!result.ok)
                return result;
        }
        {
            const result = ensureDbSchema(deps)(initMessage.dbSchema, dbSchema.value);
            if (!result.ok)
                return result;
        }
        {
            const result = ensureMessageQuarantineTable(deps);
            if (!result.ok)
                return result;
        }
        const sync = createSync({
            ...deps,
            clock,
            symmetricCrypto: createSymmetricCrypto(platformDeps),
            timestampConfig: initMessage.config,
            dbSchema: initMessage.dbSchema,
        })({
            appOwner,
            transports: initMessage.config.transports,
            onError: (error) => {
                postMessage({ type: "onError", error });
            },
            onReceive: () => {
                postMessage({ type: "refreshQueries" });
            },
        });
        if (!sync.ok)
            return sync;
        {
            const result = tryApplyQuarantinedMessages({
                ...deps,
                dbSchema: initMessage.dbSchema,
            })();
            if (!result.ok)
                return result;
        }
        sync.value.useOwner(true, appOwner);
        return ok({
            ...deps,
            getQueryRowsCache: createGetQueryRowsCache(),
            postMessage,
            sync: sync.value,
            appOwner,
        });
    });
};
const initializeDb = (deps) => (initialAppOwner, initialClock) => {
    for (const query of [
        // Never change structure to ensure all versions can read it.
        sql `
        create table evolu_version (
          "protocolVersion" integer not null
        )
        strict;
      `,
        sql `
        insert into evolu_version ("protocolVersion")
        values (${protocolVersion});
      `,
        sql `
        create table evolu_config (
          "clock" blob not null,
          "appOwnerId" text not null,
          "appOwnerEncryptionKey" blob not null,
          "appOwnerWriteKey" blob not null,
          "appOwnerMnemonic" text
        )
        strict;
      `,
        sql `
        insert into evolu_config
          (
            "clock",
            "appOwnerId",
            "appOwnerEncryptionKey",
            "appOwnerWriteKey",
            "appOwnerMnemonic"
          )
        values
          (
            ${timestampToTimestampBytes(initialClock)},
            ${initialAppOwner.id},
            ${initialAppOwner.encryptionKey},
            ${initialAppOwner.writeKey},
            ${initialAppOwner.mnemonic ?? null}
          );
      `,
        /**
         * The History table stores all values per ownerId, timestamp, table, id,
         * and column for conflict-free merging using last-write-win CRDT.
         * Denormalizes Timestamp and DbChange for covering index performance.
         * Time travel is available when last-write-win isn't desired. Future
         * optimization will store history more efficiently.
         */
        sql `
        create table evolu_history (
          "ownerId" blob not null,
          "table" text not null,
          "id" blob not null,
          "column" text not null,
          "timestamp" blob not null,
          "value" any
        )
        strict;
      `,
        // Index for reading database changes by owner and timestamp.
        sql `
        create index evolu_history_ownerId_timestamp on evolu_history (
          "ownerId",
          "timestamp"
        );
      `,
        sql `
        create unique index evolu_history_ownerId_table_id_column_timestampDesc on evolu_history (
          "ownerId",
          "table",
          "id",
          "column",
          "timestamp" desc
        );
      `,
    ]) {
        const result = deps.sqlite.exec(query);
        if (!result.ok)
            return result;
    }
    const result = createBaseSqliteStorageTables(deps);
    if (!result.ok)
        return result;
    return ok();
};
/**
 * Ensures the quarantine table exists for storing messages with unknown schema.
 *
 * When a device receives sync messages containing tables or columns that don't
 * exist in its current schema (e.g., from a newer app version), those messages
 * are stored here instead of being discarded. This enables forward
 * compatibility:
 *
 * 1. Unknown data is preserved and can be applied when the app is updated
 * 2. Messages are still propagated to other devices that may understand them
 * 3. Partial messages work - known columns go to app tables, unknown to quarantine
 *
 * The `union all` query in `readDbChange` combines `evolu_history` and this
 * table, ensuring all data (known and unknown) is included when syncing to
 * other devices.
 */
const ensureMessageQuarantineTable = (deps) => {
    const result = deps.sqlite.exec(sql `
    create table if not exists evolu_message_quarantine (
      "ownerId" blob not null,
      "timestamp" blob not null,
      "table" text not null,
      "id" blob not null,
      "column" text not null,
      "value" any,
      primary key ("ownerId", "timestamp", "table", "id", "column")
    )
    strict;
  `);
    if (!result.ok)
        return result;
    return ok();
};
const handlers = {
    getAppOwner: (deps) => () => {
        deps.postMessage({
            type: "onGetAppOwner",
            appOwner: deps.appOwner,
        });
    },
    mutate: (deps) => (message) => {
        const mutate = deps.sqlite.transaction(() => {
            const syncChanges = [];
            for (const change of message.changes) {
                const isLocalOnlyChange = change.table.startsWith("_");
                if (isLocalOnlyChange) {
                    const result = applyLocalOnlyChange(deps)(change);
                    if (!result.ok)
                        return result;
                }
                else {
                    syncChanges.push(change);
                }
            }
            if (isNonEmptyArray(syncChanges)) {
                const result = deps.sync.applyChanges(syncChanges);
                if (!result.ok)
                    return result;
            }
            // Read writes before commit to update UI ASAP
            const queryPatches = loadQueries(deps)(message.tabId, message.subscribedQueries);
            if (!queryPatches.ok)
                return queryPatches;
            // Update the tab that performed the mutation.
            deps.postMessage({
                type: "onQueryPatches",
                tabId: message.tabId,
                queryPatches: queryPatches.value,
                onCompleteIds: message.onCompleteIds,
            });
            // Notify other tabs to refresh their queries.
            deps.postMessage({ type: "refreshQueries", tabId: message.tabId });
            return ok();
        });
        if (!mutate.ok) {
            deps.postMessage({ type: "onError", error: mutate.error });
            return;
        }
    },
    query: (deps) => (message) => {
        const queryPatches = loadQueries(deps)(message.tabId, message.queries);
        if (!queryPatches.ok) {
            deps.postMessage({ type: "onError", error: queryPatches.error });
            return;
        }
        deps.postMessage({
            type: "onQueryPatches",
            tabId: message.tabId,
            queryPatches: queryPatches.value,
            onCompleteIds: [],
        });
    },
    reset: (deps) => (message) => {
        const result = deps.sqlite.transaction(() => {
            const dbSchema = getDbSchema(deps)();
            if (!dbSchema.ok)
                return dbSchema;
            for (const tableName in dbSchema.value.tables) {
                /**
                 * The dropped table is completely removed from the database schema and
                 * the disk file. The table can not be recovered. All indices and
                 * triggers associated with the table are also deleted.
                 * https://sqlite.org/lang_droptable.html
                 */
                const result = deps.sqlite.exec(sql `
          drop table ${sql.identifier(tableName)};
        `);
                if (!result.ok)
                    return result;
            }
            if (message.restore) {
                const result = ensureDbSchema(deps)(message.restore.dbSchema);
                if (!result.ok)
                    return result;
                const secret = mnemonicToOwnerSecret(message.restore.mnemonic);
                const appOwner = createAppOwner(secret);
                const clock = createClock(deps)();
                return initializeDb(deps)(appOwner, clock.get());
            }
            return ok();
        });
        if (!result.ok) {
            deps.postMessage({ type: "onError", error: result.error });
            return;
        }
        deps.postMessage({
            type: "onReset",
            onCompleteId: message.onCompleteId,
            reload: message.reload,
        });
    },
    ensureDbSchema: (deps) => (message) => {
        const result = deps.sqlite.transaction(() => ensureDbSchema(deps)(message.dbSchema));
        if (!result.ok) {
            deps.postMessage({ type: "onError", error: result.error });
            return;
        }
    },
    export: (deps) => (message) => {
        const file = deps.sqlite.export();
        if (!file.ok) {
            deps.postMessage({ type: "onError", error: file.error });
            return;
        }
        deps.postMessage({
            type: "onExport",
            onCompleteId: message.onCompleteId,
            file: file.value,
        });
    },
    useOwner: (deps) => (message) => {
        deps.sync.useOwner(message.use, message.owner);
    },
};

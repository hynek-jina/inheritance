import * as Kysely from "kysely";
import { ReadonlyRecord } from "../Object.js";
import { Result } from "../Result.js";
import { SqliteBoolean, SqliteDep, SqliteError, SqliteQueryOptions, SqliteValue } from "../Sqlite.js";
import { AnyType, IdBytes, InferErrors, InferInput, InferType, MergeObjectTypeErrors, NullableToOptionalProps, ObjectType, OptionalType, TableId, Type, ValidMutationSize, ValidMutationSizeError } from "../Type.js";
import { Simplify } from "../Types.js";
import { OwnerId } from "./Owner.js";
import { Query, Row } from "./Query.js";
import type { DbChange } from "./Storage.js";
import { TimestampBytes } from "./Timestamp.js";
/**
 * Defines the schema of an Evolu database.
 *
 * Table schema defines columns that are required for table rows. For not
 * required columns, use {@link nullOr}.
 *
 * ### Example
 *
 * ```ts
 * const TodoId = id("Todo");
 * type TodoId = typeof TodoId.Type;
 *
 * const TodoCategoryId = id("TodoCategory");
 * type TodoCategoryId = typeof TodoCategoryId.Type;
 *
 * const NonEmptyString50 = maxLength(50)(NonEmptyString);
 * type NonEmptyString50 = typeof NonEmptyString50.Type;
 *
 * // Database schema.
 * const Schema = {
 *   todo: {
 *     id: TodoId,
 *     title: NonEmptyString1000,
 *     isCompleted: nullable(SqliteBoolean),
 *     categoryId: nullable(TodoCategoryId),
 *   },
 *   todoCategory: {
 *     id: TodoCategoryId,
 *     name: NonEmptyString50,
 *     json: nullable(SomeJson),
 *   },
 * };
 * ```
 */
export type EvoluSchema = ReadonlyRecord<string, ReadonlyRecord<string, Type<any, any, any, any, any, any>>>;
/**
 * Validates an {@link EvoluSchema} at compile time, returning the first error
 * found as a readable string literal type. This approach provides much clearer
 * and more actionable TypeScript errors than the default, which are often hard
 * to read.
 *
 * Validates the following schema requirements:
 *
 * 1. All tables must have an 'id' column
 * 2. The 'id' column must be a branded ID type (created with id() function)
 * 3. Tables cannot use system column names (createdAt, updatedAt, isDeleted)
 * 4. All column types must be compatible with SQLite (extend SqliteValue)
 */
export type ValidateSchema<S extends EvoluSchema> = ValidateSchemaHasId<S> extends never ? ValidateIdColumnType<S> extends never ? ValidateNoSystemColumns<S> extends never ? ValidateColumnTypes<S> extends never ? S : ValidateColumnTypes<S> : ValidateNoSystemColumns<S> : ValidateIdColumnType<S> : ValidateSchemaHasId<S>;
export type ValidateSchemaHasId<S extends EvoluSchema> = keyof S extends infer TableName ? TableName extends keyof S ? "id" extends keyof S[TableName] ? never : SchemaValidationError<`Table "${TableName & string}" is missing required id column.`> : never : never;
export type ValidateIdColumnType<S extends EvoluSchema> = keyof S extends infer TableName ? TableName extends keyof S ? "id" extends keyof S[TableName] ? S[TableName]["id"] extends TableId<any> ? never : SchemaValidationError<`Table "${TableName & string}" id column must be a branded ID type (created with id("${TableName & string}")).`> : never : never : never;
export type ValidateNoSystemColumns<S extends EvoluSchema> = keyof S extends infer TableName ? TableName extends keyof S ? keyof S[TableName] extends infer ColumnName ? ColumnName extends keyof S[TableName] ? ColumnName extends "createdAt" | "updatedAt" | "isDeleted" | "ownerId" ? SchemaValidationError<`Table "${TableName & string}" uses system column name "${ColumnName & string}". System columns (createdAt, updatedAt, isDeleted, ownerId) are added automatically.`> : never : never : never : never : never;
export type ValidateColumnTypes<S extends EvoluSchema> = keyof S extends infer TableName ? TableName extends keyof S ? keyof S[TableName] extends infer ColumnName ? ColumnName extends keyof S[TableName] ? InferType<S[TableName][ColumnName]> extends SqliteValue ? never : SchemaValidationError<`Table "${TableName & string}" column "${ColumnName & string}" type is not compatible with SQLite. Column types must extend SqliteValue (string, number, Uint8Array, or null).`> : never : never : never : never;
/** Schema validation error that shows clear, readable messages */
export type SchemaValidationError<Message extends string> = `âŒ Schema Error: ${Message}`;
export type IndexesConfig = (create: (indexName: string) => Kysely.CreateIndexBuilder) => ReadonlyArray<Kysely.CreateIndexBuilder<any>>;
export declare const evoluSchemaToDbSchema: (schema: EvoluSchema, indexesConfig?: IndexesConfig) => DbSchema;
export type CreateQuery<S extends EvoluSchema> = <R extends Row>(queryCallback: (db: Pick<Kysely.Kysely<{
    [Table in keyof S]: {
        readonly [Column in keyof S[Table]]: Column extends "id" ? InferType<S[Table][Column]> : InferType<S[Table][Column]> | null;
    } & SystemColumns;
} & {
    readonly evolu_history: {
        readonly timestamp: TimestampBytes;
        readonly table: keyof S;
        readonly id: IdBytes;
        readonly column: string;
        readonly value: SqliteValue;
    };
    readonly evolu_message_quarantine: {
        readonly timestamp: TimestampBytes;
        readonly table: string;
        readonly id: IdBytes;
        readonly column: string;
        readonly value: SqliteValue;
    };
}>, "selectFrom" | "fn" | "with" | "withRecursive">) => Kysely.SelectQueryBuilder<any, any, R>, options?: SqliteQueryOptions) => Query<Simplify<R>>;
/**
 * System columns that are implicitly defined by Evolu.
 *
 * - `createdAt`: Set by Evolu on row creation, derived from {@link Timestamp}.
 * - `updatedAt`: Set by Evolu on every row change, derived from {@link Timestamp}.
 * - `isDeleted`: Soft delete flag created by Evolu and used by the developer to
 *   mark rows as deleted.
 * - `ownerId`: Represents ownership and logically partitions the database.
 */
export declare const SystemColumns: ObjectType<{
    createdAt: import("../Type.js").BrandType<Type<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError>, "DateIso", import("../Type.js").DateIsoError, import("../Type.js").StringError>;
    updatedAt: import("../Type.js").BrandType<Type<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError>, "DateIso", import("../Type.js").DateIsoError, import("../Type.js").StringError>;
    isDeleted: import("../Type.js").UnionType<[Type<"Null", null, null, import("../Type.js").NullError, null, import("../Type.js").NullError>, import("../Type.js").UnionType<[import("../Type.js").LiteralType<0>, import("../Type.js").LiteralType<1>]>]>;
    ownerId: import("../Type.js").BrandType<import("../Type.js").BrandType<Type<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError>, "Id", import("../Type.js").IdError, import("../Type.js").StringError>, "OwnerId", import("../Type.js").BrandWithoutRefineError<"OwnerId", import("../Type.js").StringError | import("../Type.js").IdError>, never>;
}>;
export type SystemColumns = typeof SystemColumns.Type;
export declare const systemColumns: ReadonlySet<string>;
export declare const systemColumnsWithId: readonly string[];
export type MutationKind = "insert" | "update" | "upsert";
export type Mutation<S extends EvoluSchema, Kind extends MutationKind> = <TableName extends keyof S>(table: TableName, props: InferInput<ObjectType<MutationMapping<S[TableName], Kind>>>, options?: MutationOptions) => Result<{
    readonly id: S[TableName]["id"]["Type"];
}, ValidMutationSizeError | MergeObjectTypeErrors<ObjectType<MutationMapping<S[TableName], Kind>>>>;
export type MutationMapping<P extends Record<string, AnyType>, M extends MutationKind> = M extends "insert" ? InsertableProps<P> : M extends "update" ? UpdateableProps<P> : UpsertableProps<P>;
export interface MutationOptions {
    /**
     * Called after the mutation is completed and the local state is updated.
     * Useful for triggering side effects (e.g., notifications, UI updates) after
     * insert, update, or upsert.
     */
    readonly onComplete?: () => void;
    /**
     * Specifies the owner ID for this mutation. If omitted, the default
     * {@link AppOwner} is used.
     *
     * The owner must be used with `evolu.useOwner()` to enable sync. Mutations
     * with unused owners are stored locally but not synced until the owner is
     * used.
     *
     * ### Example
     *
     * ```ts
     * // Partition your own data by project (derived from your AppOwner)
     * const projectOwner = deriveShardOwner(appOwner, [
     *   "project",
     *   projectId,
     * ]);
     * evolu.insert(
     *   "task",
     *   { title: "Task 1" },
     *   { ownerId: projectOwner.id },
     * );
     *
     * // Collaborative data (independent owner shared with others)
     * const sharedOwner = createSharedOwner(sharedSecret);
     * evolu.insert(
     *   "comment",
     *   { text: "Hello" },
     *   { ownerId: sharedOwner.id },
     * );
     * ```
     *
     * @experimental
     */
    readonly ownerId?: OwnerId;
    /**
     * Only validate, don't mutate.
     *
     * For example, `onChange` handler can call `insert`/`update`/`upsert` with
     * `onlyValidate: true`.
     */
    readonly onlyValidate?: boolean;
}
export interface MutationChange extends DbChange {
    /** Owner of the change. If undefined, the change belongs to the AppOwner. */
    readonly ownerId?: OwnerId | undefined;
}
/**
 * Type Factory to create insertable {@link Type}. It makes nullable Types
 * optional (so they are not required), omits Id, and ensures the
 * {@link maxMutationSize}.
 *
 * ### Example
 *
 * ```ts
 * const InsertableTodo = insertable(Schema.todo);
 * type InsertableTodo = typeof InsertableTodo.Type;
 * const todo = InsertableTodo.from({ title });
 * if (!todo.ok) return; // handle errors
 * ```
 */
export declare const insertable: <Props extends Record<string, AnyType>>(props: Props) => ValidMutationSize<InsertableProps<Props>>;
export type InsertableProps<Props extends Record<string, AnyType>> = Omit<NullableToOptionalProps<Props>, "id">;
export type Insertable<Props extends Record<string, AnyType>> = InferInput<ObjectType<InsertableProps<Props>>>;
/**
 * Type Factory to create updateable {@link Type}. It makes everything except for
 * the `id` column optional (so they are not required) and ensures the
 * {@link maxMutationSize}.
 *
 * ### Example
 *
 * ```ts
 * const UpdateableTodo = updateable(Schema.todo);
 * type UpdateableTodo = typeof UpdateableTodo.Type;
 *
 * // `id` is required; all other fields are optional.
 * const todoResult = UpdateableTodo.from({
 *   id: "123",
 *   title: "New Title",
 * });
 * if (!todo.ok) return; // handle errors
 * ```
 */
export declare const updateable: <Props extends Record<string, AnyType>>(props: Props) => ValidMutationSize<UpdateableProps<Props>>;
export type UpdateableProps<Props extends Record<string, AnyType>> = {
    [K in keyof Props]: K extends "id" ? Props[K] : OptionalType<Props[K]>;
} & {
    isDeleted: OptionalType<typeof SqliteBoolean>;
};
export type Updateable<Props extends Record<string, AnyType>> = InferInput<ObjectType<UpdateableProps<Props>>>;
/**
 * Type Factory to create an upsertable Type. It makes nullable Types optional
 * (so they are not required) and ensures the {@link maxMutationSize}.
 *
 * Upsert is like insert, except it requires an ID. It's useful for inserting
 * rows with external ID via {@link createIdFromString}.
 *
 * Note that it's not possible to upsert a row with `createdAt` nor `updatedAt`,
 * because they are derived from {@link CrdtMessage} timestamp. For external
 * createdAt, use a different column.
 *
 * ### Example
 *
 * ```ts
 * const UpsertableTodo = upsertable(Schema.todo);
 * type UpsertableTodo = typeof UpsertableTodo.Type;
 * const todo = UpsertableTodo.from({
 *   id,
 *   title,
 * });
 * if (!todo.ok) return; // handle errors
 * ```
 */
export declare const upsertable: <Props extends Record<string, AnyType>>(props: Props) => ValidMutationSize<UpsertableProps<Props>>;
export type UpsertableProps<Props extends Record<string, AnyType>> = NullableToOptionalProps<Props & {
    isDeleted: OptionalType<typeof SqliteBoolean>;
}>;
export type Upsertable<Props extends Record<string, AnyType>> = InferInput<ObjectType<UpsertableProps<Props>>>;
export type InferEvoluSchemaError<S extends EvoluSchema> = {
    [Table in keyof S]: InferMutationTypeErrors<S[Table]>;
}[keyof S];
export type InferMutationTypeErrors<T extends Record<string, AnyType>> = InferColumnErrors<T, "insert"> | InferColumnErrors<T, "update"> | InferColumnErrors<T, "upsert">;
export type InferColumnErrors<T extends Record<string, AnyType>, M extends MutationKind> = {
    [Column in keyof MutationMapping<T, M>]: InferErrors<MutationMapping<T, M>[Column]>;
}[keyof MutationMapping<T, M>];
export declare const DbIndex: ObjectType<{
    name: Type<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError>;
    sql: Type<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError>;
}>;
export type DbIndex = typeof DbIndex.Type;
export declare const DbSchema: ObjectType<{
    tables: import("../Type.js").RecordType<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError, import("../Type.js").SetType<Type<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError>>>;
    indexes: import("../Type.js").ArrayType<ObjectType<{
        name: Type<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError>;
        sql: Type<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError>;
    }>>;
}>;
export type DbSchema = typeof DbSchema.Type;
export interface DbSchemaDep {
    readonly dbSchema: DbSchema;
}
/** Get the current database schema by reading SQLite metadata. */
export declare const getDbSchema: (deps: SqliteDep) => ({ allIndexes }?: {
    allIndexes?: boolean;
}) => Result<DbSchema, SqliteError>;
export declare const ensureDbSchema: (deps: SqliteDep) => (newSchema: DbSchema, currentSchema?: DbSchema) => Result<void, SqliteError>;
export declare const kysely: Kysely.Kysely<unknown>;
//# sourceMappingURL=Schema.d.ts.map
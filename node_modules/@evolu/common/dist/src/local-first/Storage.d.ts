import { NonEmptyReadonlyArray } from "../Array.js";
import { Brand } from "../Brand.js";
import { RandomDep } from "../Random.js";
import { Result } from "../Result.js";
import { SqliteDep, SqliteError } from "../Sqlite.js";
import { MaybeAsync } from "../Task.js";
import { NonNegativeInt, PositiveInt, TypeError } from "../Type.js";
import { OwnerError, OwnerId, OwnerIdBytes, OwnerWriteKey } from "./Owner.js";
import { Timestamp, TimestampBytes } from "./Timestamp.js";
export interface StorageConfig {
    /**
     * Callback called before an attempt to write, to check if an {@link OwnerId}
     * has sufficient quota for the write.
     *
     * The callback receives the {@link OwnerId} and the total bytes that would be
     * stored after the write (current stored bytes plus incoming bytes), and
     * returns a {@link MaybeAsync} boolean: `true` to allow the write, or `false`
     * to deny it due to quota limits.
     *
     * The callback can be synchronous (for SQLite or in-memory checks) or
     * asynchronous (for calling remote APIs).
     *
     * The callback returns a boolean rather than an error because error handling
     * and logging are the responsibility of the callback implementation.
     *
     * ### Example
     *
     * ```ts
     * // Client
     * // evolu.subscribeError
     *
     * // Relay
     * isOwnerWithinQuota: (ownerId, requiredBytes) => {
     *   console.log(ownerId, requiredBytes);
     *   // Check error via evolu.subscribeError
     *   return true;
     * };
     * ```
     */
    readonly isOwnerWithinQuota: (ownerId: OwnerId, requiredBytes: PositiveInt) => MaybeAsync<boolean>;
}
/**
 * Evolu Storage
 *
 * Evolu protocol using Storage is agnostic to storage implementation
 * detailsâ€”any storage can be plugged in, as long as it implements this
 * interface. Implementations must handle their own errors; return values only
 * indicate overall success or failure.
 *
 * The Storage API is synchronous because SQLite's synchronous API is the
 * fastest way to use SQLite. Synchronous bindings (like better-sqlite3) call
 * SQLite's C API directly with no context switching between the event loop and
 * native code, and no promise microtasks or await overhead.
 *
 * The only exception is {@link Storage#writeMessages}, which is async to allow
 * for async validation logic before writing to storage. The write operation
 * itself remains synchronous.
 */
export interface Storage {
    readonly getSize: (ownerId: OwnerIdBytes) => NonNegativeInt | null;
    readonly fingerprint: (ownerId: OwnerIdBytes, begin: NonNegativeInt, end: NonNegativeInt) => Fingerprint | null;
    /**
     * Computes fingerprints with their upper bounds in one call.
     *
     * This function can be replaced with many fingerprint/findLowerBound calls,
     * but implementations can leverage it for batching and more efficient
     * fingerprint computation.
     */
    readonly fingerprintRanges: (ownerId: OwnerIdBytes, buckets: ReadonlyArray<NonNegativeInt>, upperBound?: RangeUpperBound) => ReadonlyArray<FingerprintRange> | null;
    readonly findLowerBound: (ownerId: OwnerIdBytes, begin: NonNegativeInt, end: NonNegativeInt, upperBound: RangeUpperBound) => NonNegativeInt | null;
    readonly iterate: (ownerId: OwnerIdBytes, begin: NonNegativeInt, end: NonNegativeInt, callback: (timestamp: TimestampBytes, index: NonNegativeInt) => boolean) => void;
    /**
     * Validates the {@link OwnerWriteKey} for the given {@link Owner}.
     *
     * Returns `true` if the write key is valid, `false` otherwise.
     */
    readonly validateWriteKey: (ownerId: OwnerIdBytes, writeKey: OwnerWriteKey) => boolean;
    /** Sets the {@link OwnerWriteKey} for the given {@link Owner}. */
    readonly setWriteKey: (ownerId: OwnerIdBytes, writeKey: OwnerWriteKey) => boolean;
    /**
     * Write encrypted {@link CrdtMessage}s to storage.
     *
     * Must use a mutex per ownerId to ensure sequential processing and proper
     * protocol logic handling during sync operations.
     *
     * TODO: Use MaybeAsync
     */
    readonly writeMessages: (ownerIdBytes: OwnerIdBytes, messages: NonEmptyReadonlyArray<EncryptedCrdtMessage>) => MaybeAsync<Result<void, StorageWriteError | StorageQuotaError>>;
    /** Read encrypted {@link DbChange}s from storage. */
    readonly readDbChange: (ownerId: OwnerIdBytes, timestamp: TimestampBytes) => EncryptedDbChange | null;
    /**
     * Delete all data for the given {@link Owner}.
     *
     * Returns `true` on success, `false` on failure.
     */
    readonly deleteOwner: (ownerId: OwnerIdBytes) => boolean;
}
export interface StorageDep {
    readonly storage: Storage;
}
/** Error indicating a serious write failure. */
export interface StorageWriteError extends OwnerError {
    readonly type: "StorageWriteError";
}
/** Error when storage or billing quota is exceeded. */
export interface StorageQuotaError extends OwnerError {
    readonly type: "StorageQuotaError";
}
/**
 * A cryptographic hash used for efficiently comparing collections of
 * {@link TimestampBytes}s.
 *
 * It consists of the first {@link fingerprintSize} bytes of the SHA-256 hash of
 * one or more timestamps.
 */
export type Fingerprint = Uint8Array & Brand<"Fingerprint">;
export declare const fingerprintSize: number & Brand<"Int"> & Brand<"NonNegative">;
/** A fingerprint of an empty range. */
export declare const zeroFingerprint: Fingerprint;
export interface BaseRange {
    readonly upperBound: RangeUpperBound;
}
/**
 * Union type for Range's upperBound: either a {@link TimestampBytes} or
 * {@link InfiniteUpperBound}.
 */
export type RangeUpperBound = TimestampBytes | InfiniteUpperBound;
export declare const InfiniteUpperBound: unique symbol;
export type InfiniteUpperBound = typeof InfiniteUpperBound;
export declare const RangeType: {
    readonly Fingerprint: 1;
    readonly Skip: 0;
    readonly Timestamps: 2;
};
export type RangeType = (typeof RangeType)[keyof typeof RangeType];
export interface SkipRange extends BaseRange {
    readonly type: typeof RangeType.Skip;
}
export interface FingerprintRange extends BaseRange {
    readonly type: typeof RangeType.Fingerprint;
    readonly fingerprint: Fingerprint;
}
export interface TimestampsRange extends BaseRange {
    readonly type: typeof RangeType.Timestamps;
    readonly timestamps: ReadonlyArray<TimestampBytes>;
}
export type Range = SkipRange | FingerprintRange | TimestampsRange;
/** An encrypted {@link CrdtMessage}. */
export interface EncryptedCrdtMessage {
    readonly timestamp: Timestamp;
    readonly change: EncryptedDbChange;
}
/** Encrypted DbChange */
export type EncryptedDbChange = Uint8Array & Brand<"EncryptedDbChange">;
/**
 * A CRDT message combining a unique {@link Timestamp} with a {@link DbChange}.
 *
 * Used in Evolu's sync protocol to replicate data changes across devices. Evolu
 * operates as a durable queue, providing exactly-once delivery guarantees for
 * reliable synchronization across application restarts and network failures.
 */
export interface CrdtMessage {
    readonly timestamp: Timestamp;
    readonly change: DbChange;
}
export declare const DbChangeValues: import("../Type.js").RecordType<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError, import("../Type.js").UnionType<[import("../Type.js").Type<"Null", null, null, import("../Type.js").NullError, null, import("../Type.js").NullError>, import("../Type.js").Type<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError>, import("../Type.js").Type<"Number", number, number, import("../Type.js").NumberError, number, import("../Type.js").NumberError>, import("../Type.js").Type<"Uint8Array", Uint8Array<ArrayBufferLike>, Uint8Array<ArrayBufferLike>, import("../Type.js").Uint8ArrayError, Uint8Array<ArrayBufferLike>, import("../Type.js").Uint8ArrayError>]>>;
export type DbChangeValues = typeof DbChangeValues.Type;
export declare const ValidDbChangeValues: import("../Type.js").BrandType<import("../Type.js").RecordType<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError, import("../Type.js").UnionType<[import("../Type.js").Type<"Null", null, null, import("../Type.js").NullError, null, import("../Type.js").NullError>, import("../Type.js").Type<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError>, import("../Type.js").Type<"Number", number, number, import("../Type.js").NumberError, number, import("../Type.js").NumberError>, import("../Type.js").Type<"Uint8Array", Uint8Array<ArrayBufferLike>, Uint8Array<ArrayBufferLike>, import("../Type.js").Uint8ArrayError, Uint8Array<ArrayBufferLike>, import("../Type.js").Uint8ArrayError>]>>, "ValidDbChangeValues", ValidDbChangeValuesError, import("../Type.js").RecordError<import("../Type.js").StringError, never> | import("../Type.js").RecordError<import("../Type.js").StringError, import("../Type.js").UnionError<import("../Type.js").StringError | import("../Type.js").NumberError | import("../Type.js").Uint8ArrayError | import("../Type.js").NullError>>>;
export type ValidDbChangeValues = typeof ValidDbChangeValues.Type;
export interface ValidDbChangeValuesError extends TypeError<"ValidDbChangeValues"> {
    readonly invalidColumns: ReadonlyArray<string>;
}
/**
 * A DbChange is a change to a table row. Together with a unique
 * {@link Timestamp}, it forms a {@link CrdtMessage}.
 */
export declare const DbChange: import("../Type.js").ObjectType<{
    table: import("../Type.js").Type<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError>;
    id: import("../Type.js").BrandType<import("../Type.js").Type<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError>, "Id", import("../Type.js").IdError, import("../Type.js").StringError>;
    values: import("../Type.js").BrandType<import("../Type.js").RecordType<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError, import("../Type.js").UnionType<[import("../Type.js").Type<"Null", null, null, import("../Type.js").NullError, null, import("../Type.js").NullError>, import("../Type.js").Type<"String", string, string, import("../Type.js").StringError, string, import("../Type.js").StringError>, import("../Type.js").Type<"Number", number, number, import("../Type.js").NumberError, number, import("../Type.js").NumberError>, import("../Type.js").Type<"Uint8Array", Uint8Array<ArrayBufferLike>, Uint8Array<ArrayBufferLike>, import("../Type.js").Uint8ArrayError, Uint8Array<ArrayBufferLike>, import("../Type.js").Uint8ArrayError>]>>, "ValidDbChangeValues", ValidDbChangeValuesError, import("../Type.js").RecordError<import("../Type.js").StringError, never> | import("../Type.js").RecordError<import("../Type.js").StringError, import("../Type.js").UnionError<import("../Type.js").StringError | import("../Type.js").NumberError | import("../Type.js").Uint8ArrayError | import("../Type.js").NullError>>>;
    isInsert: import("../Type.js").Type<"Boolean", boolean, boolean, import("../Type.js").BooleanError, boolean, import("../Type.js").BooleanError>;
    isDelete: import("../Type.js").UnionType<[import("../Type.js").Type<"Null", null, null, import("../Type.js").NullError, null, import("../Type.js").NullError>, import("../Type.js").Type<"Boolean", boolean, boolean, import("../Type.js").BooleanError, boolean, import("../Type.js").BooleanError>]>;
}>;
export type DbChange = typeof DbChange.Type;
/**
 * Common interface for both client and relay SQLite storages.
 *
 * Evolu uses a Skiplist, which leverages SQLite indexes. The core logic is
 * implemented in SQL, so it doesn't have to make roundtrips to the DB.
 *
 * While the SQL implementation may look sophisticated, it's conceptually simple
 * and LLMs can explain how it works. The Skiplist data structure is well
 * explained in [this Stack Overflow
 * answer](https://stackoverflow.com/questions/61944198/what-is-a-zip-tree-and-how-does-it-work).
 * The logic resembles [Negentropy's C++
 * storage](https://github.com/hoytech/negentropy), except we use a Skiplist to
 * leverage SQLite indexes, which makes the code simpler.
 *
 * Note: A paid review by the SQLite team is planned, as they use the same
 * algorithm for their rsync tool.
 *
 * The ideal storage for a Relay should use an architecture like
 * [strfry](https://github.com/hoytech/strfry) (a KV storage), but with Skiplist
 * to ensure that insertion order doesn't matter (local-first apps can often
 * write in the past.)
 *
 * The ideal client implementation should probably use the SQLite extension
 * instead of SQL or even a KV storage, when such a thing for browsers/native
 * will exist and will be faster than SQLite.
 *
 * # Scaling
 *
 * The load can be distributed by deploying multiple relays, synchronized with
 * each other, if necessary. One relay should handle hundreds of thousands of
 * users, and when it goes down, nothing happens, because it will be
 * synchronized later.
 */
export interface BaseSqliteStorage extends Pick<Storage, "getSize" | "fingerprint" | "fingerprintRanges" | "findLowerBound" | "iterate" | "deleteOwner"> {
    /** Inserts a timestamp for an owner into the skiplist-based storage. */
    readonly insertTimestamp: (ownerId: OwnerIdBytes, timestamp: TimestampBytes, strategy: StorageInsertTimestampStrategy) => Result<void, SqliteError>;
    /**
     * Efficiently checks which timestamps already exist in the database using a
     * single CTE query instead of N individual queries.
     */
    readonly getExistingTimestamps: (ownerIdBytes: OwnerIdBytes, timestampsBytes: NonEmptyReadonlyArray<TimestampBytes>) => Result<ReadonlyArray<TimestampBytes>, SqliteError>;
}
export interface BaseSqliteStorageDep {
    readonly storage: BaseSqliteStorage;
}
export type SqliteStorageDeps = RandomDep & SqliteDep;
export interface CreateBaseSqliteStorageConfig extends StorageConfig {
    onStorageError: (error: SqliteError) => void;
}
/**
 * Creates a {@link BaseSqliteStorage} implementation.
 *
 * # Stateless Design
 *
 * This implementation is fully stateless - it requires no in-memory state
 * between invocations. All necessary metadata (timestamp bounds for insertion
 * strategy optimization) is persisted in the evolu_usage table. This makes
 * Evolu Relay suitable for stateless serverless environments like AWS Lambda,
 * Cloudflare Workers with Durable Objects, and other platforms where memory
 * doesn't persist between requests. While not extensively tested in all these
 * environments yet, the stateless design should work well across them.
 */
export declare const createBaseSqliteStorage: (deps: SqliteStorageDeps) => (config: CreateBaseSqliteStorageConfig) => BaseSqliteStorage;
export declare const createBaseSqliteStorageTables: (deps: SqliteDep) => Result<void, SqliteError>;
export type StorageInsertTimestampStrategy = "append" | "prepend" | "insert";
/**
 * Determines the insertion strategy for a timestamp based on its position
 * relative to the current first and last timestamps.
 *
 * Returns a tuple with the strategy and updated timestamp bounds.
 */
export declare const getTimestampInsertStrategy: (timestamp: TimestampBytes, firstTimestamp: TimestampBytes, lastTimestamp: TimestampBytes) => [strategy: StorageInsertTimestampStrategy, firstTimestamp: TimestampBytes, lastTimestamp: TimestampBytes];
export declare const timestampBytesToFingerprint: (timestamp: TimestampBytes) => Fingerprint;
export declare const getTimestampByIndex: (deps: SqliteDep) => (ownerId: OwnerIdBytes, index: NonNegativeInt) => Result<TimestampBytes, SqliteError>;
/** Retrieves usage information for an owner from the evolu_usage table. */
export declare const getOwnerUsage: (deps: SqliteDep) => (ownerIdBytes: OwnerIdBytes, initialTimestamp: TimestampBytes) => Result<{
    storedBytes: NonNegativeInt | null;
    firstTimestamp: TimestampBytes;
    lastTimestamp: TimestampBytes;
}, SqliteError>;
/**
 * Updates timestamp bounds in evolu_usage table.
 *
 * Used by both relay and client to maintain firstTimestamp/lastTimestamp after
 * processing messages.
 */
export declare const updateOwnerUsage: (deps: SqliteDep) => (ownerIdBytes: OwnerIdBytes, storedBytes: PositiveInt, firstTimestamp: TimestampBytes, lastTimestamp: TimestampBytes) => Result<void, SqliteError>;
//# sourceMappingURL=Storage.d.ts.map
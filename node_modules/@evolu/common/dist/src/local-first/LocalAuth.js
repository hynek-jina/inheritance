import { createAppOwner, createOwnerSecret, mnemonicToOwnerSecret, OwnerEncryptionKey, OwnerWriteKey, } from "./Owner.js";
/**
 * Creates a local auth using the given secure storage implementation. This
 * factory function allows each platform to provide its own storage layer while
 * sharing the common auth logic.
 */
export const createLocalAuth = (deps) => {
    const setLastOwnerId = async (id, options) => {
        await deps.secureStorage.setItem(localAuthMetakeyLastOwner, id, {
            ...buildAuthOptions(options),
            accessControl: "none",
        });
    };
    const getLastOwnerId = async (options) => {
        const item = await deps.secureStorage.getItem(localAuthMetakeyLastOwner, {
            ...buildAuthOptions(options),
            accessControl: "none",
        });
        return item?.value;
    };
    const getOwnerNames = async (options) => {
        const item = await deps.secureStorage.getItem(localAuthMetakeyOwnerNames, {
            ...buildAuthOptions(options),
            accessControl: "none",
        });
        let names = {};
        if (item?.value) {
            names = JSON.parse(item.value);
        }
        return names;
    };
    const setOwnerName = async (id, username, options) => {
        const names = await getOwnerNames(options);
        names[id] = username;
        await deps.secureStorage.setItem(localAuthMetakeyOwnerNames, JSON.stringify(names), {
            ...buildAuthOptions(options),
            accessControl: "none",
        });
    };
    const deleteOwnerName = async (id, options) => {
        const { [id]: _, ...names } = await getOwnerNames(options);
        await deps.secureStorage.setItem(localAuthMetakeyOwnerNames, JSON.stringify(names), {
            ...buildAuthOptions(options),
            accessControl: "none",
        });
    };
    const getOwnerIds = async (options) => {
        const items = await deps.secureStorage.getAllItems({
            ...buildAuthOptions(options),
            includeValues: false,
        });
        return items
            .filter(Boolean)
            .filter((i) => i.key !== localAuthMetakeyLastOwner &&
            i.key !== localAuthMetakeyOwnerNames)
            .map((i) => i.key);
    };
    const clearAuthStore = (options) => deps.secureStorage.clearService(buildAuthOptions(options));
    const buildAuthOptions = (options, username) => {
        const newOptions = {
            ...localAuthDefaultOptions,
            ...(username && { webAuthnUsername: username }),
            ...options,
        };
        return {
            ...newOptions,
            authenticationPrompt: {
                title: replaceMessageTokens(newOptions.authenticationPrompt?.title ?? "", username),
                cancel: replaceMessageTokens(newOptions.authenticationPrompt?.cancel ?? "", username),
                subtitle: replaceMessageTokens(newOptions.authenticationPrompt?.subtitle ?? "", username),
                description: replaceMessageTokens(newOptions.authenticationPrompt?.description ?? "", username),
            },
        };
    };
    const replaceMessageTokens = (text, username) => {
        if (!username)
            return text;
        return text.replace("|USERNAME|", username);
    };
    return {
        login: async (ownerId, options) => {
            // Lookup the associated username
            const names = await getOwnerNames(options);
            const username = names[ownerId] ?? "";
            // Currently a reload is needed. This avoids authentication
            // it needs to be handled on next page load.
            // We set the last owner so we know what the target is.
            // It is the applications's responsibility to reload and trigger login.
            await setLastOwnerId(ownerId, options);
            return { owner: undefined, username };
        },
        register: async (username, options) => {
            // Create an owner with a new secret or use specified mnemonic
            const owner = createAppOwner(options?.mnemonic
                ? mnemonicToOwnerSecret(options.mnemonic)
                : createOwnerSecret(deps));
            // Store owner, associated username, and update last owner
            await Promise.all([
                // setOwnerItem
                deps.secureStorage.setItem(owner.id, JSON.stringify({ owner }), buildAuthOptions(options, username)),
                setOwnerName(owner.id, username, options),
                setLastOwnerId(owner.id, options),
            ]);
            // Return the owner and associated username
            return { owner, username };
        },
        unregister: async (ownerId, options) => {
            // Delete the owner and associated username
            await Promise.all([
                // deleteOwnerItem
                deps.secureStorage.deleteItem(ownerId, buildAuthOptions(options)),
                deleteOwnerName(ownerId, options),
            ]);
            // If the owner was the last owner then set to
            // the next owner based on metadata timestamp
            const lastOwnerId = await getLastOwnerId(options);
            if (lastOwnerId === ownerId) {
                const ids = await getOwnerIds(options);
                if (ids.length > 0) {
                    await setLastOwnerId(ids[0], options);
                }
            }
        },
        getOwner: async (options) => {
            const ownerId = await getLastOwnerId(options);
            if (!ownerId)
                return null;
            const names = await getOwnerNames(options);
            const username = names[ownerId] ?? "";
            // Retrieve and decrypt the owner (this will trigger device authentication)
            const account = await deps.secureStorage.getItem(ownerId, buildAuthOptions(options, username));
            if (!account?.value)
                return null;
            // Unserialize the values (TODO: save these as base64 instead of json serializing)
            const result = JSON.parse(account.value);
            const writeKey = OwnerWriteKey.orThrow(new Uint8Array(Object.values(result.owner.writeKey)));
            const encryptionKey = OwnerEncryptionKey.orThrow(new Uint8Array(Object.values(result.owner.encryptionKey)));
            const owner = { ...result.owner, writeKey, encryptionKey };
            // Update the last owner for future login attempts
            await setLastOwnerId(ownerId, options);
            // Return the owner and associated username
            return { owner, username };
        },
        getProfiles: async (options) => {
            // Get all owner ids and associated usernames
            const [ids, names] = await Promise.all([
                getOwnerIds(options),
                getOwnerNames(options),
            ]);
            // Return the list of profiles (usually used for login UX)
            return ids.map((ownerId) => ({
                ownerId,
                username: names[ownerId] ?? "",
            }));
        },
        clearAll: async (options) => {
            // Delete all owners and associated metadata (scoped to the service)
            await clearAuthStore(options);
        },
    };
};
export const localAuth_Namespace = "evolu";
export const localAuthDefaultOptions = {
    service: localAuth_Namespace,
    keychainGroup: localAuth_Namespace,
    androidBiometricsStrongOnly: true,
    iosSynchronizable: true,
    webAuthnUsername: "Evolu User",
    authenticationPrompt: {
        title: "Authenticate as |USERNAME|",
    },
};
const localAuthMetakeyLastOwner = "_last_owner";
const localAuthMetakeyOwnerNames = "_owner_names";

import { Brand } from "./Brand.js";
import { ConsoleDep } from "./Console.js";
import { EncryptionKey } from "./Crypto.js";
import { Eq } from "./Eq.js";
import { TransferableError } from "./Error.js";
import { Result } from "./Result.js";
import { SimpleName } from "./Type.js";
import { Predicate } from "./Types.js";
/**
 * SQLite driver interface. This is the minimal interface that platform-specific
 * drivers must implement.
 */
export interface SqliteDriver extends Disposable {
    readonly exec: (query: SqliteQuery, isMutation: boolean) => SqliteExecResult;
    readonly export: () => Uint8Array;
}
export type CreateSqliteDriver = (name: SimpleName, options?: SqliteDriverOptions) => Promise<SqliteDriver>;
export interface CreateSqliteDriverDep {
    readonly createSqliteDriver: CreateSqliteDriver;
}
export interface SqliteDriverOptions {
    readonly memory?: boolean;
    readonly encryptionKey?: EncryptionKey | undefined;
}
/**
 * Cross-platform SQLite abstraction.
 *
 * This API is sync only because SQLite is an embedded, single-threaded engine.
 * All operations are blocking and in-process, so async APIs add needless
 * complexity without any real benefit and are also slower. Check better-sqlite3
 * GitHub issues and docs for details.
 */
export interface Sqlite extends Disposable {
    readonly exec: <R extends SqliteRow = SqliteRow>(query: SqliteQuery) => Result<SqliteExecResult<R>, SqliteError>;
    /**
     * Executes a transaction, running the provided callback within a begin/commit
     * block. If the callback returns an error (E or {@link SqliteError}), the
     * transaction is rolled back. If the rollback fails, a SqliteError is
     * returned with both the original error and rollbackError.
     */
    readonly transaction: <T, E>(callback: () => Result<T, E | SqliteError>) => Result<T, E | SqliteError>;
    readonly export: () => Result<Uint8Array, SqliteError>;
}
export interface SqliteDep {
    readonly sqlite: Sqlite;
}
export interface SqliteQuery {
    readonly sql: SafeSql;
    readonly parameters: Array<SqliteValue>;
    readonly options?: SqliteQueryOptions;
}
/** A type representing a sanitized SQL string. */
export type SafeSql = string & Brand<"SafeSql">;
/**
 * A value that can be stored in Sqlite.
 *
 * Note that Evolu can't support Int64 because expo-sqlite (and some others) do
 * not support it.
 */
export declare const SqliteValue: import("./Type.js").UnionType<[import("./Type.js").Type<"Null", null, null, import("./Type.js").NullError, null, import("./Type.js").NullError>, import("./Type.js").Type<"String", string, string, import("./Type.js").StringError, string, import("./Type.js").StringError>, import("./Type.js").Type<"Number", number, number, import("./Type.js").NumberError, number, import("./Type.js").NumberError>, import("./Type.js").Type<"Uint8Array", Uint8Array<ArrayBufferLike>, Uint8Array<ArrayBufferLike>, import("./Type.js").Uint8ArrayError, Uint8Array<ArrayBufferLike>, import("./Type.js").Uint8ArrayError>]>;
export type SqliteValue = typeof SqliteValue.Type;
export declare const eqSqliteValue: Eq<SqliteValue>;
export interface SqliteQueryOptions {
    /**
     * If set to `true`, logs the time taken to execute the SQL query. Useful for
     * performance monitoring and identifying slow queries.
     */
    readonly logQueryExecutionTime?: boolean;
    /**
     * If set to `true`, logs the SQLite Explain Query Plan (EQP) for the query.
     * This can help analyze how SQLite plans to execute the query and identify
     * potential optimizations.
     *
     * See: {@link https://www.sqlite.org/eqp.html}.
     */
    readonly logExplainQueryPlan?: boolean;
    /**
     * If set to `true`, explicitly prepares the query before execution. Prepared
     * statements can improve performance for repeated queries by reusing the
     * compiled query.
     *
     * See: {@link https://sqlite.org/wasm/doc/trunk/api-oo1.md#db-prepare}.
     */
    readonly prepare?: boolean;
}
/** Result of executing a SQLite query. */
export interface SqliteExecResult<R extends SqliteRow = SqliteRow> {
    readonly rows: ReadonlyArray<R>;
    readonly changes: number;
}
/** Represents an error that occurred during a SQLite operation. */
export interface SqliteError {
    readonly type: "SqliteError";
    readonly error: TransferableError;
    readonly rollbackError?: TransferableError;
}
export type SqliteRow = Record<string, SqliteValue>;
/**
 * Creates a fully featured {@link Sqlite} instance from a {@link SqliteDriver}
 * implementation.
 */
export declare const createSqlite: (deps: CreateSqliteDriverDep & Partial<ConsoleDep>) => (name: SimpleName, options?: SqliteDriverOptions) => Promise<Result<Sqlite, SqliteError>>;
export interface PreparedStatements<P> extends Disposable {
    readonly get: <T extends boolean>(query: SqliteQuery, alwaysPrepare?: T) => T extends true ? P : P | null;
}
export declare const createPreparedStatementsCache: <P>(factory: (sql: SafeSql) => P, disposeFn: (statement: P) => void) => PreparedStatements<P>;
export interface SqlIdentifier {
    readonly type: "SqlIdentifier";
    readonly sql: SafeSql;
}
export interface RawSql {
    readonly type: "RawSql";
    readonly sql: string;
}
export type SqlTemplateParam = SqliteValue | SqlIdentifier | RawSql;
/**
 * Creates a safe SQL query using a tagged template literal.
 *
 * Parameters are automatically escaped and bound as SQLite values. Use
 * `sql.identifier` for column/table names and `sql.raw` for unescaped SQL.
 *
 * ### Example
 *
 * ```ts
 * const id = 42;
 * const name = "Alice";
 *
 * const result = sqlite.exec(sql`
 *   select *
 *   from users
 *   where id = ${id} and name = ${name};
 * `);
 *
 * // For identifiers
 * const tableName = "users";
 * sqlite.exec(sql`
 *   create table ${sql.identifier(tableName)} (
 *     "id" text primary key,
 *     "name" text not null
 *   );
 * `);
 *
 * // For raw SQL (use with caution)
 * const orderBy = "created_at desc";
 * sqlite.exec(sql`select * from users order by ${sql.raw(orderBy)};`);
 * ```
 *
 * ### TIP
 *
 * Use `prettier-plugin-sql-cst` for SQL formatting. Like Prettier for
 * JavaScript, this plugin formats SQL expressions differently depending on
 * their length.
 */
export declare const sql: {
    (strings: TemplateStringsArray, ...parameters: Array<SqlTemplateParam>): SqliteQuery;
    identifier(identifier: string): SqlIdentifier;
    raw(raw: string): RawSql;
    prepared(strings: TemplateStringsArray, ...parameters: Array<SqlTemplateParam>): SqliteQuery;
};
/**
 * Checks if a SQL string contains mutation keywords (insert, update, delete,
 * etc.). Results are cached for performance.
 */
export declare const isSqlMutation: Predicate<string>;
export interface SqliteQueryPlanRow {
    id: number;
    parent: number;
    detail: string;
}
export declare const explainSqliteQueryPlan: (deps: SqliteDep) => (query: SqliteQuery) => Result<void, SqliteError>;
/**
 * SQLite represents boolean values using `0` (false) and `1` (true) instead of
 * a dedicated boolean type.
 *
 * See: https://www.sqlite.org/quirks.html#no_separate_boolean_datatype
 *
 * ### Tips
 *
 * - Use {@link sqliteTrue} and {@link sqliteFalse} constants for better
 *   readability.
 * - Use {@link booleanToSqliteBoolean} and {@link sqliteBooleanToBoolean} for
 *   converting between JavaScript booleans and SQLite boolean values.
 */
export declare const SqliteBoolean: import("./Type.js").UnionType<[import("./Type.js").LiteralType<0>, import("./Type.js").LiteralType<1>]>;
export type SqliteBoolean = typeof SqliteBoolean.Type;
/**
 * Represents the {@link SqliteBoolean} value for `true`.
 *
 * See {@link SqliteBoolean}.
 */
export declare const sqliteTrue = 1;
/**
 * Represents the {@link SqliteBoolean} value for `false`.
 *
 * See {@link SqliteBoolean}.
 */
export declare const sqliteFalse = 0;
/**
 * Converts a JavaScript boolean to a {@link SqliteBoolean}.
 *
 * ### Example
 *
 * ```ts
 * const isActive = true;
 * const sqlValue = booleanToSqliteBoolean(isActive); // Returns 1
 * ```
 */
export declare const booleanToSqliteBoolean: (value: boolean) => SqliteBoolean;
/**
 * Converts a {@link SqliteBoolean} to a JavaScript boolean.
 *
 * ### Example
 *
 * ```ts
 * const sqlValue: SqliteBoolean = 1;
 * const bool = sqliteBooleanToBoolean(sqlValue); // Returns true
 * ```
 */
export declare const sqliteBooleanToBoolean: (value: SqliteBoolean) => boolean;
//# sourceMappingURL=Sqlite.d.ts.map
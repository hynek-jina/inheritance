import { Result } from "./Result.js";
import { NonNegativeInt } from "./Type.js";
export interface RandomBytes {
    /**
     * Creates cryptographically secure random bytes with type-safe length
     * branding.
     *
     * Uses the operating system's cryptographically secure random number
     * generator (crypto.getRandomValues) to generate high-quality entropy
     * suitable for cryptographic operations.
     *
     * ### Type Safety
     *
     * Returns specific branded types for common sizes:
     *
     * - `Random16` for 16-byte values (128 bits)
     * - `Random32` for 32-byte values (256 bits)
     * - `Random64` for 64-byte values (512 bits)
     * - `Random` for any other size
     *
     * ### Example
     *
     * ```ts
     * const nonce = randomBytes.create(16); // Type: Random16
     * const key = randomBytes.create(32); // Type: Random32
     * const seed = randomBytes.create(64); // Type: Random64
     * const custom = randomBytes.create(48); // Type: Random
     * ```
     */
    create(bytesLength: 16): Entropy16;
    create(bytesLength: 32): Entropy32;
    create(bytesLength: 64): Entropy64;
    create(bytesLength: number): Entropy;
}
export interface RandomBytesDep {
    readonly randomBytes: RandomBytes;
}
declare const Entropy: import("./Type.js").BrandType<import("./Type.js").Type<"Uint8Array", Uint8Array<ArrayBufferLike>, Uint8Array<ArrayBufferLike>, import("./Type.js").Uint8ArrayError, Uint8Array<ArrayBufferLike>, import("./Type.js").Uint8ArrayError>, "Entropy", import("./Type.js").BrandWithoutRefineError<"Entropy", import("./Type.js").Uint8ArrayError>, never>;
type Entropy = typeof Entropy.Type;
export declare const Entropy16: import("./Type.js").BrandType<import("./Type.js").Type<"Brand", Uint8Array<ArrayBufferLike> & import("./Brand.js").Brand<"Entropy">, Uint8Array<ArrayBufferLike>, import("./Type.js").BrandWithoutRefineError<"Entropy", import("./Type.js").Uint8ArrayError>, Uint8Array<ArrayBufferLike>, never>, "Length16", import("./Type.js").LengthError<16>, import("./Type.js").BrandWithoutRefineError<"Entropy", import("./Type.js").Uint8ArrayError>>;
export type Entropy16 = typeof Entropy16.Type;
export declare const Entropy32: import("./Type.js").BrandType<import("./Type.js").Type<"Brand", Uint8Array<ArrayBufferLike> & import("./Brand.js").Brand<"Entropy">, Uint8Array<ArrayBufferLike>, import("./Type.js").BrandWithoutRefineError<"Entropy", import("./Type.js").Uint8ArrayError>, Uint8Array<ArrayBufferLike>, never>, "Length32", import("./Type.js").LengthError<32>, import("./Type.js").BrandWithoutRefineError<"Entropy", import("./Type.js").Uint8ArrayError>>;
export type Entropy32 = typeof Entropy32.Type;
export declare const Entropy64: import("./Type.js").BrandType<import("./Type.js").Type<"Brand", Uint8Array<ArrayBufferLike> & import("./Brand.js").Brand<"Entropy">, Uint8Array<ArrayBufferLike>, import("./Type.js").BrandWithoutRefineError<"Entropy", import("./Type.js").Uint8ArrayError>, Uint8Array<ArrayBufferLike>, never>, "Length64", import("./Type.js").LengthError<64>, import("./Type.js").BrandWithoutRefineError<"Entropy", import("./Type.js").Uint8ArrayError>>;
export type Entropy64 = typeof Entropy64.Type;
export declare const createRandomBytes: () => RandomBytes;
/**
 * SLIP21.
 *
 * https://github.com/satoshilabs/slips/blob/master/slip-0021.md
 */
export declare const createSlip21: (seed: Entropy16 | Entropy32 | Entropy64, path: ReadonlyArray<string | number>) => Entropy32;
/**
 * Derives a single node in the SLIP-21 hierarchical key derivation.
 *
 * @see {@link createSlip21}
 */
export declare const deriveSlip21Node: (label: string, parentNode: Entropy64) => Entropy64;
/** The encryption key for {@link SymmetricCrypto}. */
export declare const EncryptionKey: import("./Type.js").BrandType<import("./Type.js").BrandType<import("./Type.js").Type<"Brand", Uint8Array<ArrayBufferLike> & import("./Brand.js").Brand<"Entropy">, Uint8Array<ArrayBufferLike>, import("./Type.js").BrandWithoutRefineError<"Entropy", import("./Type.js").Uint8ArrayError>, Uint8Array<ArrayBufferLike>, never>, "Length32", import("./Type.js").LengthError<32>, import("./Type.js").BrandWithoutRefineError<"Entropy", import("./Type.js").Uint8ArrayError>>, "EncryptionKey", import("./Type.js").BrandWithoutRefineError<"EncryptionKey", import("./Type.js").BrandWithoutRefineError<"Entropy", import("./Type.js").Uint8ArrayError> | import("./Type.js").LengthError<32>>, never>;
export type EncryptionKey = typeof EncryptionKey.Type;
/** Symmetric cryptography. */
export interface SymmetricCrypto {
    readonly nonceLength: NonNegativeInt;
    readonly encrypt: (plaintext: Uint8Array, encryptionKey: EncryptionKey) => {
        readonly nonce: Uint8Array;
        readonly ciphertext: Uint8Array;
    };
    readonly decrypt: (ciphertext: Uint8Array, encryptionKey: EncryptionKey, nonce: Uint8Array) => Result<Uint8Array, SymmetricCryptoDecryptError>;
}
export interface SymmetricCryptoDep {
    readonly symmetricCrypto: SymmetricCrypto;
}
export interface SymmetricCryptoDecryptError {
    readonly type: "SymmetricCryptoDecryptError";
    readonly error: unknown;
}
/**
 * XChaCha20-Poly1305 encryption
 *
 * https://github.com/paulmillr/noble-ciphers?tab=readme-ov-file#which-cipher-should-i-pick
 */
export declare const createSymmetricCrypto: (deps: RandomBytesDep) => SymmetricCrypto;
/**
 * Returns the PADMÉ padded length for a given input length.
 *
 * PADMÉ limits information leakage about the length of the plain-text for a
 * wide range of encrypted data sizes.
 *
 * See the PURBs paper for details: https://bford.info/pub/sec/purb.pdf
 */
export declare const createPadmePaddedLength: (length: NonNegativeInt) => NonNegativeInt;
/** Creates a PADMÉ padding array of zeros for the given input length. */
export declare const createPadmePadding: (length: NonNegativeInt) => Uint8Array;
/**
 * Performs a timing-safe comparison of two Uint8Arrays. Returns true if they
 * are equal, false otherwise. Takes constant time regardless of where the
 * arrays differ.
 *
 * @see https://nodejs.org/api/crypto.html#cryptotimingsafeequala-b
 */
export type TimingSafeEqual = (a: Uint8Array, b: Uint8Array) => boolean;
export interface TimingSafeEqualDep {
    readonly timingSafeEqual: TimingSafeEqual;
}
export {};
//# sourceMappingURL=Crypto.d.ts.map
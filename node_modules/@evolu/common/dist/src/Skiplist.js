import { PositiveInt } from "./Type.js";
// TODO: Use in Storage.
export const createSkiplistLevel = (deps) => (config = {}) => {
    const { probability = 0.5, maxLevel = 32 } = config;
    return {
        create: () => {
            let level = 1;
            while (deps.random.next() <= probability && level < maxLevel) {
                level += 1;
            }
            return PositiveInt.orThrow(level);
        },
    };
};
export const createSkiplist = (deps) => {
    const tail = {
        key: Number.MAX_VALUE,
        pointers: [],
    };
    const head = {
        key: Number.MIN_VALUE,
        pointers: [tail],
    };
    // Cached to reuse the array.
    const path = [];
    return {
        insert: (key) => {
            let cur = head;
            for (let i = head.pointers.length - 1; i >= 0; i--) {
                while (cur.pointers[i].key < key) {
                    cur = cur.pointers[i];
                }
                path[i] = cur;
            }
            const level = deps.skiplistLevel.create();
            if (level > head.pointers.length) {
                const tails = Array(level - head.pointers.length).fill(tail);
                const heads = Array(level - head.pointers.length).fill(head);
                head.pointers.push(...tails);
                path.push(...heads);
            }
            const newNode = { key, pointers: [] };
            for (let i = 0; i < level; i++) {
                newNode.pointers[i] = path[i].pointers[i];
                path[i].pointers[i] = newNode;
            }
        },
        find: (key) => {
            let cur = head;
            for (let i = head.pointers.length - 1; i >= 0; i--) {
                while (cur.pointers[i] && cur.pointers[i].key < key) {
                    cur = cur.pointers[i];
                }
            }
            const candidate = cur.pointers[0];
            return candidate.key === key ? candidate : null;
        },
    };
};

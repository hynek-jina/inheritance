import { assert } from "./Assert.js";
/** Creates a {@link Redacted} wrapper for a sensitive value. */
export const createRedacted = (value) => {
    const redacted = Object.create(proto);
    registry.set(redacted, value);
    return redacted;
};
const proto = {
    toString: () => redactedString,
    toJSON: () => redactedString,
    [Symbol.for("nodejs.util.inspect.custom")]: () => redactedString,
    [Symbol.dispose]() {
        registry.delete(this);
    },
};
const redactedString = "<redacted>";
const registry = new WeakMap();
/**
 * Reveals the original value from a {@link Redacted} wrapper.
 *
 * This is a separate function rather than a method on {@link Redacted} to make
 * access visually explicit and easy to grep in code reviews. Accessing
 * sensitive values should feel intentional, not convenient.
 */
export const revealRedacted = (redacted) => {
    assert(registry.has(redacted), "Redacted value was not in registry");
    return registry.get(redacted);
};
/** Checks if a value is a {@link Redacted} wrapper. */
export const isRedacted = (value) => typeof value === "object" &&
    value !== null &&
    Object.getPrototypeOf(value) === proto;
/**
 * Creates an {@link Eq} for {@link Redacted} values based on an equality function
 * for the underlying type.
 *
 * ### Example
 *
 * ```ts
 * type ApiKey = string & Brand<"ApiKey">;
 * const eqRedactedApiKey = createEqRedacted<ApiKey>(eqString);
 *
 * const a = createRedacted("x" as ApiKey);
 * const b = createRedacted("x" as ApiKey);
 * eqRedactedApiKey(a, b); // true
 * ```
 */
export const createEqRedacted = (eq) => (x, y) => eq(revealRedacted(x), revealRedacted(y));

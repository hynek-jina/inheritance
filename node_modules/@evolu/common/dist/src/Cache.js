/**
 * Creates an LRU (least recently used) cache with a maximum capacity.
 *
 * When the cache reaches capacity, the least recently used entry is evicted.
 * Both `get` and `set` operations update the access order.
 *
 * ### Example
 *
 * ```ts
 * const cache = createLruCache<string, number>(2);
 * cache.set("a", 1);
 * cache.set("b", 2);
 * cache.set("c", 3); // Evicts "a"
 * cache.has("a"); // false
 * ```
 */
export const createLruCache = (capacity) => {
    const internalMap = new Map();
    return {
        has: (key) => internalMap.has(key),
        get: (key) => {
            const value = internalMap.get(key);
            if (value === undefined)
                return undefined;
            // Move to end (most recently used)
            internalMap.delete(key);
            internalMap.set(key, value);
            return value;
        },
        set: (key, val) => {
            // If key exists, delete it first to update order
            if (internalMap.has(key)) {
                internalMap.delete(key);
            }
            else if (internalMap.size === capacity) {
                // Evict least recently used (first entry)
                const firstKey = internalMap.keys().next().value;
                internalMap.delete(firstKey);
            }
            internalMap.set(key, val);
        },
        delete: (key) => {
            internalMap.delete(key);
        },
        map: internalMap,
    };
};

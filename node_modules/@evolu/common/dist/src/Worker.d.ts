import { TransferableError } from "./Error.js";
/** Cross-platform worker abstraction. */
export interface Worker<Input, Output> {
    /** Sends a message to the worker. */
    readonly postMessage: (message: Input) => void;
    /** Sets a callback for messages from the worker. */
    readonly onMessage: (callback: (message: Output) => void) => void;
}
export interface WorkerPostMessageDep<Output> {
    readonly postMessage: (message: Output) => void;
}
/**
 * Error reporting wrapper that catches synchronous errors in handlers and
 * converts them to transferable error messages sent to the main thread.
 */
export type WithErrorReporting = <A extends Array<any>>(handler: (...args: A) => void) => (...args: A) => void;
type HasInit<Input> = Extract<Input, {
    type: "init";
}> extends never ? ["Input must contain a variant with { type: 'init' }"] : unknown;
type HasWorkerErrorOutput<T> = Extract<T, {
    type: "onError";
}> extends infer E ? [E] extends [never] ? [
    "Output must contain { type: 'onError'; error: TransferableError | ... }"
] : E extends {
    error: infer Err;
} ? TransferableError extends Err ? unknown : ["Output.onError.error must include TransferableError"] : ["Output.onError must have an error property"] : never;
/**
 * Creates a {@link Worker} that supports initialization with dependencies and
 * safe error handling.
 */
export declare const createInitializedWorker: <Input extends {
    readonly type: string;
} & HasInit<Input>, Output extends {
    readonly type: string;
} & HasWorkerErrorOutput<Output>, Deps>({ init, onMessage, }: {
    readonly init: (initMessage: Extract<Input, {
        type: "init";
    }>, postMessage: (msg: Output) => void, withErrorReporting: WithErrorReporting) => Promise<Deps | null>;
    readonly onMessage: (deps: Deps) => (message: Exclude<Input, {
        type: "init";
    }>) => void;
}) => Worker<Input, Output>;
/** Type helper to extract message types from a union type */
export type MessageHandlers<Input extends {
    readonly type: string;
}, Deps> = {
    readonly [K in Input["type"]]: (deps: Deps) => (message: Extract<Input, {
        type: K;
    }>) => void;
};
/**
 * Creates a {@link Worker} with type-safe message handlers for each message
 * type. This provides better type safety and organization compared to a single
 * onMessage handler.
 */
export declare const createInitializedWorkerWithHandlers: <Input extends {
    readonly type: string;
} & HasInit<Input>, Output extends {
    readonly type: string;
} & HasWorkerErrorOutput<Output>, Deps>({ init, handlers, }: {
    readonly init: (initMessage: Extract<Input, {
        type: "init";
    }>, postMessage: (msg: Output) => void, withErrorReporting: WithErrorReporting) => Promise<Deps | null>;
    readonly handlers: Omit<MessageHandlers<Input, Deps>, "init">;
}) => Worker<Input, Output>;
export {};
//# sourceMappingURL=Worker.d.ts.map
import { err, ok } from "./Result.js";
import { PositiveInt } from "./Type.js";
/**
 * Creates {@link Resources}.
 *
 * This tracks which consumers are using which resources and maintains reference
 * counts to know when it's safe to dispose resources. Resources are created
 * on-demand and disposed with a configurable delay to avoid churn.
 *
 * ### Example Usage
 *
 * ```ts
 * // WebSocket connections
 * interface WebSocketConfig {
 *   readonly url: WebSocketUrl;
 * }
 *
 * type WebSocketUrl = string & Brand<"WebSocketUrl">;
 * type UserId = string & Brand<"UserId">;
 *
 * const webSockets = createResources<
 *   WebSocket,
 *   WebSocketUrl,
 *   WebSocketConfig,
 *   User,
 *   UserId
 * >({
 *   createResource: (config) => new WebSocket(config.url),
 *   getResourceKey: (config) => config.url,
 *   getConsumerId: (user) => user.id,
 *   disposalDelay: 1000,
 * });
 *
 * // Add users to WebSocket connections
 * webSockets.addConsumer(user1, [
 *   { url: "ws://server1.com" as WebSocketUrl },
 *   { url: "ws://server2.com" as WebSocketUrl },
 * ]);
 * webSockets.addConsumer(user2, [
 *   { url: "ws://server1.com" as WebSocketUrl },
 * ]);
 *
 * // Remove users - server1 stays alive (user2 still using it)
 * webSockets.removeConsumer(user1, [
 *   { url: "ws://server1.com" as WebSocketUrl },
 *   { url: "ws://server2.com" as WebSocketUrl },
 * ]);
 *
 * // server2 gets disposed after delay, server1 stays alive
 * ```
 */
export const createResources = (config) => {
    let isDisposed = false;
    const resourcesMap = new Map();
    const consumerCounts = new Map();
    const consumers = new Map();
    const disposalTimeouts = new Map();
    const disposalDelay = config.disposalDelay ?? 100;
    const ensureResource = (resourceConfig) => {
        const key = config.getResourceKey(resourceConfig);
        const timeout = disposalTimeouts.get(key);
        if (timeout) {
            clearTimeout(timeout);
            disposalTimeouts.delete(key);
        }
        if (!resourcesMap.has(key)) {
            const resource = config.createResource(resourceConfig);
            resourcesMap.set(key, resource);
        }
    };
    const scheduleDisposal = (key) => {
        const timeout = setTimeout(() => {
            const resource = resourcesMap.get(key);
            if (resource) {
                resource[Symbol.dispose]();
                resourcesMap.delete(key);
            }
            disposalTimeouts.delete(key);
        }, disposalDelay);
        disposalTimeouts.set(key, timeout);
    };
    const resources = {
        addConsumer: (consumer, resourceConfigs) => {
            if (isDisposed)
                return;
            const consumerId = config.getConsumerId(consumer);
            // Store consumer (last added consumer for this ID)
            consumers.set(consumerId, consumer);
            for (const resourceConfig of resourceConfigs) {
                ensureResource(resourceConfig);
                const resourceKey = config.getResourceKey(resourceConfig);
                let counts = consumerCounts.get(resourceKey);
                if (!counts) {
                    counts = new Map();
                    consumerCounts.set(resourceKey, counts);
                }
                const currentCount = counts.get(consumerId) ?? 0;
                const newCount = currentCount + 1;
                counts.set(consumerId, PositiveInt.orThrow(newCount));
                // Call onConsumerAdded callback only when consumer is added for the first time (0 -> 1)
                if (currentCount === 0 && config.onConsumerAdded) {
                    const resource = resourcesMap.get(resourceKey);
                    if (resource) {
                        config.onConsumerAdded(consumer, resource, resourceKey);
                    }
                }
            }
        },
        removeConsumer: (consumer, resourceConfigs) => {
            if (isDisposed)
                return ok();
            const consumerId = config.getConsumerId(consumer);
            for (const resourceConfig of resourceConfigs) {
                const key = config.getResourceKey(resourceConfig);
                const counts = consumerCounts.get(key);
                if (!counts) {
                    return err({ type: "ResourceNotFoundError", resourceKey: key });
                }
                const currentCount = counts.get(consumerId);
                if (currentCount == null) {
                    return err({
                        type: "ConsumerNotFoundError",
                        consumerId: consumerId,
                        resourceKey: key,
                    });
                }
                if (currentCount === 1) {
                    counts.delete(consumerId);
                    // Call onConsumerRemoved callback only when consumer is completely removed (1 -> 0)
                    if (config.onConsumerRemoved) {
                        const resource = resourcesMap.get(key);
                        if (resource) {
                            config.onConsumerRemoved(consumer, resource, key);
                        }
                    }
                    if (counts.size === 0) {
                        consumerCounts.delete(key);
                        scheduleDisposal(key);
                    }
                }
                else {
                    counts.set(consumerId, PositiveInt.orThrow(currentCount - 1));
                }
            }
            if (!resources.hasConsumerAnyResource(consumer)) {
                consumers.delete(consumerId);
            }
            return ok();
        },
        getResource: (key) => {
            if (isDisposed)
                return null;
            return resourcesMap.get(key) ?? null;
        },
        getConsumersForResource: (key) => {
            if (isDisposed)
                return [];
            const counts = consumerCounts.get(key);
            return counts ? Array.from(counts.keys()) : [];
        },
        hasConsumerAnyResource: (consumer) => {
            if (isDisposed)
                return false;
            const consumerId = config.getConsumerId(consumer);
            // If slow, can be optimized with reverse index
            return Array.from(consumerCounts.values()).some((counts) => counts.has(consumerId));
        },
        getConsumer: (consumerId) => {
            if (isDisposed)
                return null;
            const consumer = consumers.get(consumerId);
            if (!consumer)
                return null;
            // Only return consumer if it's currently using any resources
            if (!resources.hasConsumerAnyResource(consumer)) {
                return null;
            }
            return consumer;
        },
        [Symbol.dispose]: () => {
            if (isDisposed)
                return;
            isDisposed = true;
            for (const timeout of disposalTimeouts.values()) {
                clearTimeout(timeout);
            }
            disposalTimeouts.clear();
            for (const resource of resourcesMap.values()) {
                resource[Symbol.dispose]();
            }
            resourcesMap.clear();
            consumerCounts.clear();
            consumers.clear();
        },
    };
    return resources;
};

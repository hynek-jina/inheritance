/**
 * Checks if a value is a plain object (e.g., created with `{}` or `Object`).
 *
 * ### Example
 *
 * ```ts
 * isPlainObject({}); // true
 * isPlainObject(new Date()); // false
 * isPlainObject([]); // false
 * isPlainObject(null); // false
 * ```
 */
export const isPlainObject = (value) => Object.prototype.toString.call(value) === "[object Object]";
/**
 * Like `Object.entries` but preserves branded keys.
 *
 * ### Example
 *
 * ```ts
 * type UserId = string & { readonly __brand: "UserId" };
 * const users = createRecord<UserId, string>();
 * const entries = objectToEntries(users); // [UserId, string][]
 * ```
 */
export const objectToEntries = (record) => Object.entries(record);
/**
 * Maps a `ReadonlyRecord<K, V>` to a new `ReadonlyRecord<K, U>`, preserving
 * branded key types (e.g., `type Id = 'id' & string`) lost by `Object.entries`.
 * Uses `K extends string` for precision.
 */
export const mapObject = (record, fn) => Object.fromEntries(Object.entries(record).map(([key, value]) => [
    key,
    fn(value, key),
]));
/** Conditionally excludes a property from an object. */
export const excludeProp = (obj, prop, condition) => {
    if (condition) {
        return { ...obj };
    }
    const { [prop]: _, ...rest } = obj;
    return rest;
};
/**
 * Creates a prototype-less object typed as `Record<K, V>`.
 *
 * Use this function when you need a plain record without a prototype chain
 * (e.g. when keys are controlled by external sources) to avoid prototype
 * pollution and accidental collisions with properties like `__proto__`.
 *
 * Example:
 *
 * ```ts
 * const values = createRecord<string, SqliteValue>();
 * values["__proto__"] = someValue; // safe, no prototype pollution
 * ```
 */
export const createRecord = () => Object.create(null);
/**
 * Safely gets a property from a record, returning `undefined` if the key
 * doesn't exist.
 *
 * TypeScript's `Record<K, V>` type assumes all keys exist, but at runtime
 * accessing a non-existent key returns `undefined`. This helper provides proper
 * typing for that case without needing a type assertion.
 *
 * ### Example
 *
 * ```ts
 * const users: Record<string, User> = { alice: { name: "Alice" } };
 * const user = getProperty(users, "bob"); // User | undefined
 * ```
 */
export const getProperty = (record, key) => (key in record ? record[key] : undefined);

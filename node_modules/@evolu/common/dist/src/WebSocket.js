import { err, ok } from "./Result.js";
import { retry } from "./Task.js";
import { maxPositiveInt } from "./Type.js";
/**
 * Create a new {@link WebSocket}.
 *
 * The default behavior is that WebSocket tries to reconnect repeatedly in case
 * the application is offline, because online events (both web and native) are
 * not reliable. Once it connects and the connection is closed, it tries to
 * reconnect again. Retrying the connection can be controlled using the
 * retryOptions retryable predicate.
 *
 * ### How Binary Messages Work in WebSockets
 *
 * The Server Chooses the Message Type:
 *
 * - Text (0x1) → Sent as UTF-8 encoded text (always received as a string in the
 *   browser).
 * - Binary (0x2) → Sent as raw binary data (received as a Blob or ArrayBuffer,
 *   depending on binaryType).
 *
 * The Client's binaryType Controls How Binary Data is Processed:
 *
 * - If the server sends a text frame (0x1), the browser always delivers
 *   event.data as a string, regardless of binaryType.
 * - If the server sends a binary frame (0x2), the browser delivers event.data as:
 *
 *   - A Blob (default: "blob")
 *   - An ArrayBuffer ("arraybuffer")
 *
 * ### Example
 *
 * TODO:
 */
export const createWebSocket = (url, { protocols, binaryType, onOpen, onClose, onMessage, onError, retryOptions, WebSocketConstructor = globalThis.WebSocket, } = {}) => {
    let isDisposed = false;
    const reconnectController = new AbortController();
    const defaultRetryOptions = {
        retries: maxPositiveInt, // Practically infinite retries
    };
    let socket = null;
    const disposeSocket = () => {
        if (!socket)
            return;
        // Remove all listeners before closing
        socket.onopen = null;
        socket.onclose = null;
        socket.onmessage = null;
        socket.onerror = null;
        if (socket.readyState !== socket.CLOSING &&
            socket.readyState !== socket.CLOSED) {
            socket.close();
        }
        socket = null;
    };
    // To prevent a memory leak from pending connection promise.
    let disposePromise = null;
    /**
     * This promise represents continuous connection which:
     *
     * - Is rejected when a connection cannot be established.
     * - Is rejected when a connection is closed.
     * - Is resolved when WebSocket is disposed().
     */
    void retry({
        ...defaultRetryOptions,
        ...retryOptions,
    }, () => new Promise((resolve) => {
        disposePromise = () => {
            resolve(ok());
        };
        if (isDisposed)
            disposePromise();
        disposeSocket();
        socket = new WebSocketConstructor(url, protocols);
        if (binaryType)
            socket.binaryType = binaryType;
        let isOpen = false;
        socket.onopen = () => {
            isOpen = true;
            onOpen?.();
        };
        socket.onerror = (event) => {
            const error = isOpen
                ? { type: "WebSocketConnectionError", event }
                : { type: "WebSocketConnectError", event };
            onError?.(error);
            // Trigger reconnect only on WebSocketConnectError.
            if (error.type === "WebSocketConnectError") {
                resolve(err(error));
            }
        };
        socket.onclose = (event) => {
            onClose?.(event);
            resolve(err({ type: "WebSocketConnectionCloseError", event }));
        };
        socket.onmessage = (event) => {
            onMessage?.(event.data);
        };
    }))(reconnectController).then((result) => {
        if (result.ok || result.error.type === "AbortError")
            return;
        onError?.(result.error);
    });
    return {
        send: (data) => {
            // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
            if (!socket || socket.readyState === socket.CONNECTING) {
                return err({ type: "WebSocketSendError" });
            }
            socket.send(data);
            return ok();
        },
        getReadyState: () => socket ? nativeToStringState[socket.readyState] : "connecting",
        isOpen: () => (socket ? socket.readyState === socket.OPEN : false),
        [Symbol.dispose]() {
            if (isDisposed)
                return;
            isDisposed = true;
            reconnectController.abort();
            disposeSocket();
            disposePromise?.();
        },
    };
};
const nativeToStringState = {
    [WebSocket.CONNECTING]: "connecting",
    [WebSocket.OPEN]: "open",
    [WebSocket.CLOSING]: "closing",
    [WebSocket.CLOSED]: "closed",
};

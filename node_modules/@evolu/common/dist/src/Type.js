import { utf8ToBytes } from "@noble/ciphers/utils.js";
import { sha256 } from "@noble/hashes/sha2.js";
import * as bip39 from "@scure/bip39";
import { wordlist } from "@scure/bip39/wordlists/english.js";
import { pack } from "msgpackr";
import { isPlainObject } from "./Object.js";
import { hasNodeBuffer } from "./Platform.js";
import { err, getOrNull, getOrThrow, ok, trySync } from "./Result.js";
import { safelyStringifyUnknownValue } from "./String.js";
const EvoluTypeSymbol = Symbol("evolu.Type");
/**
 * Checks if the given value is an {@link Type}.
 *
 * @category Utilities
 */
export const isType = (value) => typeof value === "object" && value !== null && EvoluTypeSymbol in value;
const createType = (name, definition) => ({
    ...definition,
    name,
    is: (value) => definition.fromUnknown(value).ok,
    from: definition.fromUnknown,
    orThrow: (value) => getOrThrow(definition.fromUnknown(value)),
    orNull: (value) => getOrNull(definition.fromUnknown(value)),
    [EvoluTypeSymbol]: true,
    Type: undefined,
    Input: undefined,
    Error: undefined,
    Parent: undefined,
    ParentError: undefined,
    Errors: undefined,
    "~standard": {
        version: 1,
        vendor: "evolu",
        validate: (value) => {
            const result = definition.fromUnknown(value);
            if (result.ok) {
                return { value: result.value };
            }
            cachedStandardSchemaFormatTypeError ??= createFormatTypeError();
            return {
                issues: typeErrorToStandardSchemaIssues(result.error, cachedStandardSchemaFormatTypeError),
            };
        },
        types: {
            input: undefined,
            output: undefined,
        },
    },
});
/**
 * Creates a formatter function for {@link TypeError}.
 *
 * The formatter generates human-readable error messages using a custom
 * formatting function and a safely stringified error value.
 *
 * ### Example
 *
 * ```ts
 * const formatStringError = createTypeErrorFormatter<StringError>(
 *   (value) => `A value ${value} is not a string.`,
 * );
 * ```
 *
 * @category Utilities
 */
export const createTypeErrorFormatter = (format) => (error) => format({ ...error, value: safelyStringifyUnknownValue(error.value) });
/**
 * Base {@link Type}.
 *
 * A Base Type validates that a value conforms to a specific TypeScript type.
 *
 * ### Example
 *
 * ```ts
 * const String = base("String", (value) =>
 *   typeof value === "string"
 *     ? ok(value)
 *     : err<StringError>({ type: "String", value }),
 * );
 *
 * interface StringError extends TypeError<"String"> {}
 *
 * const formatStringError = createTypeErrorFormatter<StringError>(
 *   (error) => `A value ${error.value} is not a string`,
 * );
 * ```
 *
 * @category Base Factories
 */
export const base = (name, fromUnknown) => createType(name, {
    fromUnknown,
    fromParent: (ok), // `fromParent` relies on types, so it can't fail for the Base Type
});
/**
 * Creates a formatter function for a base {@link TypeError}.
 *
 * This formatter is specifically for Base Types that only need a simple error
 * message indicating that the value is not of the expected type.
 *
 * ### Example
 *
 * ```ts
 * export const formatStringError =
 *   createBaseTypeErrorFormatter<StringError>();
 * ```
 *
 * @category Utilities
 */
export const createBaseTypeErrorFormatter = () => createTypeErrorFormatter((error) => `A value ${error.value} is not a ${error.type.toLowerCase()}.`);
/** @category Base Types */
export const Unknown = base("Unknown", ok);
/**
 * @category Base Types
 * @category String
 */
export const String = base("String", (value) => typeof value === "string"
    ? ok(value)
    : err({ type: "String", value }));
export const formatStringError = createBaseTypeErrorFormatter();
/** @category Base Types */
export const Number = base("Number", (value) => typeof value === "number"
    ? ok(value)
    : err({ type: "Number", value }));
export const formatNumberError = createBaseTypeErrorFormatter();
/** @category Base Types */
export const BigInt = base("BigInt", (value) => typeof value === "bigint"
    ? ok(value)
    : err({ type: "BigInt", value }));
export const formatBigIntError = createBaseTypeErrorFormatter();
/** @category Base Types */
export const Boolean = base("Boolean", (value) => typeof value === "boolean"
    ? ok(value)
    : err({ type: "Boolean", value }));
export const formatBooleanError = createBaseTypeErrorFormatter();
/** @category Base Types */
export const Undefined = base("Undefined", (value) => value === undefined
    ? ok(value)
    : err({ type: "Undefined", value }));
export const formatUndefinedError = createBaseTypeErrorFormatter();
/** @category Base Types */
export const Null = base("Null", (value) => value === null ? ok(value) : err({ type: "Null", value }));
export const formatNullError = createBaseTypeErrorFormatter();
/** @category Base Types */
export const Function = base("Function", (value) => typeof value === "function"
    ? ok(value)
    : err({ type: "Function", value }));
export const formatFunctionError = createBaseTypeErrorFormatter();
/** @category Base Types */
export const Uint8Array = base("Uint8Array", (value) => value instanceof globalThis.Uint8Array
    ? ok(value)
    : err({ type: "Uint8Array", value }));
export const formatUint8ArrayError = createBaseTypeErrorFormatter();
/**
 * `instanceof` {@link Type}.
 *
 * Ensures that a value is an instance of the given class constructor.
 *
 * ### Example
 *
 * ```ts
 * class User {
 *   constructor(public name: string) {}
 * }
 *
 * const UserInstance = instanceOf(User);
 *
 * const result = UserInstance.from(new User("Alice")); // ok
 * const error = UserInstance.from({}); // err
 * ```
 *
 * @category Base Factories
 */
export const instanceOf = (ctor) => ({
    ...base("InstanceOf", (value) => value instanceof ctor
        ? ok(value)
        : err({ type: "InstanceOf", value, ctor: ctor.name })),
    ctor,
});
export const formatInstanceOfError = createTypeErrorFormatter((error) => `The value ${error.value} is not an instance of ${error.ctor}.`);
/**
 * JavaScript Date.
 *
 * @category Base Types
 */
export const Date = instanceOf(globalThis.Date);
/**
 * Validates that an unknown value is an Evolu {@link Type} (i.e., satisfies
 * `AnyType`).
 *
 * ### Example
 *
 * ```ts
 * const result = EvoluType.from(String); // ok(String)
 * const error = EvoluType.from("not a Type"); // err
 * ```
 */
// TODO: Rename to TypeInstance or something like that.
export const EvoluType = base("EvoluType", (value) => isType(value)
    ? ok(value)
    : err({
        type: "EvoluType",
        value,
    }));
export const formatIsTypeError = createTypeErrorFormatter((error) => `Value ${error.value} is not a valid Evolu Type.`);
export function brand(name, parent, refine) {
    const fromUnknown = refine
        ? (value) => {
            const parentResult = parent.fromUnknown(value);
            if (!parentResult.ok)
                return parentResult;
            return refine(parentResult.value);
        }
        : (value) => {
            const parentResult = parent.fromUnknown(value);
            if (!parentResult.ok)
                return err({
                    type: name,
                    value,
                    parentError: parentResult.error,
                });
            return ok(parentResult.value);
        };
    return {
        ...createType("Brand", {
            fromUnknown,
            fromParent: (refine ?? ok),
        }),
        brand: name,
        parentType: parent,
    };
}
/**
 * A three-letter ISO 4217 currency code (e.g., USD, EUR).
 *
 * @category String
 */
export const CurrencyCode = brand("CurrencyCode", String, (value) => /^[A-Z]{3}$/.test(value)
    ? ok(value)
    : err({ type: "CurrencyCode", value }));
export const formatCurrencyCodeError = createTypeErrorFormatter((error) => `Invalid currency code: ${error.value}.`);
/**
 * ISO 8601 date-time string.
 *
 * This {@link Type} represents a date-time string that follows the ISO 8601
 * format and is compatible with SQLite, which lacks a native date type and
 * relies on ISO 8601 strings for sorting. Enforcing a 24-character format
 * ensures correct lexicographic ordering.
 *
 * It must be a valid JavaScript Date string that can be parsed.
 *
 * Valid range: `"0000-01-01T00:00:00.000Z"` to `"9999-12-31T23:59:59.999Z"`.
 *
 * ### Example
 *
 * ```ts
 * const result = DateIso.from("2023-01-01T12:00:00.000Z"); // ok
 * const error = DateIso.from("10000-01-01T00:00:00.000Z"); // err
 * ```
 *
 * @category String
 */
export const DateIso = brand("DateIso", String, (value) => {
    if (value.length !== 24) {
        return err({ type: "DateIso", value });
    }
    const parsed = globalThis.Date.parse(value);
    if (isNaN(parsed)) {
        return err({ type: "DateIso", value });
    }
    // Round-trip test: ensure the string is actually a proper ISO format
    const roundTrip = new globalThis.Date(parsed).toISOString();
    if (roundTrip !== value) {
        return err({ type: "DateIso", value });
    }
    return ok(value);
});
export const formatDateIsoError = createTypeErrorFormatter((error) => `The value ${error.value} is not a valid ISO 8601 date string.`);
export const dateToDateIso = (value) => DateIso.fromParent(value.toISOString());
export const dateIsoToDate = (value) => new globalThis.Date(value);
/**
 * Trimmed string.
 *
 * This Type Factory validates whether a string has no leading or trailing
 * whitespaces.
 *
 * ### Example
 *
 * ```ts
 * const TrimmedNonEmptyString = trimmed(minLength(1)(String));
 * // string & Brand<"MinLength1"> & Brand<"Trimmed">
 * type TrimmedNonEmptyString = typeof TrimmedNonEmptyString.Type;
 * ```
 *
 * @category String
 */
export const trimmed = (parent) => brand("Trimmed", parent, (value) => value.trim().length === value.length
    ? ok(value)
    : err({ type: "Trimmed", value }));
export const formatTrimmedError = createTypeErrorFormatter((error) => `The value ${error.value} must be trimmed.`);
/**
 * Trimmed string
 *
 * - Use `TrimmedString.is` to check if an unknown value is trimmed.
 * - Use `TrimmedString.from` to check if a string is trimmed.
 *
 * @category String
 */
export const TrimmedString = trimmed(String);
export const trim = (value) => value.trim();
/**
 * Minimum length.
 *
 * ### Example
 *
 * ```ts
 * // string & Brand<"MinLength1">
 * const NonEmptyString = minLength(1)(String);
 * ```
 *
 * @category String
 * @category Array
 */
export const minLength = (min) => (parent) => brand(`MinLength${min}`, parent, (value) => value.length >= min ? ok(value) : err({ type: "MinLength", value, min }));
export const formatMinLengthError = createTypeErrorFormatter((error) => `The value ${error.value} does not meet the minimum length of ${error.min}.`);
/**
 * Maximum length.
 *
 * ### Example
 *
 * ```ts
 * // string & Brand<"MaxLength100">
 * const String100 = maxLength(100)(String);
 * ```
 *
 * @category String
 * @category Array
 */
export const maxLength = (max) => (parent) => brand(`MaxLength${max}`, parent, (value) => value.length <= max ? ok(value) : err({ type: "MaxLength", value, max }));
export const formatMaxLengthError = createTypeErrorFormatter((error) => `The value ${error.value} exceeds the maximum length of ${error.max}.`);
/**
 * Exact length.
 *
 * ### Example
 *
 * ```ts
 * // string & Brand<"Length1">
 * const Length1String = length(1)(String);
 * ```
 *
 * @category String
 * @category Array
 */
export const length = (exact) => (parent) => brand(`Length${exact}`, parent, (value) => value.length === exact
    ? ok(value)
    : err({ type: "Length", value, exact }));
export const formatLengthError = createTypeErrorFormatter((error) => `The value ${error.value} does not have the required length of ${error.exact}.`);
/** @category String */
export const NonEmptyString = minLength(1)(String);
/** @category String */
export const String100 = maxLength(100)(String);
/** @category String */
export const String1000 = maxLength(1000)(String);
/** @category String */
export const NonEmptyString100 = minLength(1)(String100);
/** @category String */
export const NonEmptyString1000 = minLength(1)(String1000);
/** @category String */
export const NonEmptyTrimmedString = minLength(1)(TrimmedString);
/** @category String */
export const TrimmedString100 = maxLength(100)(TrimmedString);
/** @category String */
export const TrimmedString1000 = maxLength(1000)(TrimmedString);
/** @category String */
export const NonEmptyTrimmedString100 = minLength(1)(TrimmedString100);
/** @category String */
export const NonEmptyTrimmedString1000 = minLength(1)(TrimmedString1000);
/**
 * The mnemonic, also known as a "seed phrase," is a set of 12 words in a
 * specific order chosen from a predefined list (BIP39). It provides a
 * human-readable way to store a private key securely. The mnemonic is generated
 * safely on the user's device using cryptographically secure random number
 * generation, ensuring it remains private and unique.
 *
 * @category String
 */
export const Mnemonic = brand("Mnemonic", NonEmptyTrimmedString, (value) => bip39.validateMnemonic(value, wordlist)
    ? ok(value)
    : err({ type: "Mnemonic", value }));
export const formatMnemonicError = createTypeErrorFormatter((error) => `Invalid BIP39 mnemonic: ${error.value}.`);
/**
 * String matching a regular expression.
 *
 * ### Example
 *
 * ```ts
 * const Alphanumeric = regex("Alphanumeric", /^[a-z0-9]+$/i)(String);
 * ```
 *
 * @category String
 */
export const regex = (name, pattern) => {
    // Clone the regex to avoid shared state.
    const clonedPattern = new RegExp(pattern.source, pattern.flags);
    return (parent) => brand(name, parent, (value) => {
        // Reset `lastIndex` before each use to ensure the regex starts matching
        // from the beginning of the string.
        clonedPattern.lastIndex = 0;
        return clonedPattern.test(value)
            ? ok(value)
            : err({ type: "Regex", name, value, pattern });
    });
};
export const formatRegexError = createTypeErrorFormatter((error) => `The value ${error.value} does not match the pattern for ${error.name}: ${error.pattern}.`);
/**
 * URL-safe string.
 *
 * A `UrlSafeString` uses a limited alphabet that is safe for URLs:
 *
 * - Uppercase letters (`A-Z`)
 * - Lowercase letters (`a-z`)
 * - Digits (`0-9`)
 * - Dash (`-`)
 * - Underscore (`_`)
 *
 * This is the same character set used by Base64Url encoding, but this type does
 * not validate that the string is actually Base64Url-encoded data.
 *
 * ### Example
 *
 * ```ts
 * const result = UrlSafeString.from("abc123_-");
 * if (result.ok) {
 *   console.log("Valid URL-safe string:", result.value);
 * } else {
 *   console.error("Invalid URL-safe string:", result.error);
 * }
 * ```
 *
 * @category String
 */
export const UrlSafeString = regex("UrlSafeString", /^[A-Za-z0-9_-]+$/)(String);
/**
 * Base64Url without padding.
 *
 * Encode with {@link uint8ArrayToBase64Url}, decode with
 * {@link base64UrlToUint8Array}.
 *
 * @category String
 */
export const Base64Url = brand("Base64Url", String, (value) => {
    // Round-trip validation ensures consistency across different base64url
    // implementations (Node.js Buffer, native browser API, manual fallback).
    // Only strings that decode and encode identically are accepted.
    let roundTrip;
    try {
        roundTrip = uint8ArrayToBase64Url(base64UrlToUint8Array(value));
    }
    catch {
        //
    }
    return roundTrip === value
        ? ok(value)
        : err({ type: "Base64Url", value });
});
export const formatBase64UrlError = createTypeErrorFormatter((error) => `The value ${error.value} is not a valid Base64Url string.`);
const base64UrlOptions = { alphabet: "base64url", omitPadding: true };
/** Encodes a Uint8Array to a {@link Base64Url} string. */
export const uint8ArrayToBase64Url = hasNodeBuffer
    ? (bytes) => globalThis.Buffer.from(bytes).toString("base64url")
    : // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        typeof globalThis.Uint8Array.prototype?.toBase64 !== "undefined"
            ? (bytes) => 
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
            bytes.toBase64(base64UrlOptions)
            : (bytes) => {
                const binaryString = Array.from(bytes, (byte) => globalThis.String.fromCodePoint(byte)).join("");
                const base64 = globalThis.btoa(binaryString);
                return base64
                    .replace(/\+/g, "-")
                    .replace(/\//g, "_")
                    .replace(/=/g, "");
            };
/** Decodes a {@link Base64Url} string to a Uint8Array. */
export const base64UrlToUint8Array = hasNodeBuffer
    ? (str) => {
        const nodeBuffer = globalThis.Buffer.from(str, "base64url");
        return new globalThis.Uint8Array(nodeBuffer);
    }
    : // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        typeof globalThis.Uint8Array?.fromBase64 !== "undefined"
            ? (str) => 
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
            globalThis.Uint8Array.fromBase64(str, base64UrlOptions)
            : (str) => {
                let base64 = str.replace(/-/g, "+").replace(/_/g, "/");
                while (base64.length % 4 !== 0) {
                    base64 += "=";
                }
                const binaryString = globalThis.atob(base64);
                return globalThis.Uint8Array.from(binaryString, (c) => c.charCodeAt(0));
            };
/**
 * Simple alphanumeric string for naming in file systems, URLs, and identifiers.
 *
 * Uses the same safe alphabet as {@link UrlSafeString} (letters, digits, `-`,
 * `_`). See `UrlSafeString` for details.
 *
 * The string must be between 1 and 64 characters.
 *
 * ### Example
 *
 * ```ts
 * const result = SimpleName.from("data-report-123");
 * if (result.ok) {
 *   console.log("Valid SimpleName string:", result.value);
 * } else {
 *   console.error("Invalid SimpleName string:", result.error);
 * }
 * ```
 *
 * @category String
 */
export const SimpleName = brand("SimpleName", UrlSafeString, (value) => value.length >= 1 && value.length <= 64
    ? ok(value)
    : err({ type: "SimpleName", value }));
/**
 * Trimmed string between 8 and 64 characters, branded as `SimplePassword`.
 *
 * Take a look how `SimplePassword` is defined:
 *
 * ```ts
 * export const SimplePassword = brand(
 *   "SimplePassword",
 *   minLength(8)(maxLength(64)(TrimmedString)),
 * );
 * ```
 *
 * Nested functions are often OK (if not, make a helper), but with TC39 Hack
 * pipes it would be clearer:
 *
 * ```ts
 * // TrimmedString
 * //   |> minLength(8)(%)
 * //   |> maxLength(64)(%)
 * //   |> brand("SimplePassword", %)
 * ```
 *
 * @category String
 */
export const SimplePassword = brand("SimplePassword", minLength(8)(maxLength(64)(TrimmedString)));
export const formatSimplePasswordError = (formatTypeError) => createTypeErrorFormatter((error) => `Invalid password: ${formatTypeError(error.parentError)}`);
/**
 * Evolu Id: 16 bytes encoded as a 22‑character Base64Url string.
 *
 * There are three ways to create an Evolu Id:
 *
 * - {@link createId} – default cryptographically secure random bytes
 *   (privacy‑preserving)
 * - {@link createIdFromString} – deterministic: first 16 bytes of SHA‑256 of a
 *   string
 * - {@link createIdAsUuidv7} – optional: embeds timestamp bits (UUID v7 layout)
 *
 * Privacy: the default random Id does not leak creation time and is safe to
 * share or log. The UUID v7 variant leaks creation time anywhere the Id is
 * copied (logs, URLs, exports); only use it when you explicitly want insertion
 * locality for very large write‑heavy tables and accept timestamp exposure.
 *
 * ### Future
 *
 * A possible hybrid masked‑time approach (`timestamp ^ H(cluster_id, timestamp
 *
 * > > N)`) could provide locality without exposing raw creation time. See
 * > > https://brooker.co.za/blog/2025/10/22/uuidv7.html
 *
 * @category String
 */
export const Id = brand("Id", String, (value) => value.length === 22 && Base64Url.fromParent(value).ok
    ? ok(value)
    : err({ type: "Id", value }));
export const formatIdError = createTypeErrorFormatter((error) => `The value ${error.value} is not a valid Id.`);
/**
 * Creates a random {@link Id}. This is the recommended default.
 *
 * Use {@link createIdFromString} for deterministic mapping of external IDs or
 * {@link createIdAsUuidv7} when you accept timestamp leakage for index
 * locality.
 *
 * ### Example
 *
 * ```ts
 * const id = createId(deps);
 * const todoId = createId<"Todo">(deps);
 * ```
 */
export const createId = (deps) => {
    const id = uint8ArrayToBase64Url(deps.randomBytes.create(16));
    return id;
};
/**
 * Creates an {@link Id} from a string using SHA-256.
 *
 * When integrating with external systems that use different ID formats, use
 * this function to convert external IDs into valid Evolu IDs.
 *
 * In Evolu's CRDT, the ID serves as the unique identifier for conflict
 * resolution across distributed clients. When multiple clients create records
 * with the same external identifier, they must resolve to the same Evolu ID to
 * ensure data consistency.
 *
 * ### Example
 *
 * ```ts
 * // Both clients will generate the same ID
 * const id1 = createIdFromString("user-api-123");
 * const id2 = createIdFromString("user-api-123");
 * console.log(id1 === id2); // true
 *
 * upsert("todo", {
 *   id: createIdFromString("external-todo-456"),
 *   title: "Synced from external system",
 * });
 * ```
 *
 * **Important**: This transformation uses the first 16 bytes of SHA-256 hash of
 * the string bytes, therefore it's not possible to recover the original
 * external string from the generated {@link Id}. If you need to preserve the
 * original external ID, store it in a separate column.
 *
 * @category String
 */
export const createIdFromString = (value) => {
    const hash = sha256(utf8ToBytes(value));
    // Take first 16 bytes of hash and convert to Id
    const id = idBytesToId(hash.slice(0, 16));
    return id;
};
/**
 * Creates an {@link Id} embedding timestamp bits (UUID v7 layout) before
 * Base64Url encoding.
 *
 * Tradeoff: better insertion locality / index performance for huge datasets vs
 * leaking creation time everywhere the Id appears. Evolu uses {@link createId}
 * by default to avoid activity leakage; choose this only if you explicitly
 * accept timestamp exposure.
 *
 * ### Example
 *
 * ```ts
 * const id = createIdAsUuidv7({ randomBytes, time });
 * const todoId = createIdAsUuidv7<"Todo">({ randomBytes, time });
 * ```
 */
export const createIdAsUuidv7 = (deps) => {
    const id = deps.randomBytes.create(16);
    const timestamp = globalThis.BigInt(deps.time.now());
    id[0] = globalThis.Number((timestamp >> 40n) & 0xffn);
    id[1] = globalThis.Number((timestamp >> 32n) & 0xffn);
    id[2] = globalThis.Number((timestamp >> 24n) & 0xffn);
    id[3] = globalThis.Number((timestamp >> 16n) & 0xffn);
    id[4] = globalThis.Number((timestamp >> 8n) & 0xffn);
    id[5] = globalThis.Number(timestamp & 0xffn);
    id[6] = (id[6] & 0x0f) | 0x70;
    id[8] = (id[8] & 0x3f) | 0x80;
    return id;
};
/**
 * Creates a branded {@link Id} Type for a table's primary key.
 *
 * The table name becomes an additional brand for type safety.
 *
 * ### Example
 *
 * ```ts
 * const TodoId = id("Todo");
 * // string & Brand<"Id"> & Brand<"Todo">
 * type TodoId = typeof TodoId.Type;
 * ```
 *
 * @category String
 */
export const id = (table) => {
    const fromUnknown = (value) => {
        const parentResult = String.fromUnknown(value);
        if (!parentResult.ok)
            return parentResult;
        return fromParent(parentResult.value);
    };
    const fromParent = (value) => {
        const idResult = Id.fromParent(value);
        if (!idResult.ok) {
            return err({ type: "TableId", value, table });
        }
        return ok(idResult.value);
    };
    return {
        ...createType("Id", { fromUnknown, fromParent }),
        table,
    };
};
export const formatTableIdError = createTypeErrorFormatter((error) => `Invalid Id for table ${error.table}: ${error.value}.`);
/** Binary representation of an {@link Id}. */
export const IdBytes = brand("IdBytes", length(16)(Uint8Array));
export const idBytesTypeValueLength = 16;
export const idToIdBytes = (id) => 
// Id is Base64Url (validated by Id.from), cast is safe
base64UrlToUint8Array(id);
export const idBytesToId = (idBytes) => 
// Base64Url encoding of 16 bytes always produces valid Id (22 chars)
uint8ArrayToBase64Url(idBytes);
/**
 * Positive number (> 0).
 *
 * ### Example
 *
 * ```ts
 * const PositiveNumber = positive(Number);
 *
 * const result = PositiveNumber.from(42); // ok
 * const errorResult = PositiveNumber.from(-5); // err
 * ```
 *
 * @category Number
 */
export const positive = (parent) => brand("Positive", parent, (value) => value > 0 ? ok(value) : err({ type: "Positive", value }));
export const formatPositiveError = createTypeErrorFormatter((error) => `The value ${error.value} must be positive (> 0).`);
/**
 * Negative number (< 0).
 *
 * ### Example
 *
 * ```ts
 * const NegativeNumber = negative(Number);
 * ```
 *
 * @category Number
 */
export const negative = (parent) => brand("Negative", parent, (value) => value < 0 ? ok(value) : err({ type: "Negative", value }));
export const formatNegativeError = createTypeErrorFormatter((error) => `The value ${error.value} must be negative (< 0).`);
/**
 * Non-positive number (≤ 0).
 *
 * ### Example
 *
 * ```ts
 * const NonPositiveNumber = nonPositive(Number);
 * ```
 *
 * @category Number
 */
export const nonPositive = (parent) => brand("NonPositive", parent, (value) => value <= 0
    ? ok(value)
    : err({ type: "NonPositive", value }));
export const formatNonPositiveError = createTypeErrorFormatter((error) => `The value ${error.value} must be non-positive (≤ 0).`);
/**
 * Non-negative number (≥ 0).
 *
 * ### Example
 *
 * ```ts
 * const NonNegativeNumber = nonNegative(Number);
 * ```
 *
 * @category Number
 */
export const nonNegative = (parent) => brand("NonNegative", parent, (value) => value >= 0
    ? ok(value)
    : err({ type: "NonNegative", value }));
export const formatNonNegativeError = createTypeErrorFormatter((error) => `The value ${error.value} must be non-negative (≥ 0).`);
/**
 * Non-negative number (≥ 0).
 *
 * @category Number
 */
export const NonNegativeNumber = nonNegative(Number);
/**
 * Positive number (> 0).
 *
 * @category Number
 */
export const PositiveNumber = positive(NonNegativeNumber);
/**
 * Non-positive number (≤ 0).
 *
 * @category Number
 */
export const NonPositiveNumber = nonPositive(Number);
/**
 * Negative number (< 0).
 *
 * @category Number
 */
export const NegativeNumber = negative(NonPositiveNumber);
/**
 * Integer within the safe range of JavaScript numbers.
 *
 * ### Example
 *
 * ```ts
 * const Int = int(Number);
 * ```
 *
 * @category Number
 */
export const int = (parent) => brand("Int", parent, (value) => globalThis.Number.isSafeInteger(value)
    ? ok(value)
    : err({ type: "Int", value }));
export const formatIntError = createTypeErrorFormatter((error) => `The value ${error.value} must be an integer.`);
/**
 * Integer within the safe range of JavaScript numbers.
 *
 * @category Number
 */
export const Int = int(Number);
/**
 * Non-negative integer (≥ 0).
 *
 * @category Number
 */
export const NonNegativeInt = nonNegative(Int);
/**
 * Positive integer (> 0).
 *
 * @category Number
 */
export const PositiveInt = positive(NonNegativeInt);
/** Maximum safe positive integer value for practically infinite operations. */
export const maxPositiveInt = PositiveInt.orThrow(globalThis.Number.MAX_SAFE_INTEGER);
/**
 * Non-positive integer (≤ 0).
 *
 * @category Number
 */
export const NonPositiveInt = nonPositive(Int);
/**
 * Negative integer (< 0).
 *
 * @category Number
 */
export const NegativeInt = negative(NonPositiveInt);
/**
 * Number greater than a specified value.
 *
 * @category Number
 */
export const greaterThan = (min) => (parent) => brand(`GreaterThan${min}`, parent, (value) => value > min ? ok(value) : err({ type: "GreaterThan", value, min }));
export const formatGreaterThanError = createTypeErrorFormatter((error) => `The value ${error.value} is not > ${error.min}.`);
/**
 * Number less than a specified value.
 *
 * @category Number
 */
export const lessThan = (max) => (parent) => brand(`LessThan${max}`, parent, (value) => value < max ? ok(value) : err({ type: "LessThan", value, max }));
export const formatLessThanError = createTypeErrorFormatter((error) => `The value ${error.value} is not < ${error.max}.`);
/**
 * Number ≥ a specified value.
 *
 * @category Number
 */
export const greaterThanOrEqualTo = (min) => (parent) => brand(`GreaterThanOrEqualTo${min}`, parent, (value) => value >= min
    ? ok(value)
    : err({ type: "GreaterThanOrEqualTo", value, min }));
export const formatGreaterThanOrEqualToError = createTypeErrorFormatter((error) => `The value ${error.value} is not >= ${error.min}.`);
/**
 * Number ≤ a specified value.
 *
 * @category Number
 */
export const lessThanOrEqualTo = (max) => (parent) => brand(`LessThanOrEqualTo${max}`, parent, (value) => value <= max ? ok(value) : err({ type: "LessThanOrEqualTo", value, max }));
export const formatLessThanOrEqualToError = createTypeErrorFormatter((error) => `The value ${error.value} is not <= ${error.max}.`);
/**
 * Number that is not NaN.
 *
 * @category Number
 */
export const nonNaN = (parent) => brand("NonNaN", parent, (value) => !globalThis.Number.isNaN(value)
    ? ok(value)
    : err({ type: "NonNaN", value }));
export const formatNonNaNError = createTypeErrorFormatter(() => `The value must not be NaN.`);
/** @category Number */
export const NonNaNNumber = nonNaN(Number);
/**
 * Finite number.
 *
 * @category Number
 */
export const finite = (parent) => brand("Finite", parent, (value) => globalThis.Number.isFinite(value)
    ? ok(value)
    : err({ type: "Finite", value }));
export const formatFiniteError = createTypeErrorFormatter((error) => `The value ${error.value} must be finite.`);
/**
 * Finite number.
 *
 * This Type ensures that a number is finite.
 *
 * **Why is this important?**
 *
 * `JSON.stringify` serializes JavaScript numbers into `null` if they are not
 * finite (e.g., `Infinity`, `-Infinity`, or `NaN`). Using `FiniteNumber` helps
 * prevent these unexpected behaviors when working with JSON serialization.
 *
 * @category Number
 */
export const FiniteNumber = finite(Number);
/**
 * Number that is a multiple of a divisor.
 *
 * @category Number
 */
export const multipleOf = (divisor) => (parent) => brand(`MultipleOf${divisor}`, parent, (value) => value % divisor === 0
    ? ok(value)
    : err({ type: "MultipleOf", value, divisor }));
export const formatMultipleOfError = createTypeErrorFormatter((error) => `The value ${error.value} is not a multiple of ${error.divisor}.`);
/**
 * Number within a range, inclusive.
 *
 * ### Example
 *
 * ```ts
 * const Between1And10 = between(1, 10)(PositiveNumber);
 * const result = Between1And10.from(5); // ok(5)
 * const errorResult = Between1And10.from(11); // err
 * ```
 *
 * @category Number
 */
export const between = (min, max) => (parent) => brand(`Between${min}-${max}`, parent, (value) => value >= min && value <= max
    ? ok(value)
    : err({ type: "Between", value, min, max }));
export const formatBetweenError = createTypeErrorFormatter((error) => `The value ${error.value} is not between ${error.min} and ${error.max}, inclusive.`);
/**
 * Literal {@link Type}.
 *
 * https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types
 *
 * ### Example
 *
 * ```ts
 * const LiteralHello = literal("Hello");
 * const result = LiteralHello.from("Hello"); // ok("Hello")
 * const errorResult = LiteralHello.from("World"); // err
 * ```
 *
 * TODO: Add JsonValue
 *
 * @category Base Factories
 */
export const literal = (expected) => {
    const fromUnknown = (value) => value === expected
        ? ok(expected)
        : err({ type: "Literal", value, expected });
    return {
        ...createType("Literal", {
            fromUnknown,
            fromParent: ok,
        }),
        expected,
    };
};
export const formatLiteralError = createTypeErrorFormatter((error) => `The value ${error.value} is not strictly equal to the expected literal: ${globalThis.String(error.expected)}.`);
/**
 * Array of a specific {@link Type}.
 *
 * Usage:
 *
 * ```ts
 * const NumberArray = array(Number);
 *
 * const result1 = NumberArray.from([1, 2, 3]); // ok([1, 2, 3])
 * const result2 = NumberArray.from(["a", "b"]); // err(...)
 * ```
 *
 * @category Base Factories
 * @category Array
 */
export const array = (element) => {
    const fromUnknown = (value) => {
        if (!Array.isArray(value)) {
            return err({
                type: "Array",
                value,
                reason: { kind: "NotArray" },
            });
        }
        const result = [];
        for (let i = 0; i < value.length; i++) {
            const elementResult = element.fromUnknown(value[i]);
            if (!elementResult.ok) {
                return err({
                    type: "Array",
                    value,
                    reason: {
                        kind: "Element",
                        index: i,
                        error: elementResult.error,
                    },
                });
            }
            result.push(elementResult.value);
        }
        return ok(result);
    };
    const fromParent = (value) => {
        const result = [];
        for (let i = 0; i < value.length; i++) {
            const elementResult = element.fromParent(value[i]);
            if (!elementResult.ok) {
                return err({
                    type: "Array",
                    value,
                    reason: {
                        kind: "Element",
                        index: i,
                        error: elementResult.error,
                    },
                });
            }
            result.push(elementResult.value);
        }
        return ok(result);
    };
    return {
        ...createType("Array", { fromUnknown, fromParent }),
        element,
    };
};
export const formatArrayError = (formatTypeError) => createTypeErrorFormatter((error) => {
    switch (error.reason.kind) {
        case "NotArray":
            return `Expected an array but received ${error.value}.`;
        case "Element":
            return `Invalid element at index ${error.reason.index}: ${formatTypeError(error.reason.error)}`;
    }
});
/**
 * Set of a specific {@link Type}.
 *
 * ### Example
 *
 * ```ts
 * const NumberSet = set(Number);
 *
 * const result1 = NumberSet.from(new Set([1, 2, 3])); // ok(Set { 1, 2, 3 })
 * const result2 = NumberSet.from(new Set(["a", "b"])); // err(...)
 * ```
 *
 * @category Base Factories
 */
export const set = (element) => {
    const fromUnknown = (value) => {
        if (!(value instanceof globalThis.Set)) {
            return err({
                type: "Set",
                value,
                reason: { kind: "NotSet" },
            });
        }
        let index = 0;
        for (const item of value) {
            const elementResult = element.fromUnknown(item);
            if (!elementResult.ok) {
                return err({
                    type: "Set",
                    value,
                    reason: {
                        kind: "Element",
                        index,
                        error: elementResult.error,
                    },
                });
            }
            index++;
        }
        return ok(value);
    };
    const fromParent = (value) => {
        let index = 0;
        for (const item of value) {
            const elementResult = element.fromParent(item);
            if (!elementResult.ok) {
                return err({
                    type: "Set",
                    value,
                    reason: {
                        kind: "Element",
                        index,
                        error: elementResult.error,
                    },
                });
            }
            index++;
        }
        return ok(value);
    };
    return {
        ...createType("Set", { fromUnknown, fromParent }),
        element,
    };
};
export const formatSetError = (formatTypeError) => createTypeErrorFormatter((error) => {
    switch (error.reason.kind) {
        case "NotSet":
            return `Expected a Set but received ${error.value}.`;
        case "Element":
            return `Invalid element at index ${error.reason.index}: ${formatTypeError(error.reason.error)}`;
    }
});
/**
 * Record of a key {@link Type} and value {@link Type}.
 *
 * - The input must be a plain object (validated by {@link isPlainObject}).
 * - Each key is validated/transformed by the `key` Type.
 * - Each value is validated/transformed by the `value` Type.
 *
 * The resulting type is `Readonly<Record<KeyT, ValueT>>`.
 *
 * ### Example
 *
 * ```ts
 * const StringToNumberRecord = record(String, Number);
 *
 * // ok({ "a": 1, "b": 2 })
 * StringToNumberRecord.from({ a: 1, b: 2 });
 *
 * // err => "Key" because 42 is not a string key
 * StringToNumberRecord.from({ 42: 1, b: 2 });
 *
 * // err => "Value" because "x" is not a number
 * StringToNumberRecord.from({ a: "x", b: 2 });
 * ```
 *
 * @category Base Factories
 * @category Object
 */
export const record = (keyType, valueType) => {
    const fromUnknown = (value) => {
        if (!isPlainObject(value)) {
            return err({
                type: "Record",
                value,
                reason: { kind: "NotRecord" },
            });
        }
        const result = {};
        for (const [rawKey, rawValue] of Object.entries(value)) {
            const keyResult = keyType.fromUnknown(rawKey);
            if (!keyResult.ok) {
                return err({
                    type: "Record",
                    value,
                    reason: { kind: "Key", key: rawKey, error: keyResult.error },
                });
            }
            const valueResult = valueType.fromUnknown(rawValue);
            if (!valueResult.ok) {
                return err({
                    type: "Record",
                    value,
                    reason: {
                        kind: "Value",
                        key: rawKey,
                        error: valueResult.error,
                    },
                });
            }
            result[keyResult.value] = valueResult.value;
        }
        return ok(result);
    };
    const fromParent = (value) => {
        const result = {};
        for (const [rawKey, rawValue] of Object.entries(value)) {
            const keyResult = keyType.fromParent(rawKey);
            if (!keyResult.ok) {
                return err({
                    type: "Record",
                    value,
                    reason: {
                        kind: "Key",
                        key: rawKey,
                        error: keyResult.error,
                    },
                });
            }
            const valueResult = valueType.fromParent(rawValue);
            if (!valueResult.ok) {
                return err({
                    type: "Record",
                    value,
                    reason: {
                        kind: "Value",
                        key: keyResult.value,
                        error: valueResult.error,
                    },
                });
            }
            result[keyResult.value] = valueResult.value;
        }
        return ok(result);
    };
    return {
        ...createType("Record", {
            fromUnknown,
            fromParent,
        }),
        key: keyType,
        value: valueType,
    };
};
export const formatRecordError = (formatTypeError) => createTypeErrorFormatter((error) => {
    switch (error.reason.kind) {
        case "NotRecord":
            return `Expected a record (plain object) but received ${error.value}.`;
        case "Key":
            return `Invalid key ${error.reason.key}: ${formatTypeError(error.reason.error)}`;
        case "Value":
            return `Invalid value for key ${error.reason.key}: ${formatTypeError(error.reason.error)}`;
    }
});
export function object(props, record) {
    /* eslint-disable */
    const propKeys = Object.keys(props);
    const fromUnknown = (value) => {
        if (!isPlainObject(value)) {
            return err({
                type: record ? "ObjectWithRecord" : "Object",
                value,
                reason: { kind: "NotObject" },
            });
        }
        const errors = {};
        const result = {};
        for (const key of propKeys) {
            if (!(key in value) && isOptionalType(props[key])) {
                continue;
            }
            const propResult = props[key].fromUnknown(value[key]);
            if (!propResult.ok) {
                errors[key] = propResult.error;
            }
            else {
                result[key] = propResult.value;
            }
        }
        const extraKeys = Object.keys(value).filter((key) => !propKeys.includes(key));
        if (record) {
            for (const key of extraKeys) {
                const keyResult = record.key.fromUnknown(key);
                if (!keyResult.ok) {
                    return err({
                        type: "ObjectWithRecord",
                        value,
                        reason: {
                            kind: "IndexKey",
                            key,
                            error: keyResult.error,
                        },
                    });
                }
                const valueResult = record.value.fromUnknown(value[key]);
                if (!valueResult.ok) {
                    return err({
                        type: "ObjectWithRecord",
                        value,
                        reason: {
                            kind: "IndexValue",
                            key,
                            error: valueResult.error,
                        },
                    });
                }
                result[keyResult.value] = valueResult.value;
            }
        }
        else if (extraKeys.length > 0) {
            return err({
                type: "Object",
                value,
                reason: { kind: "ExtraKeys", extraKeys },
            });
        }
        if (Object.keys(errors).length > 0) {
            return err({
                type: record ? "ObjectWithRecord" : "Object",
                value,
                reason: { kind: "Props", errors },
            });
        }
        return ok(result);
    };
    const fromParent = (value) => {
        const errors = {};
        const result = {};
        for (const key of propKeys) {
            if (!(key in value) && isOptionalType(props[key])) {
                continue;
            }
            const propResult = props[key].fromParent(value[key]);
            if (!propResult.ok) {
                errors[key] = propResult.error;
            }
            else {
                result[key] = propResult.value;
            }
        }
        if (record) {
            for (const [key, val] of Object.entries(value)) {
                if (!propKeys.includes(key)) {
                    const keyResult = record.key.fromParent(key);
                    if (!keyResult.ok) {
                        return err({
                            type: "ObjectWithRecord",
                            value,
                            reason: { kind: "IndexKey", key, error: keyResult.error },
                        });
                    }
                    const valueResult = record.value.fromParent(val);
                    if (!valueResult.ok) {
                        return err({
                            type: "ObjectWithRecord",
                            value,
                            reason: { kind: "IndexValue", key, error: valueResult.error },
                        });
                    }
                    result[keyResult.value] = valueResult.value;
                }
            }
        }
        if (Object.keys(errors).length > 0) {
            return err({
                type: record ? "ObjectWithRecord" : "Object",
                value,
                reason: { kind: "Props", errors },
            });
        }
        return ok(result);
    };
    return {
        ...createType(record ? "ObjectWithRecord" : "Object", {
            fromUnknown,
            fromParent,
        }),
        props,
        ...(record ? { record } : {}),
    };
    /* eslint-enable */
}
export const formatObjectError = (formatTypeError) => createTypeErrorFormatter((error) => {
    switch (error.reason.kind) {
        case "NotObject":
            return `Expected a plain object but received ${error.value}`;
        case "ExtraKeys":
            return `Unexpected extra keys: ${error.reason.extraKeys.join(", ")}`;
        case "Props": {
            const formattedErrors = Object.entries(error.reason.errors)
                .filter(([, error]) => error !== undefined)
                .map(([key, error]) => `- ${key}: ${formatTypeError(error)}`)
                .join("\n");
            return `Invalid object properties:\n${formattedErrors}`;
        }
    }
});
export const formatObjectWithRecordError = (formatTypeError) => createTypeErrorFormatter((error) => {
    switch (error.reason.kind) {
        case "NotObject":
            return `Expected an object, but received ${error.value}.`;
        case "Props":
            return formatObjectError(formatTypeError)({
                type: "Object",
                value: error.value,
                reason: { kind: "Props", errors: error.reason.errors },
            });
        case "IndexKey":
            return `Invalid index key ${error.reason.key}: ${formatTypeError(error.reason.error)}`;
        case "IndexValue":
            return `Invalid value at index key ${error.reason.key}: ${formatTypeError(error.reason.error)}`;
    }
});
export function union(...args) {
    /**
     * Good First Issue:
     *
     * 1. Optimize for microbenchmarks:
     *
     *    - Detect if all arguments are literals and generate a fast-check function.
     *    - This could significantly improve performance for unions of literals.
     * 2. Enhance tagged union support:
     *
     *    - Detect if all arguments are objects with the same property but different
     *         literal values (tagged unions).
     *    - Generate a specialized function to improve validation performance for such
     *         cases.
     */
    const members = args.map((arg) => (isType(arg) ? arg : literal(arg)));
    const fromUnknown = (value) => {
        const errors = [];
        for (const member of members) {
            const result = member.fromUnknown(value);
            if (result.ok)
                return result;
            errors.push(result.error);
        }
        return err({
            type: "Union",
            value,
            errors,
        });
    };
    return {
        ...createType("Union", {
            fromUnknown,
            fromParent: fromUnknown,
        }),
        members,
    };
}
export const formatUnionError = (formatTypeError) => createTypeErrorFormatter((error) => {
    const formattedErrors = error.errors
        .map((e, i) => `  ${i + 1}. ${formatTypeError(e)}`)
        .join("\n");
    return `Value ${error.value} does not match any member of the union.\nErrors:\n${formattedErrors}`;
});
export const isUnionType = (t) => t.name === "Union" && Array.isArray(t.members);
/**
 * Recursive {@link Type}.
 *
 * Recursive types can't be inferred, so we must define them using an interface
 * and `recursive` Type Factory that returns a {@link Type}.
 *
 * ### Example
 *
 * ```ts
 * interface Category {
 *   readonly name: string;
 *   readonly subcategories: ReadonlyArray<Category>;
 * }
 *
 * interface CategoryInput {
 *   readonly name: string;
 *   readonly subcategories: ReadonlyArray<CategoryInput>;
 * }
 *
 * type CategoryError = ObjectError<{
 *   readonly name: typeof String.Error;
 *   readonly subcategories: ArrayError<CategoryError>;
 * }>;
 *
 * const Category = recursive(
 *   (): Type<"Object", Category, CategoryInput, CategoryError> =>
 *     object({
 *       name: String,
 *       subcategories: array(Category),
 *     }),
 * );
 * ```
 *
 * @category Base Factories
 */
export const recursive = (create) => {
    let type;
    return {
        name: "Recursive",
        from: (value) => {
            type ??= create();
            return type.from(value);
        },
        fromUnknown: (value) => {
            type ??= create();
            return type.fromUnknown(value);
        },
        fromParent: (value) => {
            type ??= create();
            return type.fromParent(value);
        },
        is: (value) => {
            type ??= create();
            return type.is(value);
        },
        [EvoluTypeSymbol]: true,
        getParentType: () => {
            type ??= create();
            return type;
        },
    };
};
/**
 * `union(null, T)` {@link Type}.
 *
 * ### Example
 *
 * ```ts
 * const NullOrString = nullOr(String);
 * NullOrString.from("hello"); // ok("hello")
 * NullOrString.from(null); // ok(null)
 * NullOrString.from(42); // err(...)
 * ```
 *
 * @category Base Factories
 */
export const nullOr = (type) => union(Null, type);
/**
 * `union(undefined, T)` {@link Type}.
 *
 * ### Example
 *
 * ```ts
 * const UndefinedOrString = undefinedOr(String);
 * UndefinedOrString.from("world"); // ok("world")
 * UndefinedOrString.from(undefined); // ok()
 * UndefinedOrString.from(42); // err(...)
 * ```
 *
 * @category Base Factories
 */
export const undefinedOr = (type) => union(Undefined, type);
/**
 * `union(undefined, null, T)` {@link Type}.
 *
 * Learn more:
 * https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing
 *
 * ### Example
 *
 * ```ts
 * const NullishOrString = nullishOr(String);
 * NullishOrString.from("test"); // ok("test")
 * NullishOrString.from(null); // ok(null)
 * NullishOrString.from(undefined); // ok()
 * NullishOrString.from(42); // err(...)
 * ```
 *
 * @category Base Factories
 */
export const nullishOr = (type) => union(Undefined, Null, type);
/**
 * Tuple {@link Type}.
 *
 * Represents a tuple of specific Types.
 *
 * ### Example
 *
 * ```ts
 * const NameAndAge = tuple(NonEmptyTrimmedString, PositiveNumber);
 *
 * const result = NameAndAge.from(["Alice", 25]); // ok(["Alice", 25])
 * const error = NameAndAge.from(["Alice", -10]); // err
 * ```
 *
 * @category Base Factories
 */
export const tuple = (...elements) => {
    const fromUnknown = (value) => {
        if (!Array.isArray(value) || value.length !== elements.length) {
            return err({
                type: "Tuple",
                value,
                reason: { kind: "InvalidLength", expected: elements.length },
            });
        }
        const result = [];
        for (let i = 0; i < elements.length; i++) {
            const elementResult = elements[i].fromUnknown(value[i]);
            if (!elementResult.ok) {
                return err({
                    type: "Tuple",
                    value,
                    reason: {
                        kind: "Element",
                        index: i,
                        error: elementResult.error,
                    },
                });
            }
            result[i] = elementResult.value;
        }
        return ok(result);
    };
    const fromParent = (value) => {
        if (!Array.isArray(value) || value.length !== elements.length) {
            return err({
                type: "Tuple",
                value,
                reason: { kind: "InvalidLength", expected: elements.length },
            });
        }
        const result = [];
        for (let i = 0; i < elements.length; i++) {
            const elementResult = elements[i].fromParent(value[i]);
            if (!elementResult.ok) {
                return err({
                    type: "Tuple",
                    value,
                    reason: {
                        kind: "Element",
                        index: i,
                        error: elementResult.error,
                    },
                });
            }
            result.push(elementResult.value);
        }
        return ok(result);
    };
    return {
        ...createType("Tuple", {
            fromUnknown,
            fromParent,
        }),
        elements,
    };
};
export const formatTupleError = (formatTypeError) => createTypeErrorFormatter((error) => {
    switch (error.reason.kind) {
        case "InvalidLength":
            return `Expected a tuple of length ${error.reason.expected}, but received ${error.value}.`;
        case "Element":
            return `Invalid element at index ${error.reason.index}:\n  ${formatTypeError(error.reason.error)}`;
    }
});
/**
 * 64-bit signed integer.
 *
 * `Int64` represents a `BigInt` constrained to a 64-bit signed integer range,
 * which is useful for platforms that do not support the `bigint` type, such as
 * SQLite.
 *
 * Because SQLite lacks a dedicated `bigint` type, it may return `number` or
 * 'Int64` depending on the stored value or even a wrong value if a platform
 * wrapper does not support it. A workaround for SQLite is to insert 'Int64`
 * serialized as a string (SQLite will convert it to int) and manually cast the
 * result to a string in SQL query and then to `Int64` in JS.
 *
 * https://www.sqlite.org/c3ref/int64.html
 *
 * @category Number
 */
export const Int64 = brand("Int64", BigInt, (value) => value >= -9223372036854775808n && value <= 9223372036854775807n
    ? ok(value)
    : err({ type: "Int64", value }));
export const formatInt64Error = createTypeErrorFormatter((error) => `The value ${error.value} is not a valid 64-bit signed integer (Int64).`);
/**
 * Stringified {@link Int64}.
 *
 * @category String
 */
export const Int64String = brand("Int64", NonEmptyTrimmedString, (value) => trySync(() => {
    const maybeInt = globalThis.BigInt(value);
    Int64.orThrow(maybeInt);
    return value;
}, () => ({ type: "Int64String", value })));
export const formatInt64StringError = createTypeErrorFormatter((error) => `The value ${error.value} is not a valid Int64 string.`);
/**
 * JSON-compatible value: string, {@link FiniteNumber}, boolean, null,
 * {@link JsonArray}, or {@link JsonObject}.
 *
 * @category Base Types
 */
export const JsonValue = recursive(() => union(String, FiniteNumber, Boolean, Null, JsonArray, JsonObject));
/**
 * JSON-compatible array of {@link JsonValue} elements.
 *
 * @category Array
 */
export const JsonArray = array(JsonValue);
/**
 * JSON-compatible object with string keys and {@link JsonValue} values.
 *
 * @category Object
 */
export const JsonObject = record(String, JsonValue);
export const parseJson = (value) => trySync(() => JSON.parse(value), (error) => ({
    type: `Json`,
    value,
    message: globalThis.String(error),
}));
/**
 * JSON-string {@link Type}.
 *
 * ### Example
 *
 * ```ts
 * const result = Json.from('{"key":"value"}'); // ok
 * const error = Json.from("invalid json"); // err
 * ```
 *
 * @category String
 */
export const Json = brand("Json", String, (value) => {
    const result = parseJson(value);
    if (!result.ok)
        return result;
    return ok(value);
});
export const formatJsonError = createTypeErrorFormatter((error) => `Invalid JSON: ${error.value}. Error: ${error.message}`);
export const jsonValueToJson = (value) => JSON.stringify(value);
export const jsonToJsonValue = (value) => JSON.parse(value);
/**
 * Creates a branded JSON string {@link Type} and type-safe conversion functions
 * for a given Type.
 *
 * This factory creates:
 *
 * 1. A branded string Type that validates JSON parsing and structural conformity
 * 2. A serialization function (Type → branded JSON string)
 * 3. A parsing function (branded JSON string → Type, skipping validation)
 *
 * Optimized for Evolu's SQLite workflow where we store typed JSON strings and
 * need type-safe conversions without double parsing.
 *
 * ### Example
 *
 * ```ts
 * const Person = object({
 *   name: NonEmptyString100,
 *   age: FiniteNumber,
 * });
 * type Person = typeof Person.Type;
 *
 * const [PersonJson, personToPersonJson, personJsonToPerson] = json(
 *   Person,
 *   "PersonJson",
 * );
 * // string & Brand<"PersonJson">
 * type PersonJson = typeof PersonJson.Type;
 *
 * // Usage:
 * const person: Person = { name: "Alice", age: 30 };
 * const jsonString = personToPersonJson(person); // PersonJson
 * const backToPerson = personJsonToPerson(jsonString); // Person
 * ```
 */
export const json = (type, name) => {
    const BrandedJsonType = brand(name, String, (value) => {
        const parseResult = parseJson(value);
        if (!parseResult.ok)
            return parseResult;
        const validationResult = type.fromUnknown(parseResult.value);
        if (!validationResult.ok)
            return validationResult;
        return ok(value);
    });
    return [
        BrandedJsonType,
        jsonValueToJson,
        jsonToJsonValue,
    ];
};
/**
 * Optional {@link Type}.
 *
 * Marks a `Type` as **optional**, meaning:
 *
 * - If the value is **present**, it must match the given `Type`.
 * - If the value is **absent**, it is **not included** in the final object.
 *
 * This is different from {@link undefinedOr}, which allows explicit `undefined`
 * but **still requires the key to exist**.
 *
 * ### Example:
 *
 * ```ts
 * const Todo = object({
 *   id: TodoId,
 *   title: NonEmptyString1000,
 *   isCompleted: optional(SqliteBoolean),
 * });
 * ```
 */
export const optional = (type) => ({
    ...createType("Optional", {
        fromUnknown: type.fromUnknown,
        fromParent: type.fromParent,
    }),
    parent: type,
});
/** Determines if a given type is an {@link OptionalType}. */
export const isOptionalType = (x) => typeof x === "object" && x != null && "name" in x && x.name === "Optional";
/**
 * Creates a partial object type where all properties are optional.
 *
 * This is useful when we want to validate an object in which none of the keys
 * are required, but if they are present they must conform to their
 * corresponding Types.
 *
 * ### Example
 *
 * ```ts
 * const PartialUser = partial({
 *   name: NonEmptyString,
 *   age: PositiveNumber,
 * });
 *
 * // Valid: an empty object is accepted
 * PartialUser.from({});
 *
 * // Valid: when provided, the properties must validate correctly
 * PartialUser.from({ name: "Alice" });
 *
 * // Invalid: if a property is present but fails validation it returns an error
 * PartialUser.from({ age: -5 });
 * ```
 *
 * @category Object
 */
export const partial = (props) => {
    const optionalProps = {};
    for (const key in props) {
        if (Object.prototype.hasOwnProperty.call(props, key)) {
            optionalProps[key] = optional(props[key]);
        }
    }
    return object(optionalProps);
};
/**
 * Converts each “nullable” property (a union that includes {@link Null}) into an
 * {@link optional} property. This means consumers can omit the property
 * entirely, or set it to `null`, or set it to the non-null member of the
 * union.
 *
 * @category Object
 */
export const nullableToOptional = (props) => {
    const transformedProps = {};
    for (const key in props) {
        const type = props[key];
        if (isUnionType(type)) {
            const hasNull = type.members.some((m) => m === Null);
            if (hasNull) {
                transformedProps[key] = optional(type);
                continue;
            }
        }
        transformedProps[key] = type;
    }
    return object(transformedProps);
};
/**
 * Create a new `object` {@link Type} by omitting some keys.
 *
 * @category Object
 */
export function omit(objectType, ...keys) {
    const newProps = {};
    for (const key in objectType.props) {
        if (!keys.includes(key)) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
            newProps[key] = objectType.props[key];
        }
    }
    return object(newProps);
}
export const maxMutationSize = 655360;
/**
 * Evolu has to limit the maximum mutation size. Otherwise, sync couldn't use
 * the `maxProtocolMessageRangesSize`. The max size is 640KB in bytes, measured
 * via MessagePack. Evolu Protocol DbChange will be smaller thanks to various
 * optimizations.
 */
export const validMutationSize = (type) => brand("ValidMutationSize", type, (value) => pack(value).byteLength <= maxMutationSize
    ? ok(value)
    : err({ type: "ValidMutationSize", value }));
export const formatValidMutationSizeError = createTypeErrorFormatter((error) => `The mutation size exceeds the maximum limit of ${maxMutationSize} bytes. The provided mutation has a size of ${pack(error.value).byteLength} bytes.`);
/**
 * Formats Evolu Type errors into user-friendly messages.
 *
 * Evolu Type typed errors ensure every error type must have a formatter.
 * TypeScript enforces this at compile-time, preventing unhandled validation
 * errors from reaching users.
 *
 * The `createFormatTypeError` function handles both built-in {@link TypeErrors}
 * and custom errors, and lets us override default formatting for specific
 * errors.
 *
 * ### Example
 *
 * ```ts
 * const formatTypeError = createFormatTypeError<
 *   MinLengthError | MaxLengthError
 * >((error): string => {
 *   switch (error.type) {
 *     case "MinLength":
 *       return `Text must be at least ${error.min} character${error.min === 1 ? "" : "s"} long`;
 *     case "MaxLength":
 *       return `Text is too long (maximum ${error.max} characters)`;
 *   }
 * });
 * ```
 *
 * Alternatively, write a custom formatter from scratch without using
 * `createFormatTypeError`. This gives us full control over error formatting:
 *
 * ```ts
 * const Person = object({
 *   name: NonEmptyTrimmedString100,
 *   age: optional(PositiveInt),
 * });
 *
 * // Define only the errors actually used by Person Type
 * type PersonErrors =
 *   | StringError
 *   | MaxLengthError
 *   | MinLengthError
 *   | TrimmedError
 *   | PositiveError
 *   | NonNegativeError
 *   | IntError
 *   | NumberError
 *   | ObjectError<Record<string, PersonErrors>>;
 *
 * const formatTypeError: TypeErrorFormatter<PersonErrors> = (error) => {
 *   switch (error.type) {
 *     case "String":
 *       return formatStringError(error);
 *     case "Number":
 *       return "Must be a number";
 *     case "MinLength":
 *       return `Must be at least ${error.min} characters`;
 *     case "MaxLength":
 *       return `Cannot exceed ${error.max} characters`;
 *     case "Trimmed":
 *       return "Cannot have leading or trailing spaces";
 *     case "Positive":
 *       return "Must be a positive number";
 *     case "NonNegative":
 *       return "Must be zero or positive";
 *     case "Int":
 *       return "Must be an integer";
 *     case "Object": {
 *       if (error.reason.kind === "NotObject") return "Must be an object";
 *       if (error.reason.kind === "ExtraKeys")
 *         return "Contains unexpected fields";
 *       const firstError = Object.values(error.reason.errors).find(
 *         (e) => e !== undefined,
 *       )!;
 *       return formatTypeError(firstError);
 *     }
 *   }
 * };
 * ```
 *
 * @category Utilities
 */
export const createFormatTypeError = (extraFormatter) => {
    const formatTypeError = (error) => {
        const extraMessage = extraFormatter?.(error);
        if (extraMessage != null)
            return extraMessage;
        error = error;
        switch (error.type) {
            case "String":
                return formatStringError(error);
            case "Number":
                return formatNumberError(error);
            case "BigInt":
                return formatBigIntError(error);
            case "Boolean":
                return formatBooleanError(error);
            case "Undefined":
                return formatUndefinedError(error);
            case "Null":
                return formatNullError(error);
            case "Function":
                return formatFunctionError(error);
            case "Uint8Array":
                return formatUint8ArrayError(error);
            case "InstanceOf":
                return formatInstanceOfError(error);
            case "EvoluType":
                return formatIsTypeError(error);
            case "CurrencyCode":
                return formatCurrencyCodeError(error);
            case "DateIso":
                return formatDateIsoError(error);
            case "Trimmed":
                return formatTrimmedError(error);
            case "MinLength":
                return formatMinLengthError(error);
            case "MaxLength":
                return formatMaxLengthError(error);
            case "Length":
                return formatLengthError(error);
            case "Mnemonic":
                return formatMnemonicError(error);
            case "Regex":
                return formatRegexError(error);
            case "Id":
                return formatIdError(error);
            case "TableId":
                return formatTableIdError(error);
            case "Positive":
                return formatPositiveError(error);
            case "Negative":
                return formatNegativeError(error);
            case "NonPositive":
                return formatNonPositiveError(error);
            case "NonNegative":
                return formatNonNegativeError(error);
            case "Int":
                return formatIntError(error);
            case "GreaterThan":
                return formatGreaterThanError(error);
            case "LessThan":
                return formatLessThanError(error);
            case "GreaterThanOrEqualTo":
                return formatGreaterThanOrEqualToError(error);
            case "LessThanOrEqualTo":
                return formatLessThanOrEqualToError(error);
            case "NonNaN":
                return formatNonNaNError(error);
            case "Finite":
                return formatFiniteError(error);
            case "MultipleOf":
                return formatMultipleOfError(error);
            case "Between":
                return formatBetweenError(error);
            case "Literal":
                return formatLiteralError(error);
            case "Int64":
                return formatInt64Error(error);
            case "Int64String":
                return formatInt64StringError(error);
            case "Json":
                return formatJsonError(error);
            case "ValidMutationSize":
                return formatValidMutationSizeError(error);
            // Composite Types
            case "SimplePassword":
                return formatSimplePasswordError(formatTypeError)(error);
            case "Array":
                return formatArrayError(formatTypeError)(error);
            case "Set":
                return formatSetError(formatTypeError)(error);
            case "Record":
                return formatRecordError(formatTypeError)(error);
            case "Object":
                return formatObjectError(formatTypeError)(error);
            case "ObjectWithRecord":
                return formatObjectWithRecordError(formatTypeError)(error);
            case "Union":
                return formatUnionError(formatTypeError)(error);
            case "Tuple":
                return formatTupleError(formatTypeError)(error);
            default: {
                // Fallback for unknown error types
                const unknownError = error;
                return `A value ${safelyStringifyUnknownValue(unknownError.value)} is not valid for type ${unknownError.type}.`;
            }
        }
    };
    return formatTypeError;
};
/**
 * Converts an Evolu {@link TypeError} to Standard Schema V1 issues format.
 *
 * This function recursively converts Evolu's typed errors into the Standard
 * Schema issue format with proper path tracking for nested structures.
 *
 * @category Utilities
 */
export const typeErrorToStandardSchemaIssues = (error, formatTypeError, path = []) => {
    if (error.type === "Array") {
        const arrayError = error;
        if (arrayError.reason.kind === "NotArray") {
            return [{ message: formatTypeError(error), path }];
        }
        return typeErrorToStandardSchemaIssues(arrayError.reason.error, formatTypeError, [...path, arrayError.reason.index]);
    }
    if (error.type === "Set") {
        const setError = error;
        if (setError.reason.kind === "NotSet") {
            return [{ message: formatTypeError(error), path }];
        }
        return typeErrorToStandardSchemaIssues(setError.reason.error, formatTypeError, [...path, setError.reason.index]);
    }
    if (error.type === "Object") {
        const objectError = error;
        if (objectError.reason.kind === "NotObject" ||
            objectError.reason.kind === "ExtraKeys") {
            return [{ message: formatTypeError(error), path }];
        }
        const issues = [];
        for (const [key, propError] of Object.entries(objectError.reason.errors)) {
            issues.push(...typeErrorToStandardSchemaIssues(propError, formatTypeError, [...path, key]));
        }
        return issues;
    }
    if (error.type === "ObjectWithRecord") {
        const objectWithRecordError = error;
        if (objectWithRecordError.reason.kind === "NotObject") {
            return [{ message: formatTypeError(error), path }];
        }
        if (objectWithRecordError.reason.kind === "IndexKey" ||
            objectWithRecordError.reason.kind === "IndexValue") {
            return typeErrorToStandardSchemaIssues(objectWithRecordError.reason.error, formatTypeError, [...path, objectWithRecordError.reason.key]);
        }
        const issues = [];
        for (const [key, propError] of Object.entries(objectWithRecordError.reason.errors)) {
            issues.push(...typeErrorToStandardSchemaIssues(propError, formatTypeError, [...path, key]));
        }
        return issues;
    }
    if (error.type === "Record") {
        const recordError = error;
        if (recordError.reason.kind === "NotRecord") {
            return [{ message: formatTypeError(error), path }];
        }
        return typeErrorToStandardSchemaIssues(recordError.reason.error, formatTypeError, [...path, recordError.reason.key]);
    }
    if (error.type === "Tuple") {
        const tupleError = error;
        if (tupleError.reason.kind === "InvalidLength") {
            return [{ message: formatTypeError(error), path }];
        }
        return typeErrorToStandardSchemaIssues(tupleError.reason.error, formatTypeError, [...path, tupleError.reason.index]);
    }
    if (error.type === "Union") {
        const unionError = error;
        return unionError.errors.flatMap((err) => typeErrorToStandardSchemaIssues(err, formatTypeError, path));
    }
    if (error.type === "Brand") {
        const brandError = error;
        if ("parentError" in brandError) {
            return typeErrorToStandardSchemaIssues(brandError.parentError, formatTypeError, path);
        }
        return [{ message: formatTypeError(error), path }];
    }
    return [{ message: formatTypeError(error), path }];
};
/**
 * Shared formatter cache for Standard Schema integration - avoids circular
 * dependency by lazily creating the formatter on first use rather than during
 * module initialization.
 */
let cachedStandardSchemaFormatTypeError;

import { Result } from "./Result.js";
/**
 * A generic resource manager that handles reference counting and delayed
 * disposal of shared resources. Useful for managing expensive resources like
 * WebSocket connections that need to be shared among multiple consumers.
 */
export interface Resources<TResource extends Disposable, TResourceKey extends string, TResourceConfig, TConsumer, TConsumerId extends string> extends Disposable {
    /**
     * Adds a consumer to resources, creating them if necessary. Increments
     * reference counts for existing consumer-resource pairs.
     */
    readonly addConsumer: (consumer: TConsumer, resourceConfigs: ReadonlyArray<TResourceConfig>) => void;
    /**
     * Removes a consumer from resources. Decrements reference counts and
     * schedules disposal when no consumers remain.
     *
     * Returns an error if the resource doesn't exist or if the consumer wasn't
     * added to the resource.
     */
    readonly removeConsumer: (consumer: TConsumer, resourceConfigs: ReadonlyArray<TResourceConfig>) => Result<void, ResourceNotFoundError<TResourceKey> | ConsumerNotFoundError<TConsumerId, TResourceKey>>;
    /** Gets the resource for the specified key, or null if it doesn't exist. */
    readonly getResource: (key: TResourceKey) => TResource | null;
    /** Gets all consumer IDs currently using the specified resource key. */
    readonly getConsumersForResource: (key: TResourceKey) => ReadonlyArray<TConsumerId>;
    /** Checks if a consumer is currently using any resources. */
    readonly hasConsumerAnyResource: (consumer: TConsumer) => boolean;
    /**
     * Gets the consumer for the specified consumer ID, or null if not found or
     * not using any resources.
     */
    readonly getConsumer: (consumerId: TConsumerId) => TConsumer | null;
}
/** Error when trying to remove a consumer from a resource that doesn't exist. */
export interface ResourceNotFoundError<TResourceKey extends string = string> {
    readonly type: "ResourceNotFoundError";
    readonly resourceKey: TResourceKey;
}
/** Error when trying to remove a consumer that wasn't added to a resource. */
export interface ConsumerNotFoundError<TConsumerId extends string = string, TResourceKey extends string = string> {
    readonly type: "ConsumerNotFoundError";
    readonly consumerId: TConsumerId;
    readonly resourceKey: TResourceKey;
}
export interface ResourcesConfig<TResource extends Disposable, TResourceKey extends string, TResourceConfig, TConsumer, TConsumerId extends string> {
    /** Creates a new resource for the given config. */
    readonly createResource: (config: TResourceConfig) => TResource;
    /** Extracts a unique key from a resource config for deduplication. */
    readonly getResourceKey: (config: TResourceConfig) => TResourceKey;
    /** Extracts a unique identifier from a consumer for reference counting. */
    readonly getConsumerId: (consumer: TConsumer) => TConsumerId;
    /**
     * Delay in milliseconds before disposing unused resources. Helps avoid
     * resource churn during rapid add/remove cycles. Defaults to 100ms.
     */
    readonly disposalDelay?: number;
    /**
     * Called when a consumer is added to a resource for the first time. This
     * happens when the consumer's reference count goes from 0 to 1 for this
     * resource.
     */
    readonly onConsumerAdded?: (consumer: TConsumer, resource: TResource, resourceKey: TResourceKey) => void;
    /**
     * Called when a consumer is completely removed from a resource. This happens
     * when the consumer's reference count goes from 1 to 0 for this resource.
     */
    readonly onConsumerRemoved?: (consumer: TConsumer, resource: TResource, resourceKey: TResourceKey) => void;
}
/**
 * Creates {@link Resources}.
 *
 * This tracks which consumers are using which resources and maintains reference
 * counts to know when it's safe to dispose resources. Resources are created
 * on-demand and disposed with a configurable delay to avoid churn.
 *
 * ### Example Usage
 *
 * ```ts
 * // WebSocket connections
 * interface WebSocketConfig {
 *   readonly url: WebSocketUrl;
 * }
 *
 * type WebSocketUrl = string & Brand<"WebSocketUrl">;
 * type UserId = string & Brand<"UserId">;
 *
 * const webSockets = createResources<
 *   WebSocket,
 *   WebSocketUrl,
 *   WebSocketConfig,
 *   User,
 *   UserId
 * >({
 *   createResource: (config) => new WebSocket(config.url),
 *   getResourceKey: (config) => config.url,
 *   getConsumerId: (user) => user.id,
 *   disposalDelay: 1000,
 * });
 *
 * // Add users to WebSocket connections
 * webSockets.addConsumer(user1, [
 *   { url: "ws://server1.com" as WebSocketUrl },
 *   { url: "ws://server2.com" as WebSocketUrl },
 * ]);
 * webSockets.addConsumer(user2, [
 *   { url: "ws://server1.com" as WebSocketUrl },
 * ]);
 *
 * // Remove users - server1 stays alive (user2 still using it)
 * webSockets.removeConsumer(user1, [
 *   { url: "ws://server1.com" as WebSocketUrl },
 *   { url: "ws://server2.com" as WebSocketUrl },
 * ]);
 *
 * // server2 gets disposed after delay, server1 stays alive
 * ```
 */
export declare const createResources: <TResource extends Disposable, TResourceKey extends string, TResourceConfig, TConsumer, TConsumerId extends string>(config: ResourcesConfig<TResource, TResourceKey, TResourceConfig, TConsumer, TConsumerId>) => Resources<TResource, TResourceKey, TResourceConfig, TConsumer, TConsumerId>;
//# sourceMappingURL=Resources.d.ts.map
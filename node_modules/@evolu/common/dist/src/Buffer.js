import { NonNegativeInt } from "./Type.js";
export { bytesToHex, bytesToUtf8, concatBytes, hexToBytes, utf8ToBytes, } from "@noble/ciphers/utils.js";
/**
 * Custom error for {@link Buffer}-related failures like premature end of data.
 * Provides better stack traces for debugging binary protocol issues.
 */
export class BufferError extends Error {
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}
/** Creates a {@link Buffer} for efficient byte operations. */
export const createBuffer = (arrayLike) => {
    let value = arrayLike
        ? new globalThis.Uint8Array(arrayLike)
        : new globalThis.Uint8Array(512);
    let length = NonNegativeInt.orThrow(arrayLike ? arrayLike.length : 0);
    const buffer = {
        getCapacity: () => NonNegativeInt.orThrow(value.length),
        getLength: () => length,
        extend: (arg) => {
            const targetSize = length + arg.length;
            if (value.length < targetSize) {
                const oldValue = value;
                const newCapacity = Math.max(value.length * 2, targetSize);
                value = new globalThis.Uint8Array(newCapacity);
                value.set(oldValue);
            }
            value.set(arg, length);
            length = NonNegativeInt.orThrow(length + arg.length);
        },
        shift: () => {
            if (length === 0) {
                throw new BufferError("Buffer parse ended prematurely");
            }
            const first = value[0];
            value = value.subarray(1);
            length--;
            return NonNegativeInt.orThrow(first);
        },
        shiftN: (n) => {
            if (length < n) {
                throw new BufferError("Buffer parse ended prematurely");
            }
            const subarray = value.subarray(0, n);
            value = value.subarray(n);
            length = NonNegativeInt.orThrow(length - n);
            return subarray;
        },
        truncate: (newLength) => {
            if (newLength > length) {
                throw new BufferError("Cannot truncate to a length greater than current");
            }
            length = newLength;
        },
        reset: () => {
            length = NonNegativeInt.orThrow(0);
        },
        unwrap: () => value.subarray(0, length),
    };
    return buffer;
};

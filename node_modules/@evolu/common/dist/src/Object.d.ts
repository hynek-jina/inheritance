/**
 * Checks if a value is a plain object (e.g., created with `{}` or `Object`).
 *
 * ### Example
 *
 * ```ts
 * isPlainObject({}); // true
 * isPlainObject(new Date()); // false
 * isPlainObject([]); // false
 * isPlainObject(null); // false
 * ```
 */
export declare const isPlainObject: (value: unknown) => value is Record<string, unknown>;
/**
 * A read-only `Record<K, V>` with `K extends keyof any` to preserve branded key
 * types (e.g., in {@link mapObject}).
 */
export type ReadonlyRecord<K extends keyof any, V> = Readonly<Record<K, V>>;
type StringKeyOf<T> = Extract<keyof T, string>;
/**
 * Like `Object.entries` but preserves branded keys.
 *
 * ### Example
 *
 * ```ts
 * type UserId = string & { readonly __brand: "UserId" };
 * const users = createRecord<UserId, string>();
 * const entries = objectToEntries(users); // [UserId, string][]
 * ```
 */
export declare const objectToEntries: <T extends Record<string, any>>(record: T) => ReadonlyArray<[StringKeyOf<T>, T[StringKeyOf<T>]]>;
/**
 * Maps a `ReadonlyRecord<K, V>` to a new `ReadonlyRecord<K, U>`, preserving
 * branded key types (e.g., `type Id = 'id' & string`) lost by `Object.entries`.
 * Uses `K extends string` for precision.
 */
export declare const mapObject: <K extends string, V, U>(record: ReadonlyRecord<K, V>, fn: (value: V, key: K) => U) => ReadonlyRecord<K, U>;
/** Conditionally excludes a property from an object. */
export declare const excludeProp: <T extends object, K extends keyof T>(obj: T, prop: K, condition?: boolean) => typeof condition extends true ? T : Omit<T, K>;
/**
 * Creates a prototype-less object typed as `Record<K, V>`.
 *
 * Use this function when you need a plain record without a prototype chain
 * (e.g. when keys are controlled by external sources) to avoid prototype
 * pollution and accidental collisions with properties like `__proto__`.
 *
 * Example:
 *
 * ```ts
 * const values = createRecord<string, SqliteValue>();
 * values["__proto__"] = someValue; // safe, no prototype pollution
 * ```
 */
export declare const createRecord: <K extends string = string, V = unknown>() => Record<K, V>;
/**
 * Safely gets a property from a record, returning `undefined` if the key
 * doesn't exist.
 *
 * TypeScript's `Record<K, V>` type assumes all keys exist, but at runtime
 * accessing a non-existent key returns `undefined`. This helper provides proper
 * typing for that case without needing a type assertion.
 *
 * ### Example
 *
 * ```ts
 * const users: Record<string, User> = { alice: { name: "Alice" } };
 * const user = getProperty(users, "bob"); // User | undefined
 * ```
 */
export declare const getProperty: <K extends string, V>(record: ReadonlyRecord<K, V>, key: string) => V | undefined;
export {};
//# sourceMappingURL=Object.d.ts.map
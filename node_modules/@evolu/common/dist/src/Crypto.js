/**
 * Cryptographic utilities
 *
 * Type-safe cryptographic operations including random number generation, SLIP21
 * key derivation, XChaCha20-Poly1305 symmetric encryption, PADMÉ padding, and
 * timing-safe comparisons.
 *
 * @module
 */
import { xchacha20poly1305 } from "@noble/ciphers/chacha.js";
import { hmac } from "@noble/hashes/hmac.js";
import { sha512 } from "@noble/hashes/sha2.js";
import { randomBytes, utf8ToBytes } from "@noble/hashes/utils.js";
import { trySync } from "./Result.js";
import { brand, length, NonNegativeInt, Uint8Array } from "./Type.js";
const Entropy = brand("Entropy", Uint8Array);
export const Entropy16 = length(16)(Entropy);
export const Entropy32 = length(32)(Entropy);
export const Entropy64 = length(64)(Entropy);
export const createRandomBytes = () => ({
    create: randomBytes,
});
/**
 * SLIP21.
 *
 * https://github.com/satoshilabs/slips/blob/master/slip-0021.md
 */
export const createSlip21 = (seed, path) => {
    let currentNode = hmac(sha512, utf8ToBytes("Symmetric key seed"), seed);
    for (const element of path) {
        const label = typeof element === "number" ? element.toString() : element;
        currentNode = deriveSlip21Node(label, currentNode);
    }
    return currentNode.slice(32, 64);
};
/**
 * Derives a single node in the SLIP-21 hierarchical key derivation.
 *
 * @see {@link createSlip21}
 */
export const deriveSlip21Node = (label, parentNode) => {
    const labelBytes = utf8ToBytes(label);
    const message = new globalThis.Uint8Array(labelBytes.byteLength + 1);
    message[0] = 0;
    message.set(labelBytes, 1);
    return hmac(sha512, parentNode.slice(0, 32), message);
};
/** The encryption key for {@link SymmetricCrypto}. */
export const EncryptionKey = brand("EncryptionKey", Entropy32);
/**
 * XChaCha20-Poly1305 encryption
 *
 * https://github.com/paulmillr/noble-ciphers?tab=readme-ov-file#which-cipher-should-i-pick
 */
export const createSymmetricCrypto = (deps) => {
    const nonceLength = NonNegativeInt.orThrow(24);
    const symmetricCrypto = {
        nonceLength,
        encrypt: (plaintext, encryptionKey) => {
            const nonce = deps.randomBytes.create(nonceLength);
            const ciphertext = xchacha20poly1305(encryptionKey, nonce).encrypt(plaintext);
            return { nonce, ciphertext };
        },
        decrypt: (ciphertext, encryptionKey, nonce) => trySync(() => xchacha20poly1305(encryptionKey, nonce).decrypt(ciphertext), (error) => ({
            type: "SymmetricCryptoDecryptError",
            error,
        })),
    };
    return symmetricCrypto;
};
/**
 * Returns the PADMÉ padded length for a given input length.
 *
 * PADMÉ limits information leakage about the length of the plain-text for a
 * wide range of encrypted data sizes.
 *
 * See the PURBs paper for details: https://bford.info/pub/sec/purb.pdf
 */
export const createPadmePaddedLength = (length) => {
    if (length <= 0)
        return NonNegativeInt.orThrow(0);
    const e = 31 - Math.clz32(length >>> 0);
    const s = 32 - Math.clz32(e >>> 0);
    const z = Math.max(0, e - s);
    const mask = (1 << z) - 1;
    return NonNegativeInt.orThrow((length + mask) & ~mask);
};
/** Creates a PADMÉ padding array of zeros for the given input length. */
export const createPadmePadding = (length) => {
    const paddedLength = createPadmePaddedLength(length);
    const paddingLength = NonNegativeInt.orThrow(paddedLength - length);
    return new globalThis.Uint8Array(paddingLength);
};

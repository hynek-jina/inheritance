/**
 * Bidirectional relation between two types.
 *
 * Why useful:
 *
 * - Provides O(1) (amortized) lookup in both directions (A → B and B → A) without
 *   maintaining two maps manually and risking them diverging.
 * - Natural fit for symmetric associations such as ownerId ↔ WebSocket, tag ↔
 *   item, user ↔ role, entity ↔ subscription where both directions are
 *   frequently queried.
 * - Supports fast membership tests via `has`, `hasA`, and `hasB`.
 * - Iteration helpers (`forEach`, iterator) allow treating the structure as a set
 *   of pairs when needed.
 *
 * Complexity:
 *
 * - `add` / `remove` / `has*` / `get*` each perform a constant number of Map/Set
 *   operations (O(1) expected).
 * - `deleteA` and `deleteB` are O(d) where d is the number of associated elements
 *   (the degree). This is optimal because every associated pair must be touched
 *   once.
 *
 * Object identity:
 *
 * - Elements are compared by reference (standard Map / Set semantics). Structural
 *   hashing of objects in JavaScript is non-trivial, can be expensive, and
 *   collision-prone if done naively. Prefer using stable primitive identifiers
 *   (ids, strings) instead of attempting to hash full object structures.
 * - If structural equivalence is truly required, wrap objects in an adapter that
 *   supplies a canonical hash/id and stores/retrieves the original objects
 *   separately. This is a rare need; avoid unless you have clear requirements.
 */
export interface Relation<A, B> {
    /**
     * Adds a pair to the relation. Returns true if the pair was newly added,
     * false if it already existed.
     */
    readonly add: (a: A, b: B) => boolean;
    /**
     * Removes a specific pair from the relation. Returns true if the pair existed
     * and was removed, false if it was not present.
     */
    readonly remove: (a: A, b: B) => boolean;
    /** Gets all B elements related to an A element. */
    readonly getB: (a: A) => ReadonlySet<B> | undefined;
    /** Gets all A elements related to a B element. */
    readonly getA: (b: B) => ReadonlySet<A> | undefined;
    /**
     * Iterates over each pair in the relation (in insertion order of A elements,
     * then B elements per A).
     */
    readonly forEach: (callback: (a: A, b: B) => void) => void;
    /**
     * Iterator over all pairs enabling for..of and spread. Yields readonly [a, b]
     * tuples.
     */
    readonly [Symbol.iterator]: () => IterableIterator<readonly [A, B]>;
    /** Checks if a specific pair exists in the relation. */
    readonly has: (a: A, b: B) => boolean;
    /** Checks if an A element exists in the relation. */
    readonly hasA: (a: A) => boolean;
    /** Checks if a B element exists in the relation. */
    readonly hasB: (b: B) => boolean;
    /** Deletes all pairs containing the given A element. */
    readonly deleteA: (a: A) => boolean;
    /** Deletes all pairs containing the given B element. */
    readonly deleteB: (b: B) => boolean;
    /** Clears all pairs from the relation. */
    readonly clear: () => void;
    /** Number of distinct A elements currently present. */
    readonly aCount: () => number;
    /** Number of distinct B elements currently present. */
    readonly bCount: () => number;
    /** Number of pairs currently stored in the relation. */
    readonly size: () => number;
}
/** Creates a {@link Relation}. */
export declare const createRelation: <A, B>() => Relation<A, B>;
//# sourceMappingURL=Relation.d.ts.map
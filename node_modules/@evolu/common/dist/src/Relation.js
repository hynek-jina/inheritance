import { assert } from "./Assert.js";
/** Creates a {@link Relation}. */
export const createRelation = () => {
    const aToB = new Map();
    const bToA = new Map();
    let sizeInternal = 0;
    const relation = {
        add(a, b) {
            let bSet = aToB.get(a);
            if (bSet?.has(b))
                return false;
            if (!bSet) {
                bSet = new Set();
                aToB.set(a, bSet);
            }
            bSet.add(b);
            let aSet = bToA.get(b);
            if (!aSet) {
                aSet = new Set();
                bToA.set(b, aSet);
            }
            aSet.add(a);
            sizeInternal++;
            return true;
        },
        remove(a, b) {
            const bSet = aToB.get(a);
            if (!bSet?.has(b))
                return false;
            bSet.delete(b);
            if (bSet.size === 0) {
                aToB.delete(a);
            }
            const aSet = bToA.get(b);
            assert(aSet, "Relation mapping inconsistency");
            aSet.delete(a);
            if (aSet.size === 0) {
                bToA.delete(b);
            }
            sizeInternal--;
            return true;
        },
        getB(a) {
            return aToB.get(a);
        },
        getA(b) {
            return bToA.get(b);
        },
        forEach(callback) {
            for (const [a, bSet] of aToB) {
                for (const b of bSet)
                    callback(a, b);
            }
        },
        [Symbol.iterator]() {
            const iterator = function* () {
                for (const [a, bSet] of aToB) {
                    for (const b of bSet) {
                        yield [a, b];
                    }
                }
            };
            return iterator();
        },
        has(a, b) {
            const bSet = aToB.get(a);
            return bSet?.has(b) ?? false;
        },
        hasA(a) {
            return aToB.has(a);
        },
        hasB(b) {
            return bToA.has(b);
        },
        deleteA(a) {
            const bSet = aToB.get(a);
            if (!bSet)
                return false;
            const removed = bSet.size;
            for (const b of bSet) {
                const aSet = bToA.get(b);
                if (aSet) {
                    aSet.delete(a);
                    if (aSet.size === 0) {
                        bToA.delete(b);
                    }
                }
            }
            aToB.delete(a);
            sizeInternal -= removed;
            return true;
        },
        deleteB(b) {
            const aSet = bToA.get(b);
            if (!aSet)
                return false;
            const removed = aSet.size;
            for (const a of aSet) {
                const bSet = aToB.get(a);
                if (bSet) {
                    bSet.delete(b);
                    if (bSet.size === 0) {
                        aToB.delete(a);
                    }
                }
            }
            bToA.delete(b);
            sizeInternal -= removed;
            return true;
        },
        clear() {
            aToB.clear();
            bToA.clear();
            sizeInternal = 0;
        },
        aCount() {
            return aToB.size;
        },
        bCount() {
            return bToA.size;
        },
        size() {
            return sizeInternal;
        },
    };
    return relation;
};

/**
 * Helper function to ensure exhaustive matching in a switch statement. Throws
 * an error if an unhandled case is encountered.
 *
 * Remember, it's useful only when we don't return anything from the switch
 * statement. Otherwise, a return type of a function is enough.
 *
 * ### Example
 *
 * ```ts
 * type Color = "red" | "green" | "blue";
 *
 * function handleColor(color: Color): void {
 *   switch (color) {
 *     case "red":
 *       console.log("Handling red");
 *       break;
 *     case "green":
 *       console.log("Handling green");
 *       break;
 *     case "blue":
 *       console.log("Handling blue");
 *       break;
 *     default:
 *       exhaustiveCheck(color); // Ensures all cases are handled
 *   }
 * }
 * ```
 */
export const exhaustiveCheck = (value) => {
    throw new Error(`exhaustiveCheck unhandled case: ${JSON.stringify(value)}`);
};
/**
 * Returns the input value unchanged.
 *
 * Useful as a default transformation, placeholder callback, or when a function
 * is required but no transformation is needed.
 *
 * ### Example
 *
 * ```ts
 * const values = [1, 2, 3];
 * const same = values.map(identity); // [1, 2, 3]
 *
 * const getTransform = (shouldDouble: boolean) =>
 *   shouldDouble ? (x: number) => x * 2 : identity;
 * ```
 */
export const identity = (a) => a;
export function readonly(value) {
    return value;
}
export const constVoid = () => undefined;
export const constUndefined = () => undefined;
export const constNull = () => null;
export const constTrue = () => true;
export const constFalse = () => false;

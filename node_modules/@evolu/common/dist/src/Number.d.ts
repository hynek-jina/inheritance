import { NonEmptyReadonlyArray } from "./Array.js";
import { Result } from "./Result.js";
import { NonNegativeInt, PositiveInt } from "./Type.js";
import { Predicate, WidenLiteral } from "./Types.js";
import { IsBranded } from "./Brand.js";
export declare const increment: (n: number) => number;
export declare const decrement: (n: number) => number;
/** Clamps a number within a given range. */
export declare const clamp: (min: number, max: number) => (n: number) => number;
/**
 * Creates a predicate that checks if a number is within a range, inclusive.
 *
 * ### Example
 *
 * ```ts
 * const isBetween10And20 = isBetween(10, 20);
 * console.log(isBetween10And20(15)); // true
 * console.log(isBetween10And20(25)); // false
 * ```
 */
export declare const isBetween: (min: number, max: number) => Predicate<number>;
/** Returns the minimum value, preserving branded type if applicable. */
export declare const min: <T extends number>(...values: [T, ...ReadonlyArray<T>]) => IsBranded<T> extends true ? T : WidenLiteral<T>;
/** Returns the maximum value, preserving branded type if applicable. */
export declare const max: <T extends number>(...values: [T, ...ReadonlyArray<T>]) => IsBranded<T> extends true ? T : WidenLiteral<T>;
/**
 * Divides items into buckets as evenly as possible, ensuring each bucket has at
 * least the minimum number of items. Returns a success result if the minimum is
 * met, or an error result with the required number of items if not.
 *
 * ### Example
 *
 * ```ts
 * computeBalancedBuckets(10, 3, 2); // Returns ok([4, 7, 10])
 * computeBalancedBuckets(5, 3, 2); // Returns err(6)
 * ```
 */
export declare const computeBalancedBuckets: (numberOfItems: NonNegativeInt, 
/** Default: 16 */
numberOfBuckets?: number & import("./Brand.js").Brand<"Int"> & import("./Brand.js").Brand<"NonNegative"> & import("./Brand.js").Brand<"Positive">, 
/** Default: 2 */
minNumberOfItemsPerBucket?: number & import("./Brand.js").Brand<"Int"> & import("./Brand.js").Brand<"NonNegative"> & import("./Brand.js").Brand<"Positive">) => Result<NonEmptyReadonlyArray<PositiveInt>, PositiveInt>;
//# sourceMappingURL=Number.d.ts.map
import { assert } from "./Assert.js";
import { createTransferableError } from "./Error.js";
/**
 * Creates a {@link Worker} that supports initialization with dependencies and
 * safe error handling.
 */
export const createInitializedWorker = ({ init, onMessage, }) => {
    let onMessageCallback = null;
    let deps = null;
    const pendingMessages = [];
    let initializing = false;
    const postMessage = (msg) => {
        assert(onMessageCallback != null, "The onMessage wasn't set");
        onMessageCallback(msg);
    };
    const postMessageTransferableError = (error) => {
        postMessage({
            type: "onError",
            error: createTransferableError(error),
        });
    };
    /**
     * Wraps function to catch errors and send them to the main thread instead of
     * crashing the worker.
     */
    const withErrorReporting = (handler) => (...args) => {
        try {
            handler(...args);
        }
        catch (error) {
            postMessageTransferableError(error);
        }
    };
    const worker = {
        postMessage: (message) => {
            if (message.type !== "init") {
                if (!deps) {
                    pendingMessages.push(message);
                }
                else {
                    withErrorReporting(onMessage(deps))(message);
                }
                return;
            }
            if (initializing)
                return;
            initializing = true;
            init(message, postMessage, withErrorReporting)
                .then((_deps) => {
                if (_deps == null)
                    return;
                deps = _deps;
                for (const message of pendingMessages) {
                    withErrorReporting(onMessage(deps))(message);
                }
                pendingMessages.length = 0;
            })
                .catch(postMessageTransferableError);
        },
        onMessage: (callback) => {
            onMessageCallback = callback;
        },
    };
    return worker;
};
/**
 * Creates a {@link Worker} with type-safe message handlers for each message
 * type. This provides better type safety and organization compared to a single
 * onMessage handler.
 */
export const createInitializedWorkerWithHandlers = ({ init, handlers, }) => createInitializedWorker({
    init,
    onMessage: (deps) => (message) => {
        const messageType = message.type;
        const handler = handlers[messageType];
        // TypeScript knows handler exists because handlers covers all non-init message types
        handler(deps)(message);
    },
});

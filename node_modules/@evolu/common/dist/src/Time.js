import { assert } from "./Assert.js";
import { DateIso, NonNegativeInt } from "./Type.js";
/**
 * Creates a {@link Time} using Date.now().
 *
 * If the system clock is misconfigured (out of allowed range), the application
 * will fail with an assertion error. This is intentional - there's no
 * reasonable fallback when the system clock is fundamentally wrong.
 */
export const createTime = () => {
    const time = {
        now: () => {
            const iso = time.nowIso();
            return new globalThis.Date(iso).getTime();
        },
        nowIso: () => {
            const iso = new globalThis.Date().toISOString();
            assert(DateIso.is(iso), "System clock returned invalid ISO date");
            return iso;
        },
    };
    return time;
};
/**
 * Creates a {@link Time} that returns a monotonically increasing number based on
 * a queueMicrotask.
 */
export const createTestTime = () => {
    let now = 0;
    const time = {
        now: () => {
            const current = now;
            queueMicrotask(() => {
                now++;
            });
            return current;
        },
        nowIso: () => DateIso.orThrow(new globalThis.Date(time.now()).toISOString()),
    };
    return time;
};
/**
 * Converts a duration to milliseconds.
 *
 * Accepts either a {@link DurationString} (e.g., "5m", "1h 30m") or milliseconds
 * as {@link NonNegativeInt}.
 *
 * ### Example
 *
 * ```ts
 * durationToNonNegativeInt("0ms"); // 0 ✅
 * durationToNonNegativeInt("500ms"); // 500 ✅
 * durationToNonNegativeInt("30s"); // 30000 ✅
 * durationToNonNegativeInt("5m"); // 300000 ✅
 * durationToNonNegativeInt("12h"); // 43200000 ✅
 * durationToNonNegativeInt("7d"); // 604800000 ✅
 * durationToNonNegativeInt("2h 45m"); // 9900000 ✅
 * durationToNonNegativeInt(5000); // 5000 ✅ (already milliseconds)
 * ```
 */
export const durationToNonNegativeInt = (duration) => {
    // If it's already a NonNegativeInt (milliseconds), return as-is
    if (typeof duration === "number") {
        return duration;
    }
    // Parse duration string without regex to avoid ReDoS vulnerabilities
    const units = {
        ms: 1,
        s: 1000,
        m: 60000,
        h: 3600000,
        d: 86400000, // 24 * 60 * 60 * 1000
    };
    let total = 0;
    let i = 0;
    while (i < duration.length) {
        // Skip whitespace
        while (i < duration.length && duration[i] === " ") {
            i++;
        }
        if (i >= duration.length)
            break;
        // Parse number
        let numStr = "";
        while (i < duration.length && duration[i] >= "0" && duration[i] <= "9") {
            numStr += duration[i];
            i++;
        }
        if (numStr === "")
            break;
        // Parse unit (ms or single char s/m/h/d)
        let unit = "";
        if (i < duration.length) {
            if (duration[i] === "m" &&
                i + 1 < duration.length &&
                duration[i + 1] === "s") {
                unit = "ms";
                i += 2;
            }
            else if (duration[i] === "s" ||
                duration[i] === "m" ||
                duration[i] === "h" ||
                duration[i] === "d") {
                unit = duration[i];
                i++;
            }
        }
        if (unit === "")
            break;
        const value = parseInt(numStr, 10);
        total += value * units[unit];
    }
    return NonNegativeInt.orThrow(total);
};

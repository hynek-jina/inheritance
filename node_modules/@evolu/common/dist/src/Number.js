import { assertNonEmptyReadonlyArray } from "./Assert.js";
import { err, ok } from "./Result.js";
import { PositiveInt } from "./Type.js";
export const increment = (n) => n + 1;
export const decrement = (n) => n - 1;
/** Clamps a number within a given range. */
export const clamp = (min, max) => (n) => Math.min(Math.max(n, min), max);
/**
 * Creates a predicate that checks if a number is within a range, inclusive.
 *
 * ### Example
 *
 * ```ts
 * const isBetween10And20 = isBetween(10, 20);
 * console.log(isBetween10And20(15)); // true
 * console.log(isBetween10And20(25)); // false
 * ```
 */
export const isBetween = (min, max) => (value) => value >= min && value <= max;
/** Returns the minimum value, preserving branded type if applicable. */
export const min = (...values) => values.reduce((a, b) => (a < b ? a : b));
/** Returns the maximum value, preserving branded type if applicable. */
export const max = (...values) => values.reduce((a, b) => (a > b ? a : b));
/**
 * Divides items into buckets as evenly as possible, ensuring each bucket has at
 * least the minimum number of items. Returns a success result if the minimum is
 * met, or an error result with the required number of items if not.
 *
 * ### Example
 *
 * ```ts
 * computeBalancedBuckets(10, 3, 2); // Returns ok([4, 7, 10])
 * computeBalancedBuckets(5, 3, 2); // Returns err(6)
 * ```
 */
export const computeBalancedBuckets = (numberOfItems, 
/** Default: 16 */
numberOfBuckets = PositiveInt.orThrow(16), 
/** Default: 2 */
minNumberOfItemsPerBucket = PositiveInt.orThrow(2)) => {
    const minRequiredItems = numberOfBuckets * minNumberOfItemsPerBucket;
    if (numberOfItems < minRequiredItems)
        return err(PositiveInt.orThrow(minRequiredItems));
    const indexes = [];
    const itemsPerBucket = Math.floor(numberOfItems / numberOfBuckets);
    const extraItems = numberOfItems % numberOfBuckets;
    let bucketBoundary = 0;
    for (let i = 0; i < numberOfBuckets; i++) {
        const hasExtraItem = i < extraItems;
        const itemsInThisBucket = itemsPerBucket + (hasExtraItem ? 1 : 0);
        bucketBoundary += itemsInThisBucket;
        indexes.push(PositiveInt.orThrow(bucketBoundary));
    }
    assertNonEmptyReadonlyArray(indexes);
    return ok(indexes);
};

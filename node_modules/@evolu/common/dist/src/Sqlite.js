import { createLruCache } from "./Cache.js";
import { eqArrayNumber } from "./Eq.js";
import { createTransferableError } from "./Error.js";
import { err, ok, tryAsync, trySync } from "./Result.js";
import { Null, Number, PositiveInt, String, Uint8Array, union, } from "./Type.js";
/**
 * A value that can be stored in Sqlite.
 *
 * Note that Evolu can't support Int64 because expo-sqlite (and some others) do
 * not support it.
 */
export const SqliteValue = union(Null, String, Number, Uint8Array);
export const eqSqliteValue = (x, y) => {
    if (x instanceof globalThis.Uint8Array &&
        y instanceof globalThis.Uint8Array) {
        return eqArrayNumber(x, y);
    }
    return x === y;
};
/**
 * Creates a fully featured {@link Sqlite} instance from a {@link SqliteDriver}
 * implementation.
 */
export const createSqlite = (deps) => async (name, options) => tryAsync(async () => {
    const driver = await deps.createSqliteDriver(name, options);
    let isDisposed = false;
    const doRollback = () => trySync(() => {
        deps.console?.log("[sql] rollback");
        driver.exec(sql `rollback;`, true);
    }, createSqliteError);
    const sqlite = {
        exec: (query) => trySync(() => {
            deps.console?.log("[sql]", { query });
            const result = maybeLogSqliteQueryExecutionTime(query, () => driver.exec(query, isSqlMutation(query.sql)));
            deps.console?.log("[sql]", { result });
            return result;
        }, (error) => ({
            type: "SqliteError",
            error: createTransferableError(error),
        })),
        transaction: (callback) => {
            const transactionResult = trySync(() => {
                deps.console?.log("[sql] begin");
                driver.exec(sql `begin;`, true);
                const result = callback();
                if (!result.ok)
                    return result;
                deps.console?.log("[sql] commit");
                driver.exec(sql `commit;`, true);
                return result;
            }, createSqliteError);
            // There was an SqliteError during begin, callback, or commit
            if (!transactionResult.ok) {
                const rollback = doRollback();
                if (!rollback.ok) {
                    deps.console?.log("[sql] rollback failed", rollback.error);
                    return err({
                        type: "SqliteError",
                        error: transactionResult.error.error,
                        rollbackError: rollback.error.error,
                    });
                }
                return transactionResult;
            }
            // Callback returned an error
            if (!transactionResult.value.ok) {
                const rollback = doRollback();
                if (!rollback.ok) {
                    deps.console?.log("[sql] rollback failed", rollback.error);
                    return err({
                        type: "SqliteError",
                        error: createTransferableError(transactionResult.value.error),
                        rollbackError: rollback.error.error,
                    });
                }
                return transactionResult.value;
            }
            return ok(transactionResult.value.value);
        },
        export: () => trySync(() => {
            return driver.export();
        }, (error) => ({
            type: "SqliteError",
            error: createTransferableError(error),
        })),
        [Symbol.dispose]: () => {
            if (isDisposed)
                return;
            isDisposed = true;
            driver[Symbol.dispose]();
        },
    };
    return sqlite;
}, createSqliteError);
const createSqliteError = (error) => ({
    type: "SqliteError",
    error: createTransferableError(error),
});
const maybeLogSqliteQueryExecutionTime = (query, callback) => {
    if (!query.options?.logQueryExecutionTime) {
        return callback();
    }
    const start = performance.now();
    const result = callback();
    const elapsed = performance.now() - start;
    // eslint-disable-next-line no-console
    console.log(`SqliteQueryExecutionTime: ${elapsed.toString()}ms`, query);
    return result;
};
export const createPreparedStatementsCache = (factory, disposeFn) => {
    let isDisposed = false;
    const cache = new Map();
    return {
        get: (query, alwaysPrepare) => {
            if (alwaysPrepare !== true && !query.options?.prepare)
                return null;
            let statement = cache.get(query.sql);
            if (!statement) {
                statement = factory(query.sql);
                cache.set(query.sql, statement);
            }
            return statement;
        },
        [Symbol.dispose]: () => {
            if (isDisposed)
                return;
            isDisposed = true;
            cache.forEach(disposeFn);
            cache.clear();
        },
    };
};
/**
 * Creates a safe SQL query using a tagged template literal.
 *
 * Parameters are automatically escaped and bound as SQLite values. Use
 * `sql.identifier` for column/table names and `sql.raw` for unescaped SQL.
 *
 * ### Example
 *
 * ```ts
 * const id = 42;
 * const name = "Alice";
 *
 * const result = sqlite.exec(sql`
 *   select *
 *   from users
 *   where id = ${id} and name = ${name};
 * `);
 *
 * // For identifiers
 * const tableName = "users";
 * sqlite.exec(sql`
 *   create table ${sql.identifier(tableName)} (
 *     "id" text primary key,
 *     "name" text not null
 *   );
 * `);
 *
 * // For raw SQL (use with caution)
 * const orderBy = "created_at desc";
 * sqlite.exec(sql`select * from users order by ${sql.raw(orderBy)};`);
 * ```
 *
 * ### TIP
 *
 * Use `prettier-plugin-sql-cst` for SQL formatting. Like Prettier for
 * JavaScript, this plugin formats SQL expressions differently depending on
 * their length.
 */
export const sql = (strings, ...parameters) => {
    let sql = "";
    const values = [];
    for (let i = 0; i < strings.length; i++) {
        sql += strings[i];
        if (i < parameters.length) {
            const param = parameters[i];
            if (typeof param === "object" && param != null && "type" in param) {
                sql += param.sql;
            }
            else {
                sql += "?";
                values.push(param);
            }
        }
    }
    return { sql: sql, parameters: values };
};
sql.identifier = (identifier) => ({
    type: "SqlIdentifier",
    // From Kysely
    sql: `"${identifier.replace(/"/g, '""')}"`,
});
/**
 * Insert any string.
 *
 * Sql.raw sometimes breaks auto-formatting because the parser does not consider
 * it valid SQL. A workaround is to remove it, format it, and put it back.
 *
 * **Warning**: This is not escaped.
 */
sql.raw = (raw) => ({ type: "RawSql", sql: raw });
sql.prepared = (strings, ...parameters) => {
    const query = sql(strings, ...parameters);
    return { ...query, options: { prepare: true } };
};
/**
 * Checks if a SQL string contains mutation keywords (insert, update, delete,
 * etc.). Results are cached for performance.
 */
export const isSqlMutation = (sql) => {
    /**
     * Without cache, "insert 1_000_000" Storage test dropped from 57742
     * inserts/sec to 34k. Regex we used was fast, but CodeQL flagged it as a
     * potential ReDoS vulnerability, so manual comment removal was the only
     * option. LRU cache restores performance.
     */
    const cached = isSqlMutationCache.get(sql);
    if (cached !== undefined)
        return cached;
    const result = isSqlMutationRegEx.test(removeSqlComments(sql));
    isSqlMutationCache.set(sql, result);
    return result;
};
const isSqlMutationCache = createLruCache(PositiveInt.orThrow(10_000));
const isSqlMutationRegEx = new RegExp(`\\b(${[
    "alter",
    "create",
    "delete",
    "drop",
    "insert",
    "replace",
    "update",
    "begin",
    "commit",
    "rollback",
    "pragma",
    "vacuum",
].join("|")})\\b`, "i");
/**
 * Removes SQL line comments (--) from a SQL string without using regex to avoid
 * ReDoS vulnerabilities.
 */
const removeSqlComments = (sql) => {
    // Fast path: if there are no comments, return the original string
    if (!sql.includes("--"))
        return sql;
    let result = "";
    let i = 0;
    while (i < sql.length) {
        // Check for comment start
        if (i < sql.length - 1 && sql[i] === "-" && sql[i + 1] === "-") {
            // Skip until end of line or end of string
            i += 2;
            while (i < sql.length && sql[i] !== "\n") {
                i++;
            }
            // Keep the newline if present
            if (i < sql.length && sql[i] === "\n") {
                result += "\n";
                i++;
            }
        }
        else {
            result += sql[i];
            i++;
        }
    }
    return result;
};
export const explainSqliteQueryPlan = (deps) => (query) => {
    const result = deps.sqlite.exec({
        ...query,
        sql: `EXPLAIN QUERY PLAN ${query.sql}`,
    });
    if (!result.ok)
        return result;
    // eslint-disable-next-line no-console
    console.log("[explainSqliteQueryPlan]", query);
    // eslint-disable-next-line no-console
    console.log(drawSqliteQueryPlan(result.value.rows));
    return ok();
};
const drawSqliteQueryPlan = (rows) => rows
    .map((row) => {
    let parentId = row.parent;
    let indent = 0;
    do {
        const parent = rows.find((r) => r.id === parentId);
        if (!parent)
            break;
        parentId = parent.parent;
        indent++;
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, no-constant-condition
    } while (true);
    return `${"  ".repeat(indent)}${row.detail}`;
})
    .join("\n");
/**
 * SQLite represents boolean values using `0` (false) and `1` (true) instead of
 * a dedicated boolean type.
 *
 * See: https://www.sqlite.org/quirks.html#no_separate_boolean_datatype
 *
 * ### Tips
 *
 * - Use {@link sqliteTrue} and {@link sqliteFalse} constants for better
 *   readability.
 * - Use {@link booleanToSqliteBoolean} and {@link sqliteBooleanToBoolean} for
 *   converting between JavaScript booleans and SQLite boolean values.
 */
export const SqliteBoolean = union(0, 1);
/**
 * Represents the {@link SqliteBoolean} value for `true`.
 *
 * See {@link SqliteBoolean}.
 */
export const sqliteTrue = 1;
/**
 * Represents the {@link SqliteBoolean} value for `false`.
 *
 * See {@link SqliteBoolean}.
 */
export const sqliteFalse = 0;
/**
 * Converts a JavaScript boolean to a {@link SqliteBoolean}.
 *
 * ### Example
 *
 * ```ts
 * const isActive = true;
 * const sqlValue = booleanToSqliteBoolean(isActive); // Returns 1
 * ```
 */
export const booleanToSqliteBoolean = (value) => value ? sqliteTrue : sqliteFalse;
/**
 * Converts a {@link SqliteBoolean} to a JavaScript boolean.
 *
 * ### Example
 *
 * ```ts
 * const sqlValue: SqliteBoolean = 1;
 * const bool = sqliteBooleanToBoolean(sqlValue); // Returns true
 * ```
 */
export const sqliteBooleanToBoolean = (value) => value === sqliteTrue;

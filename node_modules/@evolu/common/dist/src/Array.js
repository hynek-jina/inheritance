/**
 * Array types, type guards, operations, transformations, accessors, and (rare)
 * mutations
 *
 * ### Example
 *
 * ```ts
 * // Types - compile-time guarantee of at least one element
 * const _valid: NonEmptyReadonlyArray<number> = [1, 2, 3];
 * // ts-expect-error - empty array is not a valid NonEmptyReadonlyArray
 * const _invalid: NonEmptyReadonlyArray<number> = [];
 *
 * // Type guards
 * const arr: ReadonlyArray<number> = [1, 2, 3];
 * if (isNonEmptyReadonlyArray(arr)) {
 *   firstInArray(arr);
 * }
 *
 * // Operations
 * const appended = appendToArray([1, 2, 3], 4); // [1, 2, 3, 4]
 * const prepended = prependToArray([2, 3], 1); // [1, 2, 3]
 *
 * // Transformations
 * const readonly: ReadonlyArray<number> = [1, 2, 3];
 * const mapped = mapArray(readonly, (x) => x * 2); // [2, 4, 6]
 * const filtered = filterArray(readonly, (x) => x > 1); // [2, 3]
 * const deduped = dedupeArray([1, 2, 1, 3, 2]); // [1, 2, 3]
 * const [evens, odds] = partitionArray(
 *   [1, 2, 3, 4, 5],
 *   (x) => x % 2 === 0,
 * ); // [[2, 4], [1, 3, 5]]
 *
 * // Accessors
 * const first = firstInArray(["a", "b", "c"]); // "a"
 * const last = lastInArray(["a", "b", "c"]); // "c"
 *
 * // Mutations
 * const mutable: NonEmptyArray<number> = [1, 2, 3];
 * shiftArray(mutable); // 1 (guaranteed to exist)
 * mutable; // [2, 3]
 * ```
 *
 * Functions are intentionally data-first to be prepared for the upcoming
 * JavaScript pipe operator.
 *
 * ```ts
 * // Data-first is natural for single operations.
 * const timestamps = mapArray(messages, (m) => m.timestamp);
 *
 * // But data-first can be hard to read for nested calls.
 * const result = firstInArray(
 *   mapArray(dedupeArray(appendToArray(value, 2)), (x) => x * 2),
 * );
 *
 * // With the upcoming pipe operator, it's clear.
 * // const result = value
 * //   |> appendToArray(%, 2)
 * //   |> dedupeArray(%)
 * //   |> mapArray(%, (x) => x * 2)
 * //   |> firstInArray(%);
 *
 * // Until the pipe operator lands, use nested calls or name each step:
 * const appended = appendToArray(value, 2);
 * const deduped = dedupeArray(appended);
 * const mapped = mapArray(deduped, (x) => x * 2);
 * const result = firstInArray(mapped);
 * ```
 *
 * ### Why data-first?
 *
 * Evolu optimizes for consistent code style. We can't have both data-first
 * single operations and curried data-last helpers without sacrificing
 * consistency. We chose data-first because:
 *
 * - It's natural for single operations (for example `mapArray(messages, (m) =>
 *   m.timestamp)`).
 * - It aligns with the upcoming JavaScript pipe operator.
 *
 * **Note**: Feel free to use Array instance methods (mutation) if you think
 * it's better (performance, local scope, etc.).
 *
 * @module
 */
/**
 * Checks if an array is non-empty and narrows its type to {@link NonEmptyArray}.
 *
 * Use `if (!isNonEmptyArray(arr))` for empty checks.
 *
 * ### Example
 *
 * ```ts
 * const arr: Array<number> = [1, 2, 3];
 * if (isNonEmptyArray(arr)) {
 *   firstInArray(arr); // arr is NonEmptyArray<number>
 * }
 * ```
 *
 * @category Type Guards
 */
export const isNonEmptyArray = (array) => array.length > 0;
/**
 * Checks if a readonly array is non-empty and narrows its type to
 * {@link NonEmptyReadonlyArray}.
 *
 * Use `if (!isNonEmptyReadonlyArray(arr))` for empty checks.
 *
 * ### Example
 *
 * ```ts
 * const arr: ReadonlyArray<number> = [1, 2, 3];
 * if (isNonEmptyReadonlyArray(arr)) {
 *   firstInArray(arr); // arr is NonEmptyReadonlyArray<number>
 * }
 * ```
 *
 * @category Type Guards
 */
export const isNonEmptyReadonlyArray = (array) => array.length > 0;
/**
 * Appends an item to an array, returning a new non-empty readonly array.
 *
 * Accepts both mutable and readonly arrays. Does not mutate the original array.
 *
 * ### Example
 *
 * ```ts
 * appendToArray([1, 2, 3], 4); // [1, 2, 3, 4]
 * ```
 *
 * @category Operations
 */
export const appendToArray = (array, item) => [...array, item];
/**
 * Prepends an item to an array, returning a new non-empty readonly array.
 *
 * Accepts both mutable and readonly arrays. Does not mutate the original array.
 *
 * ### Example
 *
 * ```ts
 * prependToArray([2, 3], 1); // [1, 2, 3]
 * ```
 *
 * @category Operations
 */
export const prependToArray = (array, item) => [item, ...array];
export function mapArray(array, mapper) {
    return array.map(mapper);
}
export function filterArray(array, predicate) {
    return array.filter(predicate);
}
export function dedupeArray(array, by) {
    if (by == null) {
        return Array.from(new Set(array));
    }
    const seen = new Set();
    return array.filter((item) => {
        const key = by(item);
        if (seen.has(key))
            return false;
        seen.add(key);
        return true;
    });
}
export function partitionArray(array, predicate) {
    const trueArray = [];
    const falseArray = [];
    for (let i = 0; i < array.length; i++) {
        if (predicate(array[i], i)) {
            trueArray.push(array[i]);
        }
        else {
            falseArray.push(array[i]);
        }
    }
    return [trueArray, falseArray];
}
/**
 * Returns the first element of a non-empty array.
 *
 * Accepts both mutable and readonly arrays. Does not mutate the original array.
 *
 * ### Example
 *
 * ```ts
 * firstInArray(["a", "b", "c"]); // "a"
 * ```
 *
 * @category Accessors
 */
export const firstInArray = (array) => array[0];
/**
 * Returns the last element of a non-empty array.
 *
 * Accepts both mutable and readonly arrays. Does not mutate the original array.
 *
 * ### Example
 *
 * ```ts
 * lastInArray(["a", "b", "c"]); // "c"
 * ```
 *
 * @category Accessors
 */
export const lastInArray = (array) => array[array.length - 1];
/**
 * Shifts an item from a non-empty mutable array, guaranteed to return T.
 *
 * **Mutates** the original array.
 *
 * ### Example
 *
 * ```ts
 * const arr: NonEmptyArray<number> = [1, 2, 3];
 * shiftArray(arr); // 1
 * arr; // [2, 3]
 * ```
 *
 * @category Mutations
 */
export const shiftArray = (array) => array.shift();
/**
 * Pops an item from a non-empty mutable array, guaranteed to return T.
 *
 * **Mutates** the original array.
 *
 * ### Example
 *
 * ```ts
 * const arr: NonEmptyArray<number> = [1, 2, 3];
 * popArray(arr); // 3
 * arr; // [1, 2]
 * ```
 *
 * @category Mutations
 */
export const popArray = (array) => array.pop();

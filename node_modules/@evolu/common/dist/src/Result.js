export function ok(value = undefined) {
    return { ok: true, value: value };
}
/**
 * Creates an {@link Err} result.
 *
 * ### Example
 *
 * ```ts
 * const failure = err("Something went wrong");
 * console.log(failure); // { ok: false, error: "Something went wrong" }
 * ```
 */
export const err = (error) => ({ ok: false, error });
/**
 * Extracts the value from a {@link Result} if it is an `Ok`, or throws an error
 * if it is an `Err`.
 *
 * **Intended usage:**
 *
 * - For critical code paths (e.g., app startup, config values) where failure
 *   should crash the app.
 * - Not recommended for general error handling in application logicâ€”prefer
 *   explicit checks.
 *
 * ### Example
 *
 * ```ts
 * // At app startup, crash if config is invalid:
 * const config = getOrThrow(loadConfig());
 * // Safe to use config here
 * ```
 *
 * Throws: `Error` with the original error attached as `cause`.
 */
export const getOrThrow = (result) => {
    if (result.ok) {
        return result.value;
    }
    else {
        throw new Error("getOrThrow", { cause: result.error });
    }
};
/**
 * Extracts the value from a {@link Result} if it is an `Ok`, or returns `null`
 * if it is an `Err`.
 *
 * **Intended usage:**
 *
 * - When you need to convert a `Result` to a nullable value for APIs that expect
 *   `T | null`.
 * - When the error is not important and you just want the value or nothing.
 *
 * ### Example
 *
 * ```ts
 * const parseResult = parseJson('{"key": "value"}');
 * const value = getOrNull(parseResult);
 * // value is unknown | null
 *
 * if (value != null) {
 *   console.log("Parsed value:", value);
 * }
 * ```
 */
export const getOrNull = (result) => result.ok ? result.value : null;
/**
 * Wraps synchronous functions that may throw exceptions, returning a
 * {@link Result}.
 *
 * The `trySync` function is designed to handle synchronous code safely by
 * wrapping the execution in a try-catch block. If the function succeeds, it
 * returns an `Ok` result. If an exception is thrown, it maps the error to a
 * custom type and returns an `Err` result.
 *
 * ### Example
 *
 * ```ts
 * interface ParseJsonError {
 *   readonly type: "ParseJsonError";
 *   readonly message: string;
 * }
 *
 * const parseJson = (value: string): Result<unknown, ParseJsonError> =>
 *   trySync(
 *     () => JSON.parse(value) as unknown,
 *     (error): ParseJsonError => ({
 *       type: "ParseJsonError",
 *       message: String(error),
 *     }),
 *   );
 * ```
 */
export const trySync = (fn, mapError) => {
    try {
        return ok(fn());
    }
    catch (error) {
        return err(mapError(error));
    }
};
/**
 * Wraps async functions or any operation returning a promise, returning a
 * {@link Result}.
 *
 * The `tryAsync` function provides a way to handle asynchronous code safely by
 * catching any rejected promises and mapping errors to a custom type. If the
 * promise resolves, it returns an `Ok` result. If the promise rejects, it maps
 * the error and returns an `Err` result.
 *
 * ### Example
 *
 * ```ts
 * interface FetchError {
 *   readonly type: "FetchError";
 *   readonly message: string;
 * }
 *
 * const tryFetch = async (
 *   url: string,
 * ): Promise<Result<unknown, FetchError>> =>
 *   tryAsync(
 *     async () => {
 *       const response = await fetch(url);
 *       if (!response.ok) {
 *         throw new Error(`Request failed with status ${response.status}`);
 *       }
 *       return response.json();
 *     },
 *     (error) => ({
 *       type: "FetchError",
 *       message: String(error),
 *     }),
 *   );
 *
 * const result = await tryFetch(
 *   "https://jsonplaceholder.typicode.com/posts/1",
 * );
 * if (result.ok) {
 *   console.log("Data:", result.value);
 * } else {
 *   console.error("Error:", result.error);
 * }
 * ```
 */
export const tryAsync = async (promiseFn, mapError) => promiseFn().then((value) => ok(value), (error) => err(mapError(error)));
